[{"title":"2020的最后一天，不妨了解下装饰器","url":"/2020%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9%EF%BC%8C%E4%B8%8D%E5%A6%A8%E4%BA%86%E8%A7%A3%E4%B8%8B%E8%A3%85%E9%A5%B0%E5%99%A8.html","content":"\n\n\n\n装饰器目前还处于提案阶段，要在javascript中使用装饰器，我们必须借助babel或typescript的转码能力\n\n为什么要用装饰器引入装饰器更能够便于代码逻辑的解藕和复用。举一个例子\n举一个非常常见的需求。假设我们有一个类Network，它有一个异步getList方法\nclass Network &#123;  async getList() &#123;    return await list();  &#125;&#125;\n\n有一天，我们想给它加个全局loading，那么我们可能会这么写\nclass Network &#123;  async getList() &#123;    loading.show();    const res = await list();    loading.hide();    return res;  &#125;&#125;\n\n如果需要对另一个方法使用全局 loading，可能又需要再写一遍。并且这个代码还入侵了函数本身的逻辑。这时候使用装饰器就可以相对优雅解决这个问题。\n实现一个loadingDecorator装饰器\nfunction loadingDecorator(target, key, descriptor) &#123;  descriptor.value = async function (...args) &#123;    loading.show();    await descriptor.value.apply(this, args);    loading.hide();  &#125;;&#125;\n\n使用我们的装饰器\nclass Network &#123;  @loadingDecorator  async getList() &#123;    return await list();  &#125;&#125;\n\n这样，每当一个方法需要加 loading 的时候，给它使用@loadingDecorator装饰器即可。这样即逻辑解藕又能实现比较好的代码复用\n经过typescript转码后的代码长这样，感兴趣的同学可以看看\nvar __decorate = (this &amp;&amp; this.__decorate) || function (decorators, target, key, desc) &#123;    var c = arguments.length, r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;    if (typeof Reflect === &quot;object&quot; &amp;&amp; typeof Reflect.decorate === &quot;function&quot;) r = Reflect.decorate(decorators, target, key, desc);    else for (var i = decorators.length - 1; i &gt;= 0; i--) if (d = decorators[i]) r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r;    return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r;&#125;;\n\n什么是装饰器装饰器是一种特殊的声明，可以作用在类的声明、方法、属性、访问器或者参数上。装饰器的用法是@decorator。decorator是一个函数，会在运行时的时候调用，对类进行一些修改。需要注意的是，在javascript中，装饰器只能用于类，不能作用于普通函数。原因是函数会存在函数提升，设计者为了减少一些复杂性，可以参照一个讨论\n如下就是定义一个装饰器函数，并且作用在类上\nfunction sealed(target) &#123;  // do something with &#x27;target&#x27; ...&#125;@sealedclass A &#123;&#125;\n\n其实就是类似于以下代码\nA = sealed(A);\n\n\n装饰器工厂\n\n装饰器本质就是一个函数，所以也可以利用闭包的能力实现更多功能。装饰器工厂就是一个返回函数的函数，运行时将会被调用\n// 例如一个添加颜色的工厂装饰器function addColor(color: string) &#123;  console.log(&quot;run&quot;, color);  return function (target) &#123;    if (!target.colorList) &#123;      target.colorList = [];    &#125;    target.colorList.push(color);  &#125;;&#125;@addColor(&quot;red&quot;)class People &#123;&#125;new People().colorList; // [&#x27;red&#x27;]\n\n\n多个装饰器组合装饰器也是支持多个一起使用的，还是上面 color 例子，添加多个 不同的color的装饰器\n\n@addColor(&quot;blue&quot;)@addColor(&quot;red&quot;)@addColor(&quot;yellow&quot;)class People &#123;&#125;// log: run blue// log: run red// log: run yellownew People().colorList; // [&#x27;yellow&#x27;,&#x27;red&#x27;,&#x27;blue&#x27;]\n\n从上面的信息，可以知道。\n\n装饰器定义的执行顺序是从上到下\n装饰器运行时装饰 class 的顺序是从下到上\n\n装饰器的基本用法类装饰器 (Class Decorators)类装饰器作用于类的构造函数，可用于修改或者替换一个 class 定义\n一个装饰器函数签名如下：\ntype decorator = (target: Function) =&gt; Function | void;\n\n它接收被装饰的 class 作为target函数的参数，如果装饰器函数有返回值，则使用这个返回值作为新的 class。\n\n无返回值\n\n// 例如想直接修改一个class，给它新增一个静态方法function addLog(target) &#123;  target.log = function () &#123;    console.log(&quot;hello world&quot;);  &#125;;&#125;@addLogclass People &#123;&#125;People.log(); // &#x27;hello world&#x27;\n\n\n有返回值\n\n当然，上面有返回值的形式直接返回也行。\n// 例如想继承被装饰的classfunction logName(target) &#123;  return class extends target &#123;    log() &#123;      console.log(this.name);    &#125;  &#125;;&#125;@logNameclass People &#123;  name = &quot;hello world&quot;;&#125;new People().log(); // hello world\n\n类成员装饰器下面列举的几个都是装饰到类的成员上，所以都可以归为一类\n属性装饰器 （Property Decorators）属性装饰器用于装饰属性，函数签名如下\ntype decorator = (  target: Target | Target.prototype,  propertyKey: string) =&gt; void;\n\n属性装饰器的参数定义如下：\n1、第一个参数。如果装饰的是静态方法，则是这个类 Target 本身；如果装饰的是原型方法，则是类的原型对象 Target.prototype\n2、第二个参数。这个属性的名称\n属性装饰器的返回值是被忽略的，所以如果需要修改属性值。分两种情况\n\n静态属性，可以直接使用Object.getOwnPropertyDescriptor(target, propertyKey)和Object.defineProperty(target,propertyKey,&#123;&#125;)来获取和修改descriptor\n如果是实例属性，则不能直接很方便的进行修改，因为 class 还没有进行实例化。何为定义实例属性，即如通过babel-plugin-proposal-class-properties直接语法定义的属性\n\nclass Target &#123;  a = 1;&#125;\n\n但这样的装饰器也不是没有作用，在 typescript 中可以很方便的收集元类型信息，后面的文章会说到\n方法装饰器 (Method Decorators)方法装饰器就是用来装饰方法，可以用来修改方法的定义。方法装饰器的函数签名如下\ntype decorator = (  target: Target | Target.prototype,  propertyKey: string,  descriptor: PropertyDescriptor) =&gt; Function | void;\n\n方法装饰器的参数定义如下：\n1、第一个参数。如果装饰的是静态方法，则是这个类Target本身；如果装饰的是原型方法，则是类的原型对象Target.prototype\n2、第二个参数。这个方法的名称\n3、第三个参数，这个方法的属性描述符，通过descriptor.value可以直接拿到这个方法\n如果属性装饰器有返回值，这个返回值讲作为这个方法的属性描述符。对象的属性描述符就是调用Reflect.getOwnPropertyDescriptor(target, propertyKey)的返回值，详细可见\nconst obj = &#123; a: 1 &#125;;Reflect.getOwnPropertyDescriptor(obj, &quot;a&quot;);/**&#123;value: 1, writable: true, enumerable: true, configurable: true&#125;**/\n\nfunction log(target, key, descriptor) &#123;  console.log(target, key, descriptor);&#125;\n\n\n静态/原型方法装饰器给方法添加 log\n\n// 静态或者动态方法添加logfunction log(target, key, descriptor) &#123;  const origin = descriptor.value;  descriptor.value = function (...args) &#123;    console.log(&quot;静态log: &quot;, key);    origin.apply(this, args);  &#125;;&#125;\n\n访问器装饰器 (Accessor Decorators)参数装饰器 (Parameter Decorators)参数装饰器的函数签名如下\ntype decorator = (  target: Target | Target.prototype,  propertyKey: string,  parameterIndex: number) =&gt; void;\n\n参数装饰器的参数定义如下：\n1、第一个参数。如果装饰的是静态方法的参数，则是这个类Target本身；如果装饰的是原型方法的参数，则是类的原型对象Target.prototype\n2、第二个参数。参数所处的函数名称\n3、第三个参数，该参数位于函数参数列表的位置下标(number)\n各种装饰器的执行顺序如下：\n1、先执行实例成员装饰器（非静态的），再执行静态成员装饰器\n2、执行成员的装饰器时，先执行参数装饰器，再执行作用于成员的装饰器\n3、执行完 1、2 后，执行构造函数的参数装饰器；最后执行作用于 class 的装饰器\ntypescript 更强大的装饰器在vue-property-decorator中的应用上面提到的一些用法更多是 javascript 场景中使用装饰器优化我们代码的结构，在typescript中，装饰器还有有一个更强大的功能，就是能在运行时去拿到我们在typescript定义的时候类型信息。\n如果用过typescript写vue的同学，一般会用到vue-decorator-property这个库。在Prop我们可以看到文档这样写\n\nIf you’d like to set type property of each prop value from its type definition, you can use reflect-metadata.Set emitDecoratorMetadata to true.Import reflect-metadata before importing vue-property-decorator (importing reflect-metadata is needed just once.)\n\nimport &quot;reflect-metadata&quot;;import &#123; Vue, Component, Prop &#125; from &quot;vue-property-decorator&quot;;@Componentexport default class MyComponent extends Vue &#123;  @Prop() age!: number;&#125;\n\n我们就不需要去在Prop的options的 type 再去定义一遍这个属性告诉 vue 了。这个能力正是typescript的emitDecoratorMetadata特性提供的。我们看上面的代码经过 ts 编译后的效果如下，地址\nimport &#123; __decorate, __metadata &#125; from &quot;tslib&quot;;import &quot;reflect-metadata&quot;;import &#123; Vue, Component, Prop &#125; from &quot;vue-property-decorator&quot;;let MyComponent = class MyComponent extends Vue &#123;&#125;;__decorate(  [Prop(), __metadata(&quot;design:type&quot;, Number)],  MyComponent.prototype,  &quot;age&quot;,  void 0);MyComponent = __decorate([Component], MyComponent);export default MyComponent;\n\n可见我们的类型信息被收集到 metadata 的design:type中，通过reflect-metadata提供的一些方法我们就能在运行时拿到这个类型信息。\n可以理解为将每个被装饰的类/属性/方法的类型存放到一个全局的地方，key 为design:type。后续处理的时候可以通过class/method/key拿到这个类型信息，做一些我们想做的事情。\n在 node 中的应用\n来自深入理解 typescript的例子\n\n如果我们想基于 class 声明编写 http 接口，而不是写很多router.get/router.post这样写法。例如如下：\n@Controller(&quot;/test&quot;)class SomeClass &#123;  @Get(&quot;/a&quot;)  someGetMethod() &#123;    return &quot;hello world&quot;;  &#125;  @Post(&quot;/b&quot;)  somePostMethod() &#123;&#125;&#125;\n\n很显然，这里我们是定义了两个接口，分别是/test/a和test/b。这里的关键就在于实现Controller和Post/Get装饰器\nController作用于 class 上，我们定义一个元信息key并使用Reflect.defineMetadata存对应的元信息\nconst PATH_METADATA = Symbol(&#x27;path&#x27;)；const Controller = (path: string): ClassDecorator =&gt; &#123;  return target =&gt; &#123;    Reflect.defineMetadata(PATH_METADATA, path, target);  &#125;&#125;\n\n再实现一个工厂装饰器，返回Get/Post\nconst PATH_METADATA = Symbol(&#x27;path&#x27;)；const METHOD_METADATA = Symbol(&#x27;method&#x27;)；const createMappingDecorator = (method: string) =&gt; (path: string): MethodDecorator =&gt; &#123;  return (target, key, descriptor) =&gt; &#123;    Reflect.defineMetadata(PATH_METADATA, path,target, key;    Reflect.defineMetadata(METHOD_METADATA, method, target, key);  &#125;&#125;const Get = createMappingDecorator(&#x27;GET&#x27;);const Post = createMappingDecorator(&#x27;POST&#x27;);\n\ncreateMappingDecorator接收一个参数（表示这是Get还是Post），返回一个装饰器。装饰器调用defineMetadata存了PATH_METADATA和METHOD_METADATA两个 key，value 分别是请求路径和方法。\n所以综上装饰后，可以类比一个以下形式的存储结构\n&#123;    [PATH_METADATA]: &#123;        UNDEIFINED: &#x27;/test&#x27;        GET:&#123;            someGetMethod: &#x27;/test&#x27;        &#125;,        POST:&#123;            somePostMethod: &#x27;/test&#x27;        &#125;    &#125;,    [METHOD_METADATA]: &#123;        GET:&#123;            someGetMethod: &#x27;/a&#x27;        &#125;,        POST:&#123;            somePostMethod:&#x27;/b&#x27;        &#125;    &#125;&#125;\n\n取值并映射函数生成route\n// 取值function mapRoute(instance: Object) &#123;  const prototype = Object.getPrototypeOf(instance);  // 筛选出类的 methodName  const methodsNames = Object.getOwnPropertyNames(prototype)                              .filter(item =&gt; !isConstructor(item) &amp;&amp; isFunction(prototype[item]))；  return methodsNames.map(methodName =&gt; &#123;    const fn = prototype[methodName];    // 通过metadataKey, target, propertyKey取出定义的 metadata    const route = Reflect.getMetadata(PATH_METADATA, instance, methodName);// /a or /b    const method = Reflect.getMetadata(METHOD_METADATA, instance, methodName);// GET or POST    return &#123;      route,      method,      fn,      methodName,      pre     &#125;  &#125;)&#125;;Reflect.getMetadata(PATH_METADATA, SomeClass); // &#x27;/test&#x27;mapRoute(new SomeClass());/** * [&#123; *    route: &#x27;/a&#x27;, *    method: &#x27;GET&#x27;, *    fn: someGetMethod() &#123; ... &#125;, *    methodName: &#x27;someGetMethod&#x27; *  &#125;,&#123; *    route: &#x27;/b&#x27;, *    method: &#x27;POST&#x27;, *    fn: somePostMethod() &#123; ... &#125;, *    methodName: &#x27;somePostMethod&#x27; * &#125;] * */\n\n最后，只需把 route 相关信息绑在对应的http框架上即可\nreflect-metadata更多api可以参考\ntypedi最后再简单介绍介绍typedi\n\n引用文档的介绍。\n\ntypedi是一个 typescript(javascript)的依赖注入工具，可以在 node.js 和浏览器中构造易于测试和良好架构的应用程序。主要有以下特性：\n\n基于属性/构造函数的依赖注入\n单例/临时服务\n可以支持多个container\n\n官网例子，非常方便实现依赖注入使用\nimport &#123; Container, Service &#125; from &#x27;typedi&#x27;;@Service()class ExampleInjectedService &#123;  printMessage() &#123;    console.log(&#x27;I am alive!&#x27;);  &#125;&#125;@Service()class ExampleService &#123;  constructor(    // because we annotated ExampleInjectedService with the @Service()    // decorator TypeDI will automatically inject an instance of    // ExampleInjectedService here when the ExampleService class is requested    // from TypeDI.    private injectedService: ExampleInjectedService  ) &#123;&#125;&#125;const serviceInstance = Container.get(ExampleService);// we request an instance of ExampleService from TypeDIserviceInstance.injectedService.printMessage();// logs &quot;I am alive!&quot; to the console\n\n最后码字不易，一键三连的人明年会有好运哦，祝大家新年快乐！！！\n参考资料typescript Decorators\n深入理解 typescript\n","categories":["原生"],"tags":["原生"]},{"title":"3分钟掌握react hook 在typescript中的姿势","url":"/3%E5%88%86%E9%92%9F%E6%8E%8C%E6%8F%A1react%20hook%20%E5%9C%A8typescript%E4%B8%AD%E7%9A%84%E5%A7%BF%E5%8A%BF.html","content":"\n\n\n\nhook结合typescript可以说是很香了。本文主要介绍hook结合typescript 如何使用，享受ts带给我们的编辑器提示和类型约束\n\nuseStateuseState如果初始值不是null/undefined的话，是具备类型推导能力的，根据传入的初始值推断出类型；初始值是 null/undefined的话则需要传递类型定义才能进行约束。一般情况下，还是推荐传入类型（通过useState的第一个泛型参数）。\n// 这里ts可以推断 value的类型并且能对setValue函数调用进行约束const [value, setValue] = useState(0);interface MyObject &#123;  foo: string;  bar?: number;&#125;// 这里需要传递MyObject才能约束 value, setValue// 一般情况下推荐传入类型const [value, setValue] = useState&lt;MyObject&gt;(null);\n\nuseContextuseContext一般根据传入的Context的值就可以推断出返回值。不需要显示传递类型\ntype Theme = &#x27;light&#x27; | &#x27;dark&#x27;;// 我们在createContext就传了类型了const ThemeContext = createContext&lt;Theme&gt;(&#x27;dark&#x27;);const App = () =&gt; (  &lt;ThemeContext.Provider value=&quot;dark&quot;&gt;    &lt;MyComponent /&gt;  &lt;/ThemeContext.Provider&gt;)const MyComponent = () =&gt; &#123;    // useContext根据ThemeContext推断出类型，这里不需要显示传  const theme = useContext(ThemeContext);  return &lt;div&gt;The theme is &#123;theme&#125;&lt;/div&gt;;\n\nuseEffect useLayoutEffect没有返回值，无需传递类型\nuseCallback useMemouseMemo无需传递类型，根据函数的返回值就能推断出类型\nuseCallback无需传递类型，根据函数的返回值就能推断出类型。但是注意函数的入参需要定义类型，不然就是推断为any了！\nconst value = 10;// 推断出result是number类型const result = useMemo(() =&gt; value * 2, [value]);const multiplier = 2;// 推断出 (value: number) =&gt; number// 注意函数入参value需要定义类型const multiply = useCallback((value: number) =&gt; value * multiplier, [multiplier]);\n\nuseRefuseRef传非空初始值的时候可以推断类型，同样也可以通过传入第一个泛型参数来定义类型，约束ref.current的类型。\nconst MyInput = () =&gt; &#123;  // 这里约束inputRef是一个html元素  const inputRef = useRef&lt;HTMLInputElement&gt;(null);  return &lt;input ref=&#123;inputRef&#125; /&gt;&#125;\n\n// 自动推断出 myNumberRef.current 是number类型const myNumberRef = useRef(0);myNumberRef.current += 1;\n\nuseReducer只需要对传入useReducer的reducer函数的入参state和action进行类型约束就能够推断出来\ninterface State &#123;  value: number;&#125;type Action =  | &#123; type: &#x27;increment&#x27; &#125;  | &#123; type: &#x27;decrement&#x27; &#125;  | &#123; type: &#x27;incrementAmount&#x27;; amount: number &#125;;const counterReducer = (state: State, action: Action) =&gt; &#123;  switch (action.type) &#123;    case &#x27;increment&#x27;:      return &#123; value: state.value + 1 &#125;;    case &#x27;decrement&#x27;:      return &#123; value: state.value - 1 &#125;;    case &#x27;incrementAmount&#x27;:      return &#123; value: state.value + action.amount &#125;;    default:      throw new Error();  &#125;&#125;;// 这里可以推断出state为State类型const [state, dispatch] = useReducer(counterReducer, &#123; value: 0 &#125;);//能够约束传入dispatch的参数，符合Action类型dispatch(&#123; type: &#x27;increment&#x27; &#125;);dispatch(&#123; type: &#x27;decrement&#x27; &#125;);dispatch(&#123; type: &#x27;incrementAmount&#x27;, amount: 10 &#125;);// TypeScript compilation errordispatch(&#123; type: &#x27;invalidActionType&#x27; &#125;);\n\nuseImperativeHandleuseImperativeHandle一般比较少用，一般用来选择函数组件对外暴露ref属性被调用，需要配合forwardRef使用。\n如下例子。需要定义对外暴露的接口MyInputHandles，函数组件使用React.RefForwardingComponent对外暴露的接口调用作为泛型参数。然后就会得到约束了\n// MyInputHandles 需要给父组件的useRef作为类型使用 和 RefForwardingComponent作为泛型参数传入约束export interface MyInputHandles &#123;  focus(): void;&#125;// 使用RefForwardingComponent 类型进行定义组件，第一个泛型参数是对外暴露的handle，第二个是Propsconst MyInput: RefForwardingComponent&lt;MyInputHandles, MyInputProps&gt; = (  props,  ref) =&gt; &#123;  const inputRef = useRef&lt;HTMLInputElement&gt;(null);  useImperativeHandle(ref, () =&gt; (&#123;    // 这里的返回会自动使用MyInputHandles进行类型约束    focus: () =&gt; &#123;      if (inputRef.current) &#123;        inputRef.current.focus();      &#125;    &#125;,  &#125;));  return &lt;input &#123;...props&#125; ref=&#123;inputRef&#125; /&gt;;&#125;;// 函数组件必须使用forwardRef才能让外部组件使用该组件的refexport default forwardRef(MyInput);\n\n// 父组件const Autofocus = () =&gt; &#123;  // 能够约束 myInputRef.current的类型  const myInputRef = useRef&lt;MyInputHandles&gt;(null);  useEffect(() =&gt; &#123;    if (myInputRef.current) &#123;      myInputRef.current.focus();    &#125;  &#125;);  return &lt;MyInput ref=&#123;myInputRef&#125; /&gt;&#125;\n\n参考：\nReact Hooks in TypeScript\n","categories":["react"],"tags":["react"]},{"title":"4个避免使用npm link的理由","url":"/4%E4%B8%AA%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8npm%20link%E7%9A%84%E7%90%86%E7%94%B1.html","content":"\n\n\n\n本文主要介绍使用npm link的风险以及我们为什么使用npx link来替代它\n\n先抛结论使用npm install或者npx link去软连接一个本地包作为依赖而不是使用npm link\n$ npx link &lt;package-path&gt;\n\nnpm link是hiroki osame开发的一个更安全、更可预测的npm link的替代品\n因为如下原因我们应该避免使用npm link\n\n多个 Node.js 版本同时使用容易出错\n\nlink 失败不会报错并且会回退到直接从 npm 仓库进行安装\n\n会有预期之外的二进制可执行文件安装\n\n不符合预期的软链接删除\n\n\nnpm link是什么npm link是一个用于开发时直接将本地包链接为依赖项的一个命令行工具。通常用于发布 npm 包之前本地测试使用\n更多信息可查看官方文档\n使用假设存在以下模块包\n\nmy-library: npm 包，需要在其它项目中作为依赖进行测试\n\n需要注意的是这里my-library/package.json中的name属性也是应该my-library\n\nmy-application: package/my-application需要进行测试的项目\n\n下面演示如何将my-application中的my-library链接到本地\n\n全局安装\n\n在my-application中执行npm link将my-library安装到全局。这样才能让其它本地项目有办法链接到这个包。npm link的行为其实等同于npm install --global\n$ cd ./my-library$ npm link\n\n\n安装\n\n在my-application中执行npm link my-library去链接这个包\n$ cd ./my-application$ npm link my-library\n\nnpm link &lt;package-path&gt;也可以直接执行npm link &lt;package-path&gt;命令实现上述两步\n例子如下：\n$ cd ./my-application$ npm link ../my-library\n\n使用npm link &lt;package-path&gt;更加方便和不易出错，因为它是需要显式指定链接的包的路径\n4 个使用npm link的缺点\n多个 Node.js 版本同时使用容易出错\n\n如果开发环境中使用类似nvm的版本管理工具安装多个 Node.js 版本的话，需要确保npm link的执行是在同一个 node 版本\n像上文所说，第一步执行npm link其实是将包安装全局。但是因为多个版本的 Node.js 的全局安装路径是互相独立的。如果在不同版本中使用，包查找会失败\n可以使用以下命令查看全局包的安装路径。如果 Node.js 的版本出现在打印的路径中，则全局包安装路径在不同 Node.js 版本下是独立的\n$ npm root -g~/.nvm/versions/node/v14.16.1/lib/node_modules\n\n在不同的终端中处理多个包的时候很容易忽略不同终端下的 Node.js 版本是否一致。并且这个版本差异也很难发现，因为npm link在无法找到要链接的本地包时也不会报错\n\nlink 失败不会报错并且会回退到直接从 npm 仓库进行安装\n\n如果尝试在一个包中执行npm link a ，就算这个包之前并没有注册为全局链接，这个命令执行也不会报错\n$ npm link a~/my-package/node_modules/a -&gt; ~/.nvm/versions/node/v14.16.1/lib/node_modules/a\n\n这是因为npm link的时候没有找到全局的包a，它就会从npm仓库上去全局安装这个包并创建一个软链接到这个包\n只有这个包在 npm 远端仓库上没有这个包，npm link这个包才会失败\n$ npm link non-existent-packagenpm ERR! code E404npm ERR! 404 Not Found - GET https://registry.npmjs.org/non-existent-package - Not foundnpm ERR! 404npm ERR! 404  &#x27;non-existent-package@*&#x27; is not in this registry.npm ERR! 404 You should bug the author to publish it (or use the name yourself!)npm ERR! 404npm ERR! 404 Note that you can also install from anpm ERR! 404 tarball, folder, http url, or git url.\n\n要判断链接是否真正成功，可以检查输出是否有打印两个-&gt;，注意上面的错误链接只有一个-&gt;。两个-&gt;说明创建了一个指向全局包软链接，然后链接向本地包\n# npm v6$ npm link my-linked-package~/my-package/node_modules/my-linked-package -&gt; ~/.nvm/versions/node/v14.16.1/lib/node_modules/my-linked-package -&gt; ~/my-linked-package\n\n这种检查方法只能在 npm v6 版本中使用。从 npm v7 开始，链接路径不再被输出到终端了。从下面可以发现 v7 开始已经不可能确定是链接本地包成功还是、安装和链接了一个包\n# npm v7$ npm link aup to date, audited 3 packages in 671msfound 0 vulnerabilities\n\n也可以使用realpath命令验证一个包是否链接成功\n$ realpath node_modules/package-name~/my-linked-package\n\n综上，由于缺少适当的报错，使用npm link带给我们不是很好的体验。特别是在多个 Node.js 版本的情况下\n\n会有预期之外的二进制可执行文件安装\n\nnpm link的第一步是将包安装到全局。这个命令是由两步实现\nnpm install –global …可用于使二进制文件作为系统范围的 cli 命令使用。如果包有bin 字段，通过npm link可以另这个bin中的命令可以直接通过终端执行命令\n考虑到npm link通常只是用来在开发中进行包的测试，全局二进制文件的安装可能会有额外的副作用。由于包可以声明具有任意名称的二进制执行文件，这种意外的副作用的影响可能非常严重\n下面的例子，在package.json中指定了bin的random-command\n&#123;    &quot;name&quot;: &quot;my-package&quot;,    &quot;bin&quot;: &#123;        &quot;random-command&quot;: &quot;bin.js&quot;    &#125;&#125;\n\n执行npm link就也会全局安装可执行的random-command\n$ random-commandzsh: command not found: random-command$ cd my-package &amp;&amp; npm linkadded 1 package, and audited 3 packages in 548msfound 0 vulnerabilities$ random-commandSuddenly works!\n\n全局安装也会覆盖已经存在的的全局可执行命令（取决于PATH配置–终端查找命令的环境变量）。如果使用nvm则可能会受到影响\n下面的例子，覆盖了标准的 Unix 命令cat\n$ type catcat is /bin/cat$ cd my-package &amp;&amp; npm linkadded 1 package, and audited 3 packages in 230msfound 0 vulnerabilities$ hash cash$ type catcat is ~/.nvm/versions/node/v16.14.0/bin/cat\n\n在包安装方面，这些风险对于包管理很普遍，从安全角度来看，这些风险并不算太高\n但npm link本身不是一个包安装工具。它是一个开发时进行软链接的工具。通过上文，我们了解到这种行为是会导致不少预期外的行为以及可能导致的一些错误\n顺便提下上面提到的运行npm link a，则二进制执行命令a已安装到系统中。可能会认为 npm unlink a可以卸载，但它只会删除本地的软链接，而不会删除全局安装的二进制文件\n卸载全局包和它的二进制执行文件需要使用：\n$ npm uninstall --global a\n\n\n不符合预期的软链接删除\n\n链接多个包时，将删除先前链接的包。这个行为是 npm v7 中引入的\n以下例子pkg-a已经被链接过并且存在于node_modules中了。但当链接了第二个包pkg-b后，pkg-a就不在node_modules中了\n$ npm link ../pkg-aadded 1 package, and audited 5 packages in 684msfound 0 vulnerabilities$ ls node_modulespkg-a$ npm link ../pkg-badded 1 package, removed 1 package, and audited 5 packages in 703msfound 0 vulnerabilities$ ls node_modulespkg-b\n\n使用多个包进行链接时，npn link删除之前的链接包通常是不符合预期的。一般在链接第二个包之后，我们会继续运行代码并认为之前的软链接是应该不变的\n如果要链接多个包就必须将所有包路径一次传递给npm link\n$ npm link ../pkg-a ../pkg-badded 1 package, and audited 6 packages in 645msfound 0 vulnerabilities$ ls node_modulespkg-a pkg-b\n\n虽然可行但这并不是一个很好的开发体验。在开发中，我们并不总是提前知道所有需要链接的包或以前链接过的包\n这种令人困惑的行为说明了npm link的可用性很差\n潜在风险作为一个流行的包管理工具，npm 有一个各种各样的包但却没有统一的质量标准\n这里列举了一些恶意包，但这里提到的风险不仅限于攻击。当不清楚是否安装了正确的软件包时是有可能发生意外的\nnpm 上的许多包是用来更改文件的，例如rimraf或代码 linter 工具。运行文件中被更改的代码可能是有可能有问题的\nnpm install也有可能安装错误的包，但是了解到上面提到的npm link会有一些预料之外的行为时，npm link带来的风险会更高。如下：\n\n包名称可能会发生冲突。可能使用了一个 npm 仓库上已有的包名字去链接本地的包。在意识到名称已被占用之前，开发和测试新的或私有包可能会遇到\n\n本地链接失败不会报错。如果被链接的包无法在本地找到，将从 npm 仓库下中查找。如果找到相同名称的包，则可能会意外地安装到全局\n\n二进制可执行文件被安装。如果安装了错误的包，很难发现二进制执行文件也会被全局安装并且很难意识到需要全局卸载这个二进制执行文件。这就会留下这个不符合预期的可执行文件被可能被意外执行\n\n\n使用npm install作为替代npm link的一种替代方法是使用指定包路径的npm install\n$ npm install --no-save &lt;package-path-a&gt; &lt;package-path-b&gt; ...\n\n执行这个命令会创建一个指向包的软链接而不是全局安装。这种行为就和我们使用npm link进行测试包的初衷差不多了。 加上--no-save是为了防止包的路径保存在package.json中\n但是npm install也是有缺点的。和npm link一样，执行npm install多次是会先移除之前的软链接。如果我们想一次链接多个包的话，必须一次将需要链接的多个包作为参数传入\n$ npm install --no-save &lt;package-path-a&gt; &lt;package-path-b&gt; ...\n\nnpx linknpx link，一个小工具用来替代npm link，并且能解决上面提到的npm link的缺点\n使用起来也很简单\n$ npx link &lt;package-path&gt;\n\n[npm link](https://github.com/privatenumber/link &quot;npm link&quot;)不会全局安装链接的包或二进制执行文件，并且也不会删除以前的软链接，可以在不同版本的 Node.js 中使用。当不能解析包路径时，也会有一个执行失败报错\n如果需要执行链接包的二进制文件，执行通过npx命令或者通过package scripts\n\n","categories":["node"],"tags":["node"]},{"title":"77.9K Star 的 Axios 项目如何优雅实现请求重试","url":"/77.9K%20Star%20%E7%9A%84%20Axios%20%E9%A1%B9%E7%9B%AE%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E5%AE%9E%E7%8E%B0%E8%AF%B7%E6%B1%82%E9%87%8D%E8%AF%95.html","content":"\n\n\n\naxios是什么，无需多讲，axios解析的可以看下77.9K Star 的 Axios 项目有哪些值得借鉴的地方这篇文章\n\n为什么需要请求重试项目中，经常会有很多用户的网络抽风或者各种原因造成偶发性的网络异常请求错误，如果没有重试机制，有时候体验就比较糟糕。这个时候实现网络错误请求错误重试也能比较好的解决这种偶发场景。\n如何去做呢我们可以使用axios-retry这个库去实现重拾。用法也非常简单\nimport axiosRetry from &#x27;axios-retry&#x27;;axiosRetry(axios, &#123;&#125;);\n\n直接执行axiosRetry传递axios实例即可。同时它会支持几个配置参数\n\nretries： 重试次数，默认是3次\nretryCondition：一个函数判断发生错误时是否重试。默认是5xxhttp 错误或者网络异常或者是幂等请求（GET/HEAD/ OPTIONS/PUT/DELETE）才会重试。\nshouldResetTimeout：重试的时候是否重置超时时间。默认不重置。也就是说多次重试请求必须在timeout内结束\nretryDelay每个请求之间的重试延迟时间，默认为0\n\n例如，如果我想定制，重试4次、除了默认情况重试外，404也重试、重置超时时间、重试延迟时间50ms，则这样即可\nimport axiosRetry from &#x27;axios-retry&#x27;;axiosRetry(axios, &#123;    retries: 4,    retryCondition: (err) =&gt; axiosRetry.isNetworkOrIdempotentRequestError(err) || error.response.status === 404,    shouldResetTimeout: true,    retryDelay: 50&#125;);\n\n实现原理axios-retry实现重试的原理也比较简单\n\naxios-retry会在axios的config的axios-retry字段中保存当前已经重试的次数(retryCount)\naxios会在http异常/网络异常的情况下抛出错误。axios-retry则在响应拦截器中注册错误处理函数，执行retryCondition判断是否需要进行重试。如果需要重试则对retryCount进行++操作，然后返回一个Prommise使用当前的config重新发起一次新的请求new Promise(resolve =&gt; setTimeout(() =&gt; resolve(axios(config)), delay));。如果当前不需要重试(retryCondition返回false或者已经超过重试次数的场景，直接reject这个错误对象)axios.interceptors.response.use(null, error =&gt; &#123;  const config = error.config;  // ....  const currentState = getCurrentState(config);  const shouldRetry = retryCondition(error) &amp;&amp; currentState.retryCount &lt; retries;  if (shouldRetry) &#123;    currentState.retryCount += 1;      //.....    return new Promise(resolve =&gt; setTimeout(() =&gt; resolve(axios(config)), delay));  &#125;  return Promise.reject(error);&#125;);\n\n详细代码在此。还是非常清晰易懂的\n更进一步在实际场景中，很多时候http请求成功并不说明我们的请求就符合预期的。有以下子几种场景，如果直接使用axios-retry是无法触发重拾的\n\n业务code异常以笔者实际项目为例，后端返回异常时，http code为200，但是返回code非0的错误，如&#123;code:1,msg:&#39;some err&#39;&#125;。有的时候可能是一些偶发错误，这个时候可能也需要重试\n\n异步接口返回不符合预期假设以下场景。首先操作a先上传了视频；紧接这b操作去查询这个视频的信息，可能刚上传完，后端一些信息落db的时候有延迟。偶发的我们马上查询的时候可能查不到这个信息，需要延迟个几ms才能查到。例如查不到返回&#123;code:0,data:null&#125; 查到返回code:0,data:&#39;some thing&#39;。这个时候重试也是很重要了。\n\n\n如何优雅重试上文提到axios-retry的重试原理是通过响应拦截器的错误处理函数去实现的，那么我们在响应拦截器的正常处理函数中抛出这个这个错误是否可以呢？当然是可以的。\n\n给axios的config加一个自定义选项函数判断是否需要重试\n在响应拦截器中调用判断函数，若需要重试，设置一个标志位，Promise.reject抛出一个错误instance.interceptors.response.use((response) =&gt; &#123;  const &#123; data, config, request &#125; = response  if (config?.[namespace]?.shouldRetry?.(data)) &#123;    config[namespace].needRetry = true    return Promise.reject(      createError(        `Axios retry enhance error`,        config,        null,        request,        response      )    )  &#125;  return response&#125;)\naxios-retry的retryCondition读取到上一步的属性返回true，即可利用axios-retry进行重试axiosRetry(instance, &#123;  ...config,  retryCondition: (error) =&gt; &#123;    const &#123;      retryCondition = axiosRetry.isNetworkOrIdempotentRequestError,    &#125; = config    return retryCondition(error) || error.config?.[namespace]?.needRetry  &#125;,&#125;)\n\n于是，代码调用的时候只需如下即可\nclient.get&lt;Result&gt;(&#x27;http://example.com/test&#x27;, &#123;  retry: &#123;    // The request will retry when the code isn&#x27;t 0 even the http code is 200    shouldRetry: (res: Result) =&gt; res.code !== 0,  &#125;,&#125;)\n封装综合以上讨论，针对axios-retry进行了二次封装，实现了axios-retry-enhancer。支持axios-retry原来的参数，并且额外支持上面提到的定义重试逻辑。用法如下即可实现业务优雅重试\nimport axiosRetryEnhancer from &#x27;axios-retry-enhancer&#x27;import axios from &#x27;axios&#x27;const client = axios.create()axiosRetryEnhancer(client, &#123;  // same options with axios-retry. See https://github.com/softonic/axios-retry#options&#125;)interface Result&lt;T = unknown&gt; &#123;  code: number  data: T&#125;client.get&lt;Result&gt;(&#x27;http://example.com/test&#x27;, &#123;  retry: &#123;    // The request will retry when the code isn&#x27;t 0 even the http code is 200    shouldRetry: (res: Result) =&gt; res.code !== 0,  &#125;,&#125;)\n\n码字不易，你的点赞是我最大的动力，嘿嘿\n","categories":["工程化"],"tags":["工程化"]},{"title":"AbortController的使用","url":"/AbortController%E7%9A%84%E4%BD%BF%E7%94%A8.html","content":"\n\n今天介绍一个有用的 JavaScript api AbortController\nAbortController是什么\nAbortController 接口表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。你可以使用 AbortController.AbortController() 构造函数创建一个新的 AbortController。使用 AbortSignal 对象可以完成与 DOM 请求的通信\n\n这个 api 简单来说就是可以提供一个能力给我们去提前终止一个 fetch 请求\n一个终止 fetch 请求的 demo 如下：\nfetchButton.onclick = async () =&gt; &#123;  const controller = new AbortController();  // 点击abort button实现终止fetch请求  abortButton.onclick = () =&gt; controller.abort();  try &#123;    const r = await fetch(&#x27;/json&#x27;, &#123; signal: controller.signal &#125;);    const json = await r.json();  &#125; catch (e) &#123;  // 如果fetch请求被终止会抛出一个AbortError的错误    const isUserAbort = (e.name === &#x27;AbortError&#x27;);  &#125;&#125;;\n\n\n提前终止后这个请求在 network 面板中的 status 显示为 canceled\n在没有AbortController这个 api 之前，我们是没法去让浏览器提前去终止一个请求的。而有了这个 api 之后，浏览器就能提前终止请求进而节约一些用户带宽。除此之外，这个 api 也能给我们带来一些新的开发模式\nController 和 Signal下面实例化了一个AbortController，它的signal属性就是一个AbortSignal\nconst controller = new AbortController();const &#123; signal &#125; = controller;\n\n\ncontroller 可通过controller.abort()去终止它对应的signal\nsignal本身是不能被直接终止的。可以将它传递给一些函数调用如 fetch 或者直接监听signal的状态变化（可以通过signal.aborted查看signal的状态或者监听它的abort事件）\n\n实际使用普通对象中的终止一些旧的 DOM api 是不支持AbortSignal。例如WebScocket只提供了一个close方法当我们无需使用时进行关闭。如果要使用AbortSignal则可以类似以下的封装\nfunction abortableSocket(url, signal) &#123;  const w = new WebSocket(url);  if (signal.aborted) &#123;    w.close();  // signal已经终中止的情况下马上关闭websocket  &#125;  signal.addEventListener(&#x27;abort&#x27;, () =&gt; w.close());  return w;&#125;\n\n这个使用也很简单，但是需要注意的是如果signal已经终止的情况下是不会触发abort事件，需要我们先进行一个判断是否signal已经终止\n移除事件监听我们经常需要在 js 中处理 dom 的监听和卸载工作。但是下面的例子由于事件监听和卸载传入的函数不是同一个引用时不会生效的\nwindow.addEventListener(&#x27;resize&#x27;, () =&gt; doSomething());// 不会生效window.removeEventListener(&#x27;resize&#x27;, () =&gt; doSomething());\n\n因此我们经常需要一些额外的代码去维护这个回调函数的引用的一致性。而有了AbortSignal之后我们就可以有一种的新的方式去实现\nconst controller = new AbortController();const &#123; signal &#125; = controller;window.addEventListener(&#x27;resize&#x27;, () =&gt; doSomething(), &#123; signal &#125;);controller.abort();\n\n因为addEventListener也能接收signal属性的。我们最后只需要调用controller.abort()，这个controller的signal传递的相关事件监听都会被自动相应卸载了\n构造器模式在 JavaScript 中我们可能需要在对象中管理非常复杂的生命周期，如WebSocket。我们需要执行开启然后执行一系列逻辑后终止。可能我们会写以下代码\nconst someObject = new SomeObject();someObject.start();// 执行一些操作后someObject.stop();\n\n也可以通过AbortSignal进行实现\nconst controller = new AbortController();const &#123; signal &#125; = controller;const someObject = new someObject(signal);// 执行一些操作后controller.abort();\n\n\n这能非常清晰地表示这个对象只能被执行一次，只能从开始到结束，而不能反过来。如果它终止了后想再次使用则需要再次创建一个对象\n\n可以在很多地方共享一个signal。我们无需持有多个SomeObject的实例。只需要调用controller.abort()，这些SomeObject的实例都能被终止掉\n\n如果SomeObject内部也有调用像fetch之类的内部 api 只需要把这个signal继续传递，则fetch也能被一起终止掉\n\n\n如下是一个例子。展示了两种 signal 的用法。传递给内置 apifetch和检查signal状态执行一些操作\nexport class SomeObject &#123;  constructor(signal) &#123;    this.signal = signal;    // 执行一些操作例如发请求    const p = fetch(&#x27;/json&#x27;, &#123; signal &#125;);  &#125;  doComplexOperation() &#123;    if (this.signal.aborted) &#123;      throw new Error(`thing stopped`);    &#125;    for (let i = 0; i &lt; 1_000_000; ++i) &#123;      // 执行复杂操作    &#125;  &#125;&#125;\n\nreact hook 中的异步调用我们通常会在useEffect中进行一些异步 api 调用。借助signal可以在下一次useEffect重新调用 api 的时候将前一次的调用终止\nfunction FooComponent(&#123; something &#125;) &#123;  useEffect(() =&gt; &#123;    const controller = new AbortController();    const &#123; signal &#125; = controller;    const p = (async () =&gt; &#123;      const j = await fetch(url + something, &#123; signal &#125;);    &#125;)();    return () =&gt; controller.abort();  &#125;, [something]);  return &lt;&gt;...&lt;&gt;;&#125;\n\n也可以封装一个useEffectAsync的 hook\nfunction useEffectAsync(cb,dependence) &#123;   const controller = new AbortController();   const &#123; signal &#125; = controller;   useEffect(() =&gt; &#123;     cb(signal);     return () =&gt; controller.abort();   &#125;,dependence)&#125;\n\n一些有用的 AbortSignal 方法\n这些方法当前有可能还没有实现\n\n\nAbortSignal.timeout(ms): 创建一个给定时间后终止的AbortSignal\n\nfunction abortTimeout(ms) &#123;  const controller = new AbortController();  setTimeout(() =&gt; controller.abort(), ms);  return controller.signal;&#125;\n\n\nAbortSignal.any(signals)：创建一个AbortSignal，如果传入的任一signal终止了，这个返回的signal也会被终止\n\nfunction abortAny(signals) &#123;  const controller = new AbortController();  signals.forEach((signal) =&gt; &#123;    if (signal.aborted) &#123;      controller.abort();    &#125; else &#123;      signal.addEventListener(&#x27;abort&#x27;, () =&gt; controller.abort());    &#125;  &#125;);  return controller.signal;&#125;\n\n\nAbortSignal.throwIfAborted()：如果signal本身已经终止了，调用该方法会抛出执行abort(reason)时指定的 reason 异常；否则只会静默执行\n\nif (signal.aborted) &#123;  throw new Error(...);&#125;// becomessignal.throwIfAborted();\n\n这个方法目前不太容易 polyfill，但是可通过下面的工具函数实现\nfunction throwIfSignalAborted(signal) &#123;  if (signal.aborted) &#123;    throw new Error(...);  &#125;&#125;\n\n参考https://whistlr.info/2022/abortcontroller-is-your-friend/\n\n","categories":["原生"],"tags":["原生"]},{"title":"ES5 在 Web 上的现状","url":"/ES5%20%E5%9C%A8%20Web%20%E4%B8%8A%E7%9A%84%E7%8E%B0%E7%8A%B6.html","content":"\n\n\n\n最后一个支持 ES5 的浏览器 IE 11 在 2022 年被微软停止支持，那么今天 Web 上的 ES5 现状如何？在构建生产代码时，Web 开发者的最佳实践是什么？\n\n本文将通过数据来回答这些问题，并基于这些数据为网站开发者和库作者提供一些具体的建议，帮助他们在未来处理旧版浏览器的支持问题。\n简要声明在深入探讨 ES5 使用的实际数据之前，本文需要澄清一点，编写或发布 ES5 代码本身并没有什么错。\nJavaScript 引擎对 ES5 代码的优化时间比对现代代码的优化时间长得多，所以如果你有旧的 ES5 代码仍在工作，没有必要仅仅为了使其“现代化”而更新它。\n然而，如果你使用 ES6+语法编写代码，然后使用构建工具将其转译为 ES5，这通常会导致大量的 polyfill 和转译器膨胀，显著增加最终包的大小。\n为了说明这一点，下面是一个例子：\nconsole.log([1, 2, 3].at(-1));\n\n如果你手动将这段代码转译为 ES5，它可能看起来像这样：\nvar arr = [1, 2, 3];console.log(arr[arr.length - 1]);\n\n然而，如果你使用Babel转译这段代码，并配置它以添加 polyfills——即使你仅限于根据源代码中的使用情况添加所需的 polyfills——它会包含71 个 core-js 依赖项，并从 31 字节增加到11,217 字节的最小化代码！\n这个例子的重点不是要说 Babel 或 core-js 不好。这些工具需要支持所有可能的 ES6+代码，这要求它们考虑各种边缘情况（尽管这个特定的例子没有任何边缘情况）。\n相反，重点是强调选择支持旧版浏览器是有代价的，而且这个代价可能非常高。\n不幸的是，问题实际上比代码膨胀更糟糕。如果查看下面的数据，了解今天流行的网站实际上是如何转译和部署他们的代码到生产环境，你会发现大多数网站在互联网上发布的代码是转译为 ES5 的，但仍然无法在 IE 11 中工作——这意味着转译器和 polyfill 膨胀被 100%的用户下载，但没有一个用户受益。\n数据分析要了解 ES5 在 Web 上的现状，需要关注以下三个方面，因为它们都在我们作为 Web 用户接收到的最终代码输出中起着关键作用：\n\n流行的打包器和构建工具的默认配置\n流行 JavaScript 库中的代码状态\n网站所有者部署的代码状态\n\n默认打包器和构建工具配置大多数打包器和构建工具都具有极高的可配置性，几乎可以对最终输出的代码进行无限控制。然而，在实际操作中，大多数开发者只是使用默认配置，因此默认配置非常重要。\n那么这些默认配置是什么？具体来说，这些默认配置是否会将代码转译为 ES5？\n可以通过State of JS 调查（2023 年）看到最受欢迎的构建工具，按使用量大致排序如下：\n\n\n\n工具\n默认转译为 ES5？\n备注\n\n\n\nBrowserslist\n否\n本身不是构建工具，但被许多构建工具内部使用，是配置浏览器支持目标的最流行开源工具。defaults设置不再包括任何 ES5 浏览器。最后一个是 IE 11，它在 4.21 版本中被标记为已废弃。\n\n\nBabel\n是\nBabel 的文档推荐设置targets选项（使用 Browserslist），但如果未指定，它将转译所有代码为 ES5。\n\n\nwebpack\n否\n默认情况下，webpack 不会转译任何代码。大多数 webpack 用户包括babel-loader，而 webpack 的使用示例建议设置targets: &quot;defaults&quot;。\n\n\nTypeScript (tsc)\n是\nTypeScript 的默认target选项是 ES5。\n\n\nNext.js\n否\nNext.js使用 Babel 进行转译，默认设置一个 Browserslist 配置，目标是“现代浏览器”（即支持 ES 模块的浏览器）。\n\n\nesbuild\n否\nesbuild默认不进行转译。你可以设置自定义目标以启用转译，但 ES5 不支持作为转译目标。\n\n\nVite\n否\nVite 使用 esbuild，默认设置自定义目标为“现代浏览器”（即支持 ES 模块的浏览器）。如果需要支持旧版浏览器，Vite 允许用户安装一个插件。\n\n\nRollup\n否\nRollup 默认不进行转译。许多 Rollup 用户安装@rollup/plugin-babel，在这种情况下使用 Babel 的默认配置。\n\n\nParcel\n否\nParcel自动应用差异化服务，并具有可自定义的目标。\n\n\nClosure Compiler\n否\n默认设置为ECMASCRIPT_NEXT，即最新的一组稳定的 ES 特性。\n\n\n如上表所示，绝大多数打包器和构建工具默认不再转译为 ES5。值得注意的是，较新的工具根本不支持 ES5，这表明趋势正在向这个方向发展。\n尽管如此，Babel 仍然是最流行的 JavaScript 转译工具，因此在 Web 上转译为 ES5 仍然相当普遍（详见野外的 ES5 使用情况）。\n流行的 JavaScript 库除了查看流行的构建工具外，还查看了一些当今最流行的库（同样基于State of JS 调查，按受欢迎程度大致排序）：\n为了测试这些库中的每一个，我创建了一个仅导入该特定库的打包入口点，使用库文档中的一个代码示例。然后，我使用 Rollup 和 Webpack 打包代码，测试输出并查看是否包含任何 ES6+语法（特别是任何IE 11 不支持的 ES6+语法）。\n结果：\n\n\n\n库\n包含 ES6+语法？\n备注\n\n\n\nLodash\n否\n仅 ES5\n\n\nReact\n否\n仅 ES5\n\n\ndate-fns\n是\n箭头函数\n\n\nthree.js\n是\nasync/await，箭头函数，展开运算符，解构赋值\n\n\nd3\n是\n箭头函数，展开运算符，解构赋值\n\n\nFramer-motion\n是\n箭头函数，展开运算符，解构赋值\n\n\ngreensock\n否\n仅 ES5\n\n\ndayjs\n否\n仅 ES5\n\n\nZod\n是\nasync/await，箭头函数，展开运算符，解构赋值\n\n\nRxJS\n是\n箭头函数\n\n\nimmer\n是\n箭头函数，展开运算符，解构赋值\n\n\nluxon\n是\nasync/await，箭头函数，展开运算符，解构赋值\n\n\nreact-query\n否\n仅 ES5（打包了 Babel 助手）\n\n\n如上所示，许多流行的 JavaScript 库现在发布的是 ES6+语法。\n这很值得注意，因为正如我之前提到的，大多数使用 Babel 转译源文件的开发者在打包时，明确配置他们的打包器不转译node_modules目录中的任何内容——这是库作者历史上觉得需要继续转译为 ES5 的主要原因。\n截至 2024 年 9 月：\n\nWebpack 的babel-loader文档推荐的配置排除了node_modules。\nRollup 的plugin-babel文档建议排除node_modules，并且建议库作者不要发布 ES6 代码。\n\n而 TypeScript（tsc），作为仅次于 Babel 的第二大转译工具，只会转译项目自己的代码文件。它不会转译node_modules中的项目依赖项。\n这就为任何希望支持 ES5 并使用 Babel 或tsc转译代码的网站带来了问题。除非他们对构建管道的各个部分如何相互作用有深刻的理解，并且知道如何正确配置每一个部分，否则他们可能会在不知不觉中将 ES6+代码与 ES5 代码一起打包。\n那么，这是否真的对实际网站造成了问题，还是大多数网站正确配置了他们的工具？下一节将通过HTTP Archive的数据来回答这个问题。\n注意： 上表中的一些库发布了 ES5 和 ES6+版本，通常 ES5 版本设置在package.main字段，而 ES6+版本设置在package.module或package.exports字段。在这些情况下，我只查看了使用默认配置时打包器拉取的脚本版本（因为这是大多数人使用的），而今天的打包器默认使用package.module或package.exports而不是package.main（参见：[1]，[2]，[3]）。\n野外的 ES5 使用情况开发者用来将 ES6+代码转译为 ES5 的三大主要工具是：\n\nBabel\nTypeScript（tsc）\nClosure Compiler（即 Google 内部的 JSCompiler）\n\n这三种工具都包括某种形式的 polyfills 和所谓的 ES5“助手”函数，以避免在最终输出中重复。最常用的 ES5 助手函数库是：babel-helpers，core-js，regenerator-runtime，tslib，和$jscomp。\n这些助手库中的许多函数都足够独特，可以通过查询 HTTP Archive 来检测（即使在最小化代码中）哪些网站在使用它们。搜索这些助手函数的存在——而不是标准的 ES5 语法（如var或非箭头function）——有助于区分手写的旧 ES5 代码（通常相当优化）和由转译器生成的新 ES5 代码（通常相当臃肿）。\n我在 HTTP Archive 上进行了搜索，看看流行网站（基于CrUX 受欢迎度排名的前 10,000 个网站）在他们部署到生产环境的脚本包中包含这些助手的情况有多普遍。我还想看看网站提供未转译的 ES6+语法的情况有多普遍。\n以下是我发现的结果（完整结果）：\n\n89% 的网站提供至少一个包含未转译 ES6+语法的 JavaScript 文件。\n79% 的网站提供至少一个包含 ES5 助手代码的 JavaScript 文件。\n68% 的网站提供至少一个同时包含 ES5 助手代码和未转译 ES6+语法的 JavaScript 文件。\n\n重申一下本文的观点——如果浏览器不支持 ES6+语法（如 IE 11），那么它在尝试加载包含 ES6+语法的脚本文件时会出错。而如果浏览器确实支持 ES6+语法，那么它不需要任何 ES5 助手代码或任何旧版 polyfills。绝对没有理由同时包含两者。\n为了确认这个查询结果的准确性，手动测试了列表中的 20 个随机网站，确认它们确实在某些脚本包中同时包含 ES5 助手代码和 ES6+语法。还手动在 IE 11 中访问了这些网站，确认这些脚本包确实无法加载。\n请记住，这些不仅仅是互联网上的随机网站。这些是全球最受欢迎的 10,000 个网站\n这意味着什么？对于一个网站来说，提供包含 ES5 助手和未转译 ES6+语法的代码，实际上只有两种可能的解释：\n\n该网站不需要支持 ES5 浏览器，但他们的一些依赖项转译为 ES5，因此 ES5 代码出现在他们的输出中。\n该网站打算支持 ES5 浏览器，但他们没有意识到一些依赖项发布了未转译的 ES6+语法，并且他们没有配置打包器来转译node_modules中的代码。\n\n无论是哪种解释，全球许多最受欢迎的网站都在提供大量不必要的代码，这强烈表明我们当前工具推荐的默认配置并不起作用。\n如果从这些数据中能找到一丝安慰，那就是显而易见的是，放弃对 IE 的支持不会对大多数企业产生明显影响。如果所有这些大公司显然没有受到这些 IE 体验破坏的影响，那么你的公司也可能不会。\n建议对于库作者库作者应将代码转译为 ES5 的最初理由是大多数网站需要转译为 ES5。然而，鉴于目前前 10,000 个网站中有 89%发布了一些未转译的 ES6+语法，这一理由已不再有效。\n根据本文提供的数据，JavaScript 库作者不再需要将代码转译为 ES5。\n实际上，库作者对导入它们的网站的浏览器支持需求没有信息，因此不应该为其所有用户做出这个决定。同时，库作者也不应该假设所有用户都能够通过复杂的构建过程运行它们的库，因此发布的代码应使用完全标准的 JavaScript，并在当前广泛使用的浏览器中工作。\n那么库作者应该选择什么目标？在我看来，库作者的最佳解决方案是使用Baseline——具体来说，只包括Baseline Widely Available特性在任何发布的代码中。\n如果你不熟悉 Baseline，这是 W3C 内的WebDX 社区组的一项努力，旨在帮助开发者轻松识别所有主要浏览器和浏览器渲染引擎在桌面和移动设备上稳定且广泛支持的特性。如果某个特性在所有四个主要浏览器的稳定版本中至少存在 30 个月，则被认为是Baseline Widely Available。\n针对Baseline Widely Available的主要好处是它是一个动态目标，这意味着它不会像针对 ES5 那样被困在过去（这也是 Next.js、Vite 和 Parcel 使用的esmodule目标目前正在发生的情况）。\n库作者可以通过以下Browserslist查询配置他们的构建系统，以现在针对Baseline Widely Available特性（适用于任何支持 Browserslist 的工具）：\ntargets: [  &quot;chrome &gt;0 and last 2.5 years&quot;,  &quot;edge &gt;0 and last 2.5 years&quot;,  &quot;safari &gt;0 and last 2.5 years&quot;,  &quot;firefox &gt;0 and last 2.5 years&quot;,  &quot;and_chr &gt;0 and last 2.5 years&quot;,  &quot;and_ff &gt;0 and last 2.5 years&quot;,  &quot;ios &gt;0 and last 2.5 years&quot;,];\n\n注意： 有一个开放的功能请求，希望将 Baseline 支持添加到 Browserslist，这将使上述查询简化为“baseline widely available”。\n如果某个网站需要支持比Baseline Widely Available覆盖的更多浏览器，这完全没问题。该网站可以始终配置其构建系统以进一步转译任何导入的库。关键是这个决定最好由网站开发者做出，而不是库作者。\n对于网站开发者许多网站开发在同一个脚本包中同时提供未转译的 ES6+语法和 ES5 助手代码，这清楚地表明排除node_modules目录不进行转译的做法并不是一个好做法。\n然而，如今构建工具已经变得显著更快。此外，网站可以配置他们的构建，只在生产环境中处理node_modules中的代码。在开发中，代码应该在开发者使用的任何浏览器上运行良好，特别是如果库作者遵循我上面给出的建议并针对Baseline Widely Available。\n主要观点\nES5 不再是构建工具或 JavaScript 库应该默认针对的目标。 如果工具仍然希望提供 ES5 支持，这应该是有特定支持需求的单个网站可以选择的。\n构建工具和库不应该使用固定的浏览器支持策略。 这些策略很快就会过时，这导致了本文数据中突出的问题。浏览器支持决策应该由网站本身做出，而不是它使用的工具。一个好的浏览器支持策略是Baseline Widely Available。\n导入第三方库的网站开发者应该将这些库作为其构建的一部分进行处理。 不能假设所有库作者都有与你相同的浏览器支持需求。正如本文数据所示，在许多情况下，网站开发者可能比他们导入的库有更广泛的浏览器支持需求（因此需要进一步转译它们）。\n跨浏览器支持不应该完全依赖于你的构建工具来处理。 如果需要支持特定的一组浏览器，那么你需要测试你的网站以确保它在这些浏览器中正常工作。\n\n参考The State of ES5 on the Web\n","categories":["原生"],"tags":["原生"]},{"title":"Go之数组/切片","url":"/Go%E4%B9%8B%E6%95%B0%E7%BB%84!%E5%88%87%E7%89%87.html","content":"\n\n\nGo之数组/切片初始化Go中初始化一个数组如下// 指定长度x:= [4]int&#123;1,2,3,4&#125;// orvar y = [4]int// 不指定长度，由元素个数决定长度x:= [...]int&#123;1,2,3,4&#125;\n\n在Go中，数组的长度是固定的，创建后不可修改。所以一般情况下用切片比较方便。切片的长度是可变的，比较好用。\n初始化一个切片由几种方法。// 1 、直接通过元素初始化x:= []int&#123;1,2,3,4&#125;//2、 通过数组生成切片arr:= [...]int&#123;1,2,3,4&#125;// 表示以arr的下标0-3 生成一个新的切片x:= arr[0:4] // 等价于 arr[:4] arr[:] // 3 通过make初始化x:= make([]int,4,4) // 初始化一个长度为4 ；容量为4的切片\n需要注意的是，切片底层是指向一个数组的。参考以下代码\nfunc main() &#123;\tx := [...]int&#123;1, 2, 3, 4&#125;\ty := x[:]\ty[2] = 1\tfmt.Println(x, y)// [1 2 1 4] [1 2 1 4]&#125;\n我们可以看到修改切片的值，数组和切片都同样被改变。但是有一种情况是不同的，就是如果我们对切片进行元素追加，此时切片就指向另一个新的底层匿名数组，此时和原数组就没有关系了\n如下：\nfunc main() &#123;\tx := [...]int&#123;1, 2, 3, 4&#125;\ty := x[:]\ty = append(y, 5)\ty[2] = 222\tfmt.Println(x, y) // [1 2 3 4] [1 222 3 4 5]&#125;\n\n简单总结就是：切片是指向一个底层数组，如果这个底层数组容量不足时，切片会自动扩容，指向另一个新的底层数组，和原来的数组就没有关系\n数组和切片作为参数传递给函数\n值传递\nfunc Test(arr [4]int) &#123;\tarr[1] = 888&#125;x := [...]int&#123;1, 2, 3, 4&#125;Test(x) // x: [1,2,3,4] 值传递不会影响到x的值\n传递地址\nfunc Test(arr *[4]int) &#123;\tarr[1] = 888&#125;x := [...]int&#123;1, 2, 3, 4&#125;Test(&amp;x) // [1,888,3,4] 传递地址，函数内修改会影响外部\n\n切片有点特殊。切片本质上是一个包含3个属性的结构体。3个属性分别是，切片的长度、切片的容量、一个指针指向底层数组\n// y是切片unsafe.Sizeof(y)// 24// 类似type Slice struct &#123;\tlen int //切片长度\tcap int // 切片容量\tpoint *[](int) // 底层数组的指针&#125;\n\n\n值传递\n\n需要注意的是，我们通过传递切片也是值传递的（切片本身被拷贝），函数内的修改切片是修改切片的数组指针属性指向的底层数组的，所以对应底层数组也会被修改。所以有一种错觉，怎么切片值传递，切片值出来被修改了呢。\nfunc Test(arr []int) &#123;\tarr[1] = 888&#125;func main() &#123;\tx := [...]int&#123;1, 2, 3, 4&#125;\ty := x[:]\tTest(y)\tfmt.Println(x) // x [1,888,3,4] 看上去是修改了原切片，其实只是函数内部通过拷贝的底层数组的地址修改了对应底层数组的值&#125;\n\n但是，如果我们在函数内对切片进行追加，此时，我们再去修改，就是修改了另一个底层数组。这时候原切片和原数组，都不会被修改到了。\nfunc Test(arr []int) &#123;\tarr[1] = 888\tarr = append(arr, 222)&#125;func main() &#123;\tx := [...]int&#123;1, 2, 3, 4&#125;\ty := x[:]\tTest(y)\tfmt.Println(x, y)// 这里x y 都不会被修改&#125;\n\n所以，切片作为函数参数传递，也是符合Go语言的函数参数值传递的理念。\n\n地址传递\n\n切片也是可以地址传递的\nfunc Test(arr *([]int)) &#123;\t(*arr) = append(*arr, 222)&#125;func main() &#123;\tx := [...]int&#123;1, 2, 3, 4&#125;\ty := x[:]\tTest(&amp;y)\tfmt.Println(x, y)// [1 2 3 4] [1 2 3 4 222]&#125;\n\n有之前的分析，就很好理解了。切片传递的是指针，函数内对切片追加，修改就是修改了原切片的指向底层数组的指针指向，指向我们新生成的指针。所以main函数中，我们打印切片，发现打印值就是我们修改的值，而原数组也不会被更改了。\n","categories":["Go"],"tags":["Go"]},{"title":"Go项目接入travis CI总结","url":"/Go%E9%A1%B9%E7%9B%AE%E6%8E%A5%E5%85%A5travis%20CI%E6%80%BB%E7%BB%93.html","content":"\n\n\n\n上一篇文章提到了npm的接入 travis 实现自动发布 npm 包的方法，本文主要讲述 Go 项目的使用，主要分为执行单元测试和 build 打包发步到 github release。具体 travis 的基本操作参考上文即可，本文只讲述不同的部分\n\n单元测试本文不讲述 Go 的单元测试如何编写，这里直接以filenamify（一个合法化文件路径的库）为例子。已为filenamify.go编写测试文件filenamify_test.go。只需要在tracis中执行go test -v即可。\n# https://github.com/flytam/filenamify/blob/master/.travis.ymllanguage: gogo:    - 1.13.xenv:    - GO111MODULE=onscript: go test -v\n\n然后给在项目中加上构建状态图标。搞定这样，每次推送到远程，就会触发CI自动执行单元测试\n发布 github release有时候我们的 Go 项目是需要打包成可行文件直接发布到 github release 让别人下载执行的。这时候也可以使用travis实现，借助travis releases工具即可\n1、新建一个.travis.yml文件，填入基本的 Go 配置环境\nlanguage: gogo:    - 1.13.xenv:    - GO111MODULE=on # 启用Go modinstall:    - go get -v\n\n2、编写Makefile\n在nodejs项目中，我们一般会配置一个npm run test的命令执行测试，但是 Go 是没有npm和package.json这两个东西，这时候就需要编写Makefile来实现了（可以把Makefile看作功能类型于package.json的东西，只是使用make xxx来执行），Makefile编写可以参考。\n以blog-sync为例子，这里我是需要打包全平台的可行文件，于是Makefile如下\nGOCMD=goGOBUILD=$(GOCMD) buildBINARY_NAME=binNAME=blog-sync#macbuild:\tCGO_ENABLED=0 $(GOBUILD) -o $(BINARY_NAME)/$(NAME)-mac# linuxbuild-linux:\tCGO_ENABLED=0 GOOS=windows GOARCH=amd64 $(GOBUILD) -o $(BINARY_NAME)/$(NAME)-linux# windowsbuild-win:\tCGO_ENABLED=0 GOOS=linux GOARCH=amd64 $(GOBUILD) -o $(BINARY_NAME)/$(NAME)-win.exe# 全平台build-all:\tmake build\tmake build-win\tmake build-linux\n\n执行make build-all即可在bin目录下生成 3 个平台的可执行文件。\nlanguage: gogo:    - 1.13.xenv:    - GO111MODULE=on # 启用Go modinstall:    - go get -vbefore_deploy: make build-alldeploy:    provider: releases    api_key: 自动生成的github key    file_glob: true    file: bin/*    skip_cleanup: true    on:        repo: flytam/blog-sync        tags: true\n\n3、使用setup初始化配置\n# 已经安装travis clitravis setup releases# 按需填写，输入github账号密码，加密key，发布文件等\n\n再简单定制化后，最终如下配置，releases配置可参考文档\n# https://github.com/flytam/blog-sync/blob/master/.travis.ymllanguage: gogo:    - 1.13.xenv:    - GO111MODULE=on # 启用Go modinstall:    - go get -vbefore_deploy: make build-all # 发布前执行生成二进制文件的命令deploy:    provider: releases    api_key:        secure: xxxx    # 使用glob匹配发布bin目录下的文件    file_glob: true    file: bin/*    skip_cleanup: true    on:        repo: flytam/blog-sync        # tag才触发发布        tags: true\n\n4、发布\n每次打tag推送到仓库，就会触发自动发布可执行文件到github release\ngit tag 1.0.0git push --tags\n\n5、可以看到，我们的自动构建发布 release 成功了\n\n","categories":["Go"],"tags":["Go"]},{"title":"JavaScript不再需要写void 0了","url":"/JavaScript%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E5%86%99void%200%E4%BA%86.html","content":"\n\n我们经常会在一些代码中看到void 0的写法，这种写法其实现在已经不需要了\n\n本文翻译自：https://p42.ai/blog/2022-05-10/you-dont-need-void-0\n\nvoid操作符执行一个表达式并返回原始值undefined。void 0执行0，这什么都不会发生并且会返回undefined。是undefined的别名\n为什么void 0会用来当作undefined的别名？undefined本身不是一个保留关键字而是一个全局对象的一个属性\n在ES5（2009）之前，全局属性undefined的值是能被修改的，这会导致undefined一些不符合预期的行为\n下面的例子（这在现在JavaScript引擎中已经不是这样了）\n// 修改全局对象中的undefined属性undefined = &quot;something else&quot;; // 在其它js文件或者script中if (aVariable === undefined) &#123;  doSomething();&#125;\n\n修改全局的undefined可能发生在第三方代码中，例如通过脚本标签导入的库。由于void 0总是返回undefiend的实际原始值，因此在ES5之前通常使用它来在防止全局undefined被修改的情况下仍能确保undefined判断的准确性\nES5之后的全局属性undefinedundefined可以在全局对象上被修改的问题很大，以至于JavaScript标准在ES5中改变了。在ES5中，全局属性undefined变成了只读。尝试更改更改undefined的值在现代JavaScript中没有任何作用\nglobalThis.undefined = &quot;something else&quot;;console.log(undefined); // 在现代JS引擎中打印undefined\n\nundefined仍然可以被局部变量覆盖虽然不再能更改全局属性undefined，但undefined仍然不是JavaScript中的保留关键字。因此它仍然可以被局部变量覆盖\n&#123;  const undefined = &quot;something else&quot;;  let check = aVariable === void 0; // 这里的void 0仍需要&#125;\n我们应该避免使用undefined作为变量名。ESLint规则no-undefined 不允许使用 undefined 作为变量名并防止出现覆盖问题\nvoid 0是否有助于减少打包体积？表达式void 0比undefined短。JavaScript包的大小对于创建快速加载的网站是至关重要的并且减少一些字节会有所帮助\n但是最好将代码大小优化让Terser之类的工具在打包过程中进行处理。这些工具可以执行许多不同的优化，并且源代码在没有任何手动的代码大小优化(如使用void 0而不是undefined)的情况下也更易于阅读\n在现代JavaScript中避免使用void 0总之，在现代浏览器和JavaScript引擎中没有理由再使用void 0\n\n全局属性undefined不能在ES5以及后续的环境中更改\n本地变量命名undefined可以通过ESLint规则no-undefined进行禁止\n生产环境打包时minifier工具可以将undefined替代成void 0实现体积优化\n\n相反，void 0使JavaScript代码更难阅读，因为需要知道void 0的含义并处理相同概念(undefined)的不同术语(void 0,undefined)\n结论：使用undefined并移除不必要的void 0\n\n","categories":["原生"],"tags":["原生"]},{"title":"Koa源码学习","url":"/Koa%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html","content":"\n\n\n前言\nkoa是一个非常流行的Node.js http框架。本文我们来学习下它的使用和相关源码\n\n来自官网的介绍：Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序\n\n为什么使用koa使用koa而不直接使用Node.js的http模块\n\n高度可定制性：koa中实现了一套中间件机制以及在koa中万物皆中间件，我们通过中间件处理请求和响应并可以按需自由添加和修改中间件，并且koa的中间件生态非常丰富。而使用http需要自己编写全部的请求处理逻辑\n\n异步编程：koa基于async/await语法，可以让异步编程变得更加简单和优雅。而直接使用http模块，则需要使用回调函数或事件监听的方式进行异步编程，不够直观\n\n错误处理：koa内置的错误处理机制可以很好的捕获和处理错误，让代码更加健壮和可靠。而使用http模块，则需要自己编写错误处理逻辑，容易出现漏洞\n\n扩展性：koa内置的扩展机制可以让开发者在不改变核心代码的情况下，轻松地扩展和定制koa的功能。而使用http模块，则需要自己编写全部的扩展逻辑，不够便捷\n\n\n使用koa的使用非常简单，引入koa后只需要6行代码即可访问3000端口的http服务返回一个Hello koa\nconst Koa = require(&#x27;koa&#x27;);const app = new Koa();app.use(ctx =&gt; &#123;  ctx.body = &#x27;Hello Koa&#x27;;&#125;);app.listen(3000);\n\n中间件koa本身几乎没有封装任何进一步处理http请求的能力，而是实现了一套中间件的机制，所有的逻辑均由相关的中间件进行实现，中间件可以说是koa的灵魂\nkoa的中间件本质是一个函数，接收一个上下文对象（context）和一个next函数作为参数，然后对请求和响应进行处理，并将控制权传递给下一个中间件。中间件可以实现各种功能，例如路由、请求处理、错误处理等\nconst myMiddleware = async (ctx, next) =&gt; &#123;  // 处理请求  // ...  // 调用下一个中间件  await next();  // 处理响应  // ...&#125;\n\n例如我们实现一个错误处理中间件，在服务端发生任何错误时给客户端返回一个500的状态码，可以以下实现即可\nconst errorHandler = async (ctx, next) =&gt; &#123;  try &#123;    // 处理请求    // ...    // 调用下一个中间件    await next();    // 处理响应    // ...  &#125; catch (err) &#123;    // 处理错误    ctx.status = 500;    ctx.body = err.message;  &#125;&#125;app.use(errorHandler)\n以两个最常用的中间件为例\n\nkoa-router\n\nkoa默认也是没有封装对于特定的请求方法进行处理的功能，像很多http中处理路由相关的逻辑则需要引入koa-router 进行使用。koa router提供了基础的路由路径处理、嵌套路由等一些基础路由能力\n\nvar Koa = require(&#x27;koa&#x27;);var Router = require(&#x27;koa-router&#x27;);var app = new Koa();var router = new Router();router.get(&#x27;/&#x27;, (ctx, next) =&gt; &#123;  // ctx.router available&#125;);app  .use(router.routes())  .use(router.allowedMethods());\n\nkoa-router的源码就不展开了，原理基本上在中间件中读取req.url 、 req.method 和相关req上的一些属性进行分发到相应的路由注册的回调返回中进行处理\n\nkoa-body\n\n另一个常用的功能就是将请求的请求体数据解析成js对象，方便代码进行消费对于node原生的http服务，我们需要监听请求对象的data和end事件，在data 事件中接收二进制buffer数据，在end事件中将buffer转成字符串再序列化成js对象\nconst Koa = require(&#x27;koa&#x27;);const bodyParser = require(&#x27;koa-bodyparser&#x27;);const app = new Koa();app.use(bodyParser());app.use(async ctx =&gt; &#123;  // the parsed body will store in ctx.request.body  // if nothing was parsed, body will be an empty object &#123;&#125;  ctx.body = ctx.request.body;&#125;);\n\n这样对于这类请求我们通过ctx.request.body就能获取到json请求的数据，无需关心从请求流关心如何获取请求体。koa-body不止处理json类型，它还会对form、text、xml等类型做相应的处理\n\n源码实现koa的源码非常简洁，一共只有4个文件\n\napplicationapplication.js定义了Koa类，用于创建koa app对象，下面是koa类的构造函数\n// ...const Emitter = require(&#x27;events&#x27;)const compose = require(&#x27;koa-compose&#x27;);const http = require(&#x27;http&#x27;);const context = require(&#x27;./context&#x27;);const request = require(&#x27;./request&#x27;);const response = require(&#x27;./response&#x27;);// ...class Koa extends Emitter &#123;  constructor() &#123;    super();    this.middleware = [];    this.context = Object.create(context);    this.request = Object.create(request);    this.response = Object.create(response);    // constructor中其它的逻辑忽略  &#125;  // ...&#125;\n\nKoa类继承了Emitter类，用于实现事件的发布和订阅。还定义了一些属性，主要包括middleware、context、request和response。其中，middleware是中间件函数数组，用于存储所有的中间件函数；context是koa的请求上下文对象、request是请求对象实例、response是响应对象实例\nkoa实例上也暴露了几个对外使用的方法\n\napp.listen\n\n上面的使用demo，可以看到调用listen后就是监听指定端口运行起我们的http服务\n\n通过查看app.listen 的实现本质是调用了app.callback获取到回调函数处理逻辑，再传给http.createSerever。所以也等价于以下调用\nconst http = require(&#x27;http&#x27;);const Koa = require(&#x27;koa&#x27;);const app = new Koa();http.createServer(app.callback()).listen(3000);\n\n\napp.callback\n\n返回可以直接传递给 http.createServer() 方法的回调函数来处理请求\ncallback () &#123;  const fn = this.compose(this.middleware)  if (!this.listenerCount(&#x27;error&#x27;)) this.on(&#x27;error&#x27;, this.onerror)  const handleRequest = (req, res) =&gt; &#123;    const ctx = this.createContext(req, res)    return this.handleRequest(ctx, fn)  &#125;  return handleRequest&#125;  handleRequest (ctx, fnMiddleware) &#123;  const res = ctx.res  res.statusCode = 404  const onerror = err =&gt; ctx.onerror(err)  const handleResponse = () =&gt; respond(ctx)  onFinished(res, onerror)  return fnMiddleware(ctx).then(handleResponse).catch(onerror)&#125;\n\n主要有以下几个逻辑\n\n判断我们是否有监听错误事件进行处理（this.listenerCount是继承的EventEmiter上用于获取某个事件监听次数的方法），如果没有则使用koa自带的默认错误处理\n\n使用回调入参的request对象和response对象构造请求上下文对象并传递给this.handleRequest函数进行处理\n\n在handleRequest中，就是调用了被compose完成后的中间件函数，在处理完成后调用respond进行结束整个请求的流程\n\n在koa中我们无需像Node.js中http需要显式调用res.end或者res.pipe进行响应的结束发送，因为在handleResponse的respond函数中处理了。它会根据我们在业务逻辑设置的不同的body的类型进行相关调用，例如如果是一个流则调用pipe进行流式返回、特定状态码不返回body、非buffer和string的body序列化成字符串等\n\n\n\n\n洋葱模型\n\nkoa的洋葱模型是一种中间件处理机制其核心是将请求和响应对象传递给一系列中间件函数，每个中间件函数都可以对请求和响应进行处理，并将控制权传递给下一个中间件函数，最终将响应返回给客户端。中间件函数在请求处理过程中像是一个个套在一起的“洋葱”，请求从外层中间件函数开始处理，逐层深入，直到最内层中间件函数，然后逐层返回，最终响应从最外层中间件函数返回给客户端\n在洋葱模型中，每个中间件函数都是一个异步async函数。在处理请求时，每个中间件函数都接收一个context对象和一个next函数作为参数，context对象包含了请求和响应的信息，next函数可以调用下一个中间件函数\n处理顺序如下\n\n请求从外层中间件函数开始处理，先经过第一个中间件函数\n\n第一个中间件函数处理请求，然后调用next函数，将控制权传递给下一个中间件函数\n\n下一个中间件函数也处理请求，然后调用next函数，将控制权传递给下一个中间件函数，直到最内层中间件函数\n\n最内层中间件函数处理请求完成后逐层返回每个中间件函数在返回时可以对响应进行处理\n\n最后，响应从最外层中间件函数返回给客户端\n\n\n洋葱模型的优点是可以将请求和响应的处理逻辑分解成多个模块，每个模块只需关注自己的逻辑，提高了代码的可维护性。由于每个中间件函数都可以对请求和响应进行处理，因此可以实现一些复杂的功能例如身份验证、日志记录、错误处理等\n主要是koa-compose包的实现将中间件函数组合在一起，compoose实现代码如下\nfunction compose (middleware) &#123;  return function (context, next) &#123;    // last called middleware #    let index = -1    return dispatch(0)    function dispatch (i) &#123;      if (i &lt;= index) return Promise.reject(new Error(&#x27;next() called multiple times&#x27;))      index = i      let fn = middleware[i]      if (i === middleware.length) fn = next      if (!fn) return Promise.resolve()      try &#123;        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)))      &#125; catch (err) &#123;        return Promise.reject(err)      &#125;    &#125;  &#125;&#125;// 使用 const fn = this.compose(this.middleware)\ncompose函数接收一个中间件函数数组作为参数，返回一个新的中间件。新的中间件函数接收context和next对应于常规中间件的入参\n函数内部实现了dispatch，用于递归调用中间件数组中的每个函数。dispatch函数接收一个参数i，表示当前调用的中间件函数在数组中的索引。如果i小于等于上一次调用的索引index，则表示next函数被多次调用，koa中间件中next只能被调用一次，调用多次会抛出一个错误。然后，dispatch将index赋值为i，表示当前调用的中间件函数已经被执行。然后dispatch函数会从中间件数组中取出当前索引对应的函数fn，如果当前索引i等于数组长度则说明已经到达中间件函数数组的末尾然后将fn设置为next函数。如果fn不存在则直接返回一个已经resolve的Promise。最后dispatch函数通过Promise.resolve调用当前中间件函数，并将dispatch.bind(null, i + 1)作为下一个中间件函数的next参数传入，以便递归调用下一个中间件函数。如果当前中间件函数抛出了一个错误则通过Promise.reject将错误传递给下一个中间件函数\n总结原理是通过递归调用中间件函数数组中的每个函数，并将next函数作为参数传入，实现洋葱模型中间件的处理顺序。在递归调用的过程中，如果某个中间件函数抛出了错误则通过Promise.reject将错误逐层传递给下一个中间件函数，直到最终返回错误响应或者成功响应\ncontext请求上下文对象，对应中间件的ctx入参context.js文件主要是对外导出了一个对象，以及执行了一系列delegate操作\n\n\n\n导出的对象主要是封装了cookie的读取逻辑\n\ndelegate方法是从delegates npm包进行导入（这个包的解读见# 每天阅读一个 npm 模块(7)- delegates - 掘金）\n\n\n简单来说就是将对context对象上的操作代理到koa封装的request和response对象中去\n// proto这里是contextdelegate(proto, &#x27;response&#x27;).method(&#x27;append&#x27;).access(&#x27;body&#x27;)\n\n这个执行后的结果就是\n\ncontext.append方法调用实际调用的是context.response.append\n\ncontext.body的读写实际调的是context.response.body的读写而context.response则在下面的createContext时将koa的response对象设置在context对象中去\n\n\n在application中通过createContext方法构造后传入请求处理回调函数\nclass Koa extends Emitter &#123;  constructor() &#123;    //....    this.context = Object.create(context);    //....  &#125;  // ...    callback () &#123;    const fn = this.compose(this.middleware)    if (!this.listenerCount(&#x27;error&#x27;)) this.on(&#x27;error&#x27;, this.onerror)    const handleRequest = (req, res) =&gt; &#123;      const ctx = this.createContext(req, res)      return this.handleRequest(ctx, fn)    &#125;    return handleRequest  &#125;      createContext (req, res) &#123;    /** @type &#123;Context&#125; */    const context = Object.create(this.context)    /** @type &#123;KoaRequest&#125; */    const request = context.request = Object.create(this.request)    /** @type &#123;KoaResponse&#125; */    const response = context.response = Object.create(this.response)    // 挂载    context.app = request.app = response.app = this    context.req = request.req = response.req = req    context.res = request.res = response.res = res    request.ctx = response.ctx = context    request.response = response    response.request = request    context.originalUrl = request.originalUrl = req.url    context.state = &#123;&#125;    return context  &#125;&#125;\n\n主要是将我们koa中常用的几个对象挂载到相应的地方，经过createContext的操作，我们可以得到可以通过以下方式获取相关对象\n\nkoa app实例\napp === context.app === context.request.app === context.response.app\n\n\nkoa 请求context对象\ncontext  === context.request.ctx === context.response.ctx\n\n\nkoa request对象 \nctx.request === ctx.response.request\n\n\nkoa response对象\nctx.response === ctx.request.response\n\n\n原生req对象\ncontext.req === context.request.req === context.response.req\n\n\n原生res对象\ncontext.res === context.response.res === context.request.res\n\n\n\nrequestkoa中的请求对象封装。基本上都是基于Node.js的http请求的request做一些便捷使用的二次封装的属性和方法，并挂载在ctx.request中\n一个例子就是Node.js 的http server回调函数入参的req对象http.ImcomingMessage 是没有提供便捷的获取query参数信息，它只有一个url属性\n而koa的request对象则实现了query的解析、获取、设置等\n// request.jsget query () &#123;    const str = this.querystring    const c = this._querycache = this._querycache || &#123;&#125;    return c[str] || (c[str] = qs.parse(str))  &#125;  get querystring () &#123;    if (!this.req) return &#x27;&#x27;    return parse(this.req).query || &#x27;&#x27;  &#125;\n\nresponsekoa中的响应对象封装，基于Node.js的http请求的response做一些封装的属性和方法，挂载在ctx.response中\n一个比较常用到的就是会有根据我们的ctx.body设置的值（会delegate到ctx.response.body中）帮我们去设置response的Content-Type的值，例如给ctx.body设置一个普通js对象的话，会将Content-Type设置为json类型并将js对象json序列化（序列化逻辑在上面提到的respond函数中）\n\n\n最近更新作为一个代码实现非常精简且已经非常稳定的广泛使用的框架，一般来说不会有什么更新了，2.x也已经稳定了很久。但是在1/2却更新了3.0.0-alpha.0版本，翻看更新记录这个大版本目前只更新了一个功能\n\n可以直接使用app.currentContext来获取当前的请求上下文对象，这个功能可以方便不少我们的代码开发\n通过上面我们知道，koa的contxt对象是每次请求维度的一个新对象，如果我们想在一些封装的方法中获拿到当前请求的context对象，必须层层传递context对象会比较麻烦\n//  fn.jsconst fn = (ctx) =&gt; &#123;    console.log(ctx.url)&#125;exports.fn = fn// app.jsconst app = new Koa();app.use(ctx =&gt; &#123;  ctx.body = &#x27;Hello Koa&#x27;;  fn(ctx)&#125;).listen(3000);\n\n而支持了app.currentContext后，我们在任意地方想获取当前的请求上下文对象直接app.currentContext即可，无需再多层透传context对象\n//  fn.jsconst fn = () =&gt; &#123;    console.log(app.currentContext.url)&#125;\n\n这个功能的实现利用了Node.js的async_hooks模块提供的AsyncLocalStorage。AsyncLocalStorage 是 Node.js 在v14.8.0 版本中引入的一个模块，是官方推荐的在异步代码中管理数据的方式之一，会将我们保存的数据与异步操作所在的上下文关联起来，确保在异步操作中访问到相应正确的数据\nAsyncLocalStorage 有两个主要的方法\n\nrun()：用于在异步操作中保存数据。接收一个回调函数作为参数，该回调函数会在异步操作执行期间被调用，并且在该回调函数中保存的数据会与异步操作所在的上下文关联起来\n\ngetStore()：用于在异步操作中获取数据。它会返回与异步操作所在的上下文关联的数据\n\n\n所以在koa中实现app.currentContext功能主要就是以下代码\n// application.jsclass Application extends Emitter &#123;   constructor (options) &#123;    //....    if (options.asyncLocalStorage) &#123;      const &#123; AsyncLocalStorage &#125; = require(&#x27;async_hooks&#x27;)      this.ctxStorage = new AsyncLocalStorage()      this.use(this.createAsyncCtxStorageMiddleware())        &#125;    &#125;   // ...  createAsyncCtxStorageMiddleware () &#123;    const app = this    return async function asyncCtxStorage (ctx, next) &#123;      await app.ctxStorage.run(ctx, async () =&gt; &#123;        return await next()      &#125;)    &#125;  &#125;  // ....   get currentContext () &#123;    if (this.ctxStorage) return this.ctxStorage.getStore()  &#125;&#125;\n\n\n如果初始化时配置了option.asyncLocalStorage，就注册一个放在第一位的koa中间件\n\n在请求进入中间件时会执行ctxStorage.run 存入当前的context对象并马上在回调函数中执行next（即请求后续所有的操作）\n\n在后续获取即可通过getStore()获取到当前请求的context对象\n\n\n总结通过本文的学习我们了解到了koa的一些使用和实现，koa的源码是非常精简的没有太多耦合功能，但是设计了巧妙的中间件机制设计来方便让我们开发各种功能\n\n","categories":["node"],"tags":["node"]},{"title":"LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（上）","url":"/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8A%EF%BC%89.html","content":"\n\n\n前言Langchain 是一个大语言模型（LLM）应用开发的框架，提供了 LLM 开发中各个阶段很多非常强大的辅助工具支持。对于进行 LLM 开发是必不可少的工具库。\n本文将通过一个实际的开发例子来入门 LLM 开发基础工具链，并实现 langchain.js ChatModel 接入火山引擎大模型和基于 langchain 工具链实现一个简单的 CLI 聊天机器人\n\nChatModel &amp; LLM目前国内外有各种各样的大模型，而 langchain 作为一个通用 LLM 应用框架，它本身是和具体大模型无关的，是可以和任意模型进行交互的。要实现和模型的交互就要实例化使用相应的模型。\n一个以 OpenAI 为例子则是安装相应的@langchain/openai和配置相应的 API key 进行使用即可\nimport &#123; ChatOpenAI &#125; from &#x27;@langchain/openai&#x27;import &#123; HumanMessage, SystemMessage &#125; from &#x27;@langchain/core/messages&#x27;const messages = [  new SystemMessage(&#x27;Translate the following from English into Italian&#x27;),  new HumanMessage(&#x27;hi!&#x27;),]const model = new ChatOpenAI(&#123; model: &#x27;gpt-4&#x27; &#125;)await model.invoke(messages)\n\n由于 langchain 目前没有提供火山引擎模型的集成，这里我们需要实现一个对于火山引擎大模型的集成\n在 langchain 中有两个组件都可以实现模型的对接分别是 ChatModel 和 LLM。\n其中 LLM 实现由于只能接收字符串作为输入输出，对于新模型目前已经不再推荐使用。而是使用 ChatModel的实现来替代，ChatModel 是可以使用一系列消息作为输入并返回聊天消息作为输出的语言模型。支持将不同的角色分配给对话消息，有助于区分来自 AI、用户和系统消息等。\n因此我们这里使用ChatModel来实现火山引擎的接入\n火山引擎大模型开通目前火山引擎对于每个大模型都提供了 50 万的白嫖 token 和部分模型的免费试用\n\n创建接入点完成相关基础的注册认证后，前往火山方舟在线推理新建接入点\n\n记住我们的接入点ep-xxx作为下面初始化的 model参数\n创建 API key前往 API key 管理 创建 API key\n\n实现自定义 ChatModel要实现 langchan 中的大模型对接需要实现SimpleChatModel基类，主要实现以下 3 个方法\n\nabstract _call(messages: BaseMessage[], options: this[&quot;ParsedCallOptions&quot;], runManager?: CallbackManagerForLLMRun): Promise&lt;string&gt;;\n\n大模型调用，传入对话消息返回大模型返回的字符串\n\nabstract _llmType(): string;\n\n返回模型名称，便于在日志中打印调试\n\n_streamResponseChunks(_messages: BaseMessage[], _options: this[&quot;ParsedCallOptions&quot;], _runManager?: CallbackManagerForLLMRun): AsyncGenerator&lt;ChatGenerationChunk&gt;;\n\n大模型交互时流式输出支持，调用 model.stream等方法时会调用该实现\n因此对接大模型的实现思路也是比较清晰，主要就是实现_call和_streamResponseChunks根据接收的参数来根据火山引擎的 Open API 文档进行调用\n主要实现\n参数和类型定义\n\n我们对外导出ChatVolcengine类作为模型对接使用。按照火山引擎的文档将相关的模型参数作为构造类的入参\n\n\n为了提供良好的用户使用体验，并将火山引擎的数据结构用相应的 ts 声明表示，详见\n\nOpen API 请求封装\n\n一般大模型的接口返回都支持流式和非流式，这里我们实现request方法将和大模型 OpenApi 的非流式和流式调用作为统一的封装。将 langchain 的数据结构转化为火山引擎接收的数据结构并调用 Open API\nasync _request(messages: BaseMessage[], options: this[&#x27;ParsedCallOptions&#x27;], stream?: boolean): Promise&lt;Response&gt; &#123;  const parameters = this.invocationParams()  const messagesMapped: MessageParam[] = messages.map(message =&gt; (&#123;    role: messageToRole(message),    content: message.content as string,  &#125;))  const request: ChatCompletionRequest = &#123;    ...parameters,    ...options,    messages: messagesMapped,  &#125;  if (stream) &#123;    request.stream = stream  &#125;  return this.caller.call(async () =&gt; &#123;    const response = await fetch(`$&#123;this.volcengineApiHost&#125;/api/v3/chat/completions`, &#123;      method: &#x27;POST&#x27;,      headers: &#123;        &#x27;Authorization&#x27;: `Bearer $&#123;this.volcengineApiKey&#125;`,        &#x27;Content-Type&#x27;: &#x27;application/json&#x27;,      &#125;,      body: JSON.stringify(request),      signal: options.signal,    &#125;)    if (!response.ok) &#123;      const error: SimpleChatCompletionResponse | StreamChatCompletionResponse = await response.json()      throw new Error(error.error?.message ?? &#x27;Unknown error&#x27;)    &#125;    return response  &#125;)&#125;\n\n\n_call 方法实现\n\n_call 方法是在模型调用invoke等方法时被调用，返回的是模型返回的字符串回答。我们在该方法下也支持流式调用，如果是流式调用则把流式调用的结果拼接成完整的字符串后再返回\nasync _call(messages: BaseMessage[], options: this[&#x27;ParsedCallOptions&#x27;], runManager?: CallbackManagerForLLMRun): Promise&lt;string&gt; &#123;  if (this.enableStream) &#123;    // 在该方法下也支持流式调用，如果是流式调用则把流式调用的结果拼接成完整的字符串后再返回    let content = &#x27;&#x27;    // _streamResponseChunks 是下面提到的流式调用    for await (const chunk of this._streamResponseChunks(      messages,      options,      runManager,    )) &#123;      content += chunk.text    &#125;    return content  &#125;  else &#123;    const res = await this._request(messages, options)    const data: SimpleChatCompletionResponse = await res.json()    return data.choices?.[0]?.message?.content  &#125;&#125;\n\n\n_streamResponseChunks 方法实现\n\n该方法用于大模型交互时流式输出支持，例如调用 model.stream等。\nlangchain 提供了工具函数convertEventStreamToIterableReadableDataStream。这里我们只需要将调用_request方法返回的响应传递给工具方法即可得到一个IterableReadableDataStream，对该流进行解析即可实现流式返回解析。\n每次接收到的数据进行 JSON 序列化后调用ChatGenerationChunk和AIMessageChunk构造出生成器函数的返回对象就完成了整个流式数据的读取。需要注意的是火山引擎流式接口使用 SSE 协议并以[DONE]作为结束标记，在chunk 为 [DONE] 时需要退出流的解析\nimport &#123; convertEventStreamToIterableReadableDataStream &#125; from &#x27;@langchain/core/utils/event_source_parse&#x27;  async *_streamResponseChunks(    _messages: BaseMessage[],    _options: this[&#x27;ParsedCallOptions&#x27;],    _runManager?: CallbackManagerForLLMRun,  ): AsyncGenerator&lt;ChatGenerationChunk&gt; &#123;    const response = await this._request(_messages, _options, true)    if (!response.body) &#123;      throw new Error(&#x27;No body in response&#x27;)    &#125;    // 只需要将调用`_request`方法返回的响应传递给工具方法即可得到一个`IterableReadableDataStream`    const stream = convertEventStreamToIterableReadableDataStream(response.body)    // 对该流进行解析即可实现流式返回解析    for await (const chunk of stream) &#123;      try &#123;        // 需要注意的是火山引擎流式接口使用 SSE 协议并以`[DONE]`作为结束标记，在`chunk` 为 `[DONE]` 时需要退出流的解析        if (chunk === &#x27;[DONE]&#x27;) &#123;          break        &#125;        const data: StreamChatCompletionResponse = JSON.parse(chunk)        const text = data.choices?.[0]?.delta.content        // 每次接收到的数据进行 JSON 序列化后调用`ChatGenerationChunk`和`AIMessageChunk`构造出生成器函数的返回对象就完成了整个流式数据的读取        yield new ChatGenerationChunk(&#123;          text,          message: new AIMessageChunk(&#123;            content: text,            additional_kwargs: &#123;              logprobs: data.choices?.[0].logprobs,              finish_reason: data.choices?.[0].finish_reason,            &#125;,            usage_metadata: &#123;              input_tokens: data.usage?.prompt_tokens ?? 0,              output_tokens: data.usage?.completion_tokens ?? 0,              total_tokens: data.usage?.total_tokens ?? 0,            &#125;,          &#125;),        &#125;)        await _runManager?.handleLLMNewToken(text)      &#125;      catch &#123;        console.error(`Received a non-JSON parseable chunk: $&#123;chunk&#125;`)      &#125;    &#125;  &#125;\n\nPS: 对于更加进一步实现模型调用 tracing 等能力，可以实现基类BaseChatModel。\n由于这里我们只作为聊天工具使用为了简单起见直接实现的SimpleChatModel，SimpleChatModel本身也是继承自BaseChatModel，只是自带实现了简单版本的abstract _generate(messages: BaseMessage[], options: this[&quot;ParsedCallOptions&quot;], runManager?: CallbackManagerForLLMRun): Promise&lt;ChatResult&gt;; 方法\n至此，我们即实现了 langchain 对火山引擎大模型的对接，代码验证\nimport &#123; HumanMessage &#125; from &#x27;@langchain/core/messages&#x27;import &#123; ChatVolcengine &#125; from &#x27;../dist/index.mjs&#x27;import &#x27;dotenv/config&#x27;const chatModel = new ChatVolcengine(&#123;  volcengineApiHost: process.env.VOLCENGINE_HOST,  volcengineApiKey: process.env.VOLCENGINE_API_KEY,  model: process.env.VOLCENGINE_MODEL,&#125;)const res = await chatModel.invoke([new HumanMessage(&#123; content: &#x27;Hi! I\\&#x27;m Bob&#x27; &#125;)])console.log(&#x27;ans&#x27;, res)\n\n可见我们这里已经调用火山引擎大模型成功了\n\n该 langchain 火山引擎大模型集成代码同时发布了 npm 包 langchain-bytedance-volcengine\n参考\nConceptual guide\nCreate a custom chat model class\n\n","categories":["LLM"],"tags":["LLM"]},{"title":"LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（下）","url":"/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8B%EF%BC%89.html","content":"\n\n\n书接上回，我们已经实现了一个 langchain.js 接入火山引擎的 ChatModel。\n本文我们实现将这个大模型接入到聊天 CLI 实现和大模型进行交互式问答\n需求我们希望这个简易的聊天 CLI 能够拥有以下功能\n\n启动时由用户输入 prompt\n支持回答流式输出\n支持连续聊天和清空上下文\n\n聊天 CLI 基础能力实现由于实现基本的 CLI 输入输出不是本文重点。这里我们直接通过以下代码实现一个简单的 node.js 交互式程序，实现了\n\n启动后接收用户输入的 prompt\n接收/clear 指令打印清空\n其它输入后原样打印\n\nimport readline from &#x27;node:readline&#x27;import process, &#123; stdin, stdout &#125; from &#x27;node:process&#x27;import &#123; EventEmitter &#125; from &#x27;node:events&#x27;class ChatCli extends EventEmitter &#123;  constructor() &#123;    super()    this.input = stdin    this.output = stdout    this.input.setEncoding(&#x27;utf-8&#x27;)    this.output.setEncoding(&#x27;utf-8&#x27;)  &#125;  async runInputLoop() &#123;    const prompt = await this.prompt(&#x27;请输入 prompt\\n &gt; &#x27;)    console.log(&#x27;prompt&#x27;, prompt)    return new Promise((resolve) =&gt; &#123;      const rl = readline.createInterface(this.input, this.output)      rl.setPrompt(&#x27;&gt; &#x27;)      rl.prompt()      rl.on(&#x27;line&#x27;, async (line) =&gt; &#123;        if (line === &#x27;\\\\clear&#x27;) &#123;          this.write(&#x27;清空上下文\\n&#x27;)        &#125;        else &#123;          this.write(`xxx $&#123;line&#125;`)          this.write(&#x27;\\n&#x27;)        &#125;        rl.prompt()      &#125;)      rl.on(&#x27;close&#x27;, resolve)      rl.on(&#x27;SIGINT&#x27;, () =&gt; &#123;        rl.close()        process.emit(&#x27;SIGINT&#x27;, &#x27;SIGINT&#x27;)      &#125;)    &#125;)  &#125;  write(data) &#123;    this.output.write(data)  &#125;  prompt(query = &#x27;&gt; &#x27;) &#123;    return new Promise((resolve) =&gt; &#123;      const rl = readline.createInterface(this.input, this.output)      rl.question(query, (answer) =&gt; &#123;        resolve(answer)        rl.close()      &#125;)    &#125;)  &#125;&#125;const cli = new ChatCli()cli.runInputLoop()\n\n\n大模型接入由于聊天 CLI 已经实现，我们只需要在对应的代码点进行模型的交互。相关接入火山引擎细节见LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（上）\n初始化 langchain 火山大模型构造函数中初始化火山大模型\nimport &#123; ChatVolcengine &#125; from &#x27;langchain-bytedance-volcengine&#x27;class ChatCli extends EventEmitter &#123;  constructor() &#123;    super()    // ....    // 初始化火山大模型    this.chatModel = new ChatVolcengine(&#123;      volcengineApiHost: process.env.VOLCENGINE_HOST,      volcengineApiKey: process.env.VOLCENGINE_API_KEY,      model: process.env.VOLCENGINE_MODEL,    &#125;)    // ....  &#125;&#125;\n\nprompt 接收和大模型聊天交互\n将接受的 prompt 作为SystemMessage和将用户输入作为 HumanMessage传入stream方法。这里的SystemMessage和HumanMessage也是 langchain 提供的工具类用于构造消息\n\n解析大模型返回的流式数据输出到终端\n\n\nimport &#123; HumanMessage, SystemMessage &#125; from &#x27;@langchain/core/messages&#x27; async runInputLoop() &#123;    const prompt = await this.prompt(&#x27;请输入 prompt\\n &gt; &#x27;)    return new Promise((resolve) =&gt; &#123;      //....      rl.on(&#x27;line&#x27;, async (line) =&gt; &#123;        if (line === &#x27;\\\\clear&#x27;) &#123;          this.write(&#x27;清空上下文\\n&#x27;)        &#125;        else &#123;          const stream = await this.chatModel.stream([new SystemMessage(prompt), new HumanMessage(line)])          for await (const chunk of stream) &#123;            this.write(chunk.content)          &#125;          this.write(&#x27;\\n&#x27;)        &#125;        //....      &#125;)      //....    &#125;)  &#125;\n\n运行效果\n\n连续聊天能力实现虽然我们已经和 CLI 打通了和大模型的交互聊天，但是此时聊天 CLI 是没有聊天上下文功能的。\n\n我们需要为这个聊天 CLI 增加上下文功能。对于直接调用大模型 OPEN API 来说，这通常需要我们将上下文手动处理传入大模型的 API。\n但是上面提过，作为一个强大的 LLM 应用开发框架，langchain 提供了开箱即用的能力帮助我们实现。\nlangchain 只所以称为 chain，它是可以以自定义chain的形式将多个工具串联起来使用。每个串联起来的工具必须是一个实现了 Runnable 接口的实例，目前 langchain 中实现了Runnable 接口的组件有 Prompt ChatModel LLM OutputParser Retriever Tool\n这里我们使用 langchain 提供的RunnableWithMessageHistory进行聊天上下文的记录和调用；使用InMemoryChatMessageHistory来实现内存的聊天上下文的存储\n修改代码实现如下\n\n通过 ChatPromptTemplate.fromMessages 来初始化传给模型的完整 prompt。其中第一项为我们输入的SystemMessage，第二项为占位传递的历史上下文，第三项是本次我们的输入\n\n通过自定义链将这个prompt和我们的火山chatModel串联起来\n\n将自定义链传递给RunnableWithMessageHistory构造出 withMessageHistory 对象，并实现聊天历史的上下文对象\n\n通过 withMessageHistory.stream 进行模型的调用，并同时传递本次的上下文config对象\n\n\nimport &#123;  ChatPromptTemplate,  MessagesPlaceholder,&#125; from &#x27;@langchain/core/prompts&#x27;import &#123; InMemoryChatMessageHistory &#125; from &#x27;@langchain/core/chat_history&#x27;import &#123; RunnableWithMessageHistory &#125; from &#x27;@langchain/core/runnables&#x27;async runInputLoop() &#123;  const _prompt = await this.prompt(&#x27;请输入 prompt\\n &gt; &#x27;)  // 通过 `ChatPromptTemplate.fromMessages` 来初始化传给模型的完整 prompt。其中第一项为我们输入的`SystemMessage`，第二项为占位传递的历史上下文，第三项是本次我们的输入  const prompt = ChatPromptTemplate.fromMessages([    [&#x27;system&#x27;, _prompt],    new MessagesPlaceholder(&#x27;chat_history&#x27;),    [&#x27;human&#x27;, &#x27;&#123;input&#125;&#x27;],  ])  // 通过自定义链将这个`prompt`和我们的火山`chatModel`串联起来  const chain = prompt.pipe(this.chatModel)  const messageHistories = &#123;&#125;  // 将自定义链传递给`RunnableWithMessageHistory`构造出 `withMessageHistory` 对象，并实现聊天历史的上下文对象  const withMessageHistory = new RunnableWithMessageHistory(&#123;    runnable: chain,    getMessageHistory: async (sessionId) =&gt; &#123;      if (messageHistories[sessionId] === undefined) &#123;        messageHistories[sessionId] = new InMemoryChatMessageHistory()      &#125;      return messageHistories[sessionId]    &#125;,    inputMessagesKey: &#x27;input&#x27;,    historyMessagesKey: &#x27;chat_history&#x27;,  &#125;)    return new Promise((resolve) =&gt; &#123;      const config = &#123;        configurable: &#123;          sessionId: `$&#123;Date.now()&#125;`,        &#125;,      &#125;      rl.on(&#x27;line&#x27;, async (line) =&gt; &#123;        if (line === &#x27;\\\\clear&#x27;) &#123;          // 接收重置上下文是更新 config          config.configurable.sessionId = `$&#123;Date.now()&#125;`        &#125;        else &#123;          // 通过 `withMessageHistory.stream` 进行模型的调用，并同时传递本次的上下文`config`对象          const stream = await withMessageHistory.stream(&#123;            input: line,          &#125;, config)          for await (const chunk of stream) &#123;            this.write(chunk.content)          &#125;          this.write(&#x27;\\n&#x27;)        &#125;        rl.prompt()      &#125;)      //....    &#125;)&#125;\n\n再次运行代码测试，表现符合预期\n\n完整实现代码详见\nimport readline from &#x27;node:readline&#x27;import process, &#123; stdin, stdout &#125; from &#x27;node:process&#x27;import &#123; EventEmitter &#125; from &#x27;node:events&#x27;import &#123; ChatVolcengine &#125; from &#x27;langchain-bytedance-volcengine&#x27;import &#x27;dotenv/config&#x27;import &#123; HumanMessage, SystemMessage &#125; from &#x27;@langchain/core/messages&#x27;import &#123;  ChatPromptTemplate,  MessagesPlaceholder,&#125; from &#x27;@langchain/core/prompts&#x27;import &#123; InMemoryChatMessageHistory &#125; from &#x27;@langchain/core/chat_history&#x27;import &#123; RunnableWithMessageHistory &#125; from &#x27;@langchain/core/runnables&#x27;class ChatCli extends EventEmitter &#123;  constructor() &#123;    super()    this.input = stdin    this.output = stdout    this.input.setEncoding(&#x27;utf-8&#x27;)    this.output.setEncoding(&#x27;utf-8&#x27;)    this.chatModel = new ChatVolcengine(&#123;      volcengineApiHost: process.env.VOLCENGINE_HOST,      volcengineApiKey: process.env.VOLCENGINE_API_KEY,      model: process.env.VOLCENGINE_MODEL,    &#125;)  &#125;  async runInputLoop() &#123;    const _prompt = await this.prompt(&#x27;请输入 prompt\\n &gt; &#x27;)    const prompt = ChatPromptTemplate.fromMessages([      [&#x27;system&#x27;, _prompt],      new MessagesPlaceholder(&#x27;chat_history&#x27;),      [&#x27;human&#x27;, &#x27;&#123;input&#125;&#x27;],    ])    const chain = prompt.pipe(this.chatModel)    const messageHistories = &#123;&#125;    const withMessageHistory = new RunnableWithMessageHistory(&#123;      runnable: chain,      getMessageHistory: async (sessionId) =&gt; &#123;        if (messageHistories[sessionId] === undefined) &#123;          messageHistories[sessionId] = new InMemoryChatMessageHistory()        &#125;        return messageHistories[sessionId]      &#125;,      inputMessagesKey: &#x27;input&#x27;,      historyMessagesKey: &#x27;chat_history&#x27;,    &#125;)    return new Promise((resolve) =&gt; &#123;      const rl = readline.createInterface(this.input, this.output)      rl.setPrompt(&#x27;&gt; &#x27;)      rl.prompt()      const config = &#123;        configurable: &#123;          sessionId: `$&#123;Date.now()&#125;`,        &#125;,      &#125;      rl.on(&#x27;line&#x27;, async (line) =&gt; &#123;        if (line === &#x27;\\\\clear&#x27;) &#123;          config.configurable.sessionId = `$&#123;Date.now()&#125;`        &#125;        else &#123;          const stream = await withMessageHistory.stream(&#123;            input: line,          &#125;, config)          for await (const chunk of stream) &#123;            this.write(chunk.content)          &#125;          this.write(&#x27;\\n&#x27;)        &#125;        rl.prompt()      &#125;)      rl.on(&#x27;close&#x27;, resolve)      rl.on(&#x27;SIGINT&#x27;, () =&gt; &#123;        rl.close()        process.emit(&#x27;SIGINT&#x27;, &#x27;SIGINT&#x27;)      &#125;)    &#125;)  &#125;  write(data) &#123;    this.output.write(data)  &#125;  prompt(query = &#x27;&gt; &#x27;) &#123;    return new Promise((resolve) =&gt; &#123;      const rl = readline.createInterface(this.input, this.output)      rl.question(query, (answer) =&gt; &#123;        resolve(answer)        rl.close()      &#125;)    &#125;)  &#125;&#125;const cli = new ChatCli()cli.runInputLoop()\n\n总结通过本文我们实现了一个简易的聊天 CLI，并成功接入了火山引擎大模型，实现了流式输出和上下文管理功能。通过 langchain.js 提供的工具类和自定义链，我们不仅简化了与大模型的交互，还实现了连续聊天的能力\n","categories":["LLM"],"tags":["LLM"]},{"title":"Node.js 中的进程和线程原理学习","url":"/Node.js%20%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.html","content":"\n\n\n\n本文所有的代码均基于 node.js 14 LTS 版本分析\n\n概念进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位，操作系统的其他所有内容都是围绕着进程展开的\n线程是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行\n一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源\n单线程require(&quot;http&quot;)  .createServer((req, res) =&gt; &#123;    res.writeHead(200);    res.end(&quot;Hello World&quot;);  &#125;)  .listen(8000);console.log(&quot;process id&quot;, process.pid);\n\ntop -pid 28840 查看线程数可见在这种情况下有 7 个线程\n\n一个 node 进程通常包含：\n\n1 个 Javascript 执行主线程\n1 个 watchdog 监控线程用于处理调试信息\n1 个 v8 task scheduler 线程用于调度任务优先级\n4 个 v8 线程用于执行代码调优与 GC 等后台任务\n异步 I/O 的 libuv 线程池（如果涉及文件读写，默认为 4 个，可通过process.env.UV_THREADPOOL_SIZE进行设置。网络 I/O 不占用线程池）\n\n\n事件循环既然 js 执行线程只有一个，那么 node 还能支持高并发在于 node 进程中通过 libuv 实现了一个事件循环机制，当执主程发生阻塞事件，如 I/O 操作时，主线程会将耗时的操作放入事件队列中，然后继续执行后续程序。事件循环会尝试从 libuv 的线程池中取出一个空闲线程去执行队列中的操作，执行完毕获得结果后，通知主线程，主线程执行相关回调，并且将线程实例归还给线程池。通过此模式循环往复，来保证非阻塞 I/O，以及主线程的高效执行\n\n整个流程分为 2 个 while 循环\n\n外层大循环，执行 uv_run + DrainVMTasks\n内层 libuv uv_run事件循环\n\n//src/node_main_instance.h// ... // Start running the node.js instances, return the exit code when finished.  int Run();// ...// src/node_main_instance.ccnamespace node &#123;// ...int nodeMainInstance::Run() &#123;    do &#123;        // 执行一次libuv事件循环        uv_run(env-&gt;event_loop(), UV_RUN_DEFAULT);         // 执行v8中的一些挂起的任务队列的函数        per_process::v8_platform.DrainVMTasks(isolate_);        // 检查事件循环是否还有待处理        more = uv_loop_alive(env-&gt;event_loop());        // 继续        if (more &amp;&amp; !env-&gt;is_stopping()) continue;        // 无待处理        if (!uv_loop_alive(env-&gt;event_loop())) &#123;        // 检查process.on(beforeExit)事件，若无退出          if (EmitProcessBeforeExit(env.get()).IsNothing())            break;        &#125;        // 若有继续下一轮循环处理一下        // Emit `beforeExit` if the loop became alive either after emitting        // event, or after running some callbacks.        more = uv_loop_alive(env-&gt;event_loop());  &#125; while (more == true &amp;&amp; !env-&gt;is_stopping());    //....    &#125;&#125;\n\n\n\n主要有 libuv 提供的两个函数uv_run 和 uv_loop_alive\n\nuv_run(env-&gt;event_loop(), UV_RUN_DEFAULT) 执行一轮事件循环 。UV_RUN_DEFAULT 是 libuv 执行事件循环的执行模式，事件循环会一直运行直到没有更多的事件要处理或者程序被强制退出\n\ntypedef enum &#123;  UV_RUN_DEFAULT = 0,// 默认模式。在该模式下，事件循环会一直运行，直到没有更多的事件要处理或者程序被强制退出  UV_RUN_ONCE,// 单次模式。在该模式下，事件循环只会运行一次，处理完所有当前已有的事件后立即退出。主要用于一些清理操作  UV_RUN_NOWAIT // 非阻塞模式。在该模式下，事件循环会轮询当前的 I/O 事件，如果没有 I/O 事件需要处理则立即退出。在node代码中用来写单测&#125; uv_run_mode;\n\nuv_run代码如下，它的返回值是是否有活跃事件\nint uv_run(uv_loop_t* loop, uv_run_mode mode) &#123;  int timeout;  int r;  int ran_pending; // 判断有没有活跃的事件（事件监听 I/O、定时器等）  r = uv__loop_alive(loop);  // 无活跃事件，更新时间 loop-&gt;time = uv__hrtime(UV_CLOCK_FAST) / 1000000  if (!r)    uv__update_time(loop);  //  若有活跃事件进进入  while (r != 0 &amp;&amp; loop-&gt;stop_flag == 0) &#123;    // 更新处理时间    uv__update_time(loop);    // 执行定时事件，从定时事件的最小堆里遍历出相较于loop-&gt;time 已过期的事件，并依次执行其回调    uv__run_timers(loop);    // ⭐️ 运行事件循环中当前已经被添加到队列中但还未执行的任务。如上次事件循环结束后进入的回调、IO结束的回调    ran_pending = uv__run_pending(loop);    // 遍历并执行空转（Idle）事件 ，内部的低优先级的任务或者清理工作等操作    uv__run_idle(loop);    // 遍历并执行准备（Prepare）事件，一些初始化工作或者准备工作，例如检查环境变量、加载配置文件等操作    uv__run_prepare(loop);    timeout = 0;    if ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)    // 获取尚未触发的离现在最近的定时器的时间间隔（uv_backend_timeout），即事件循环到下一次循环的最长时间      timeout = uv_backend_timeout(loop);    // ⭐️ 去监听等待 I/O 事件触发，并以timeout的时间间隔作为最大监听时间，若超时还未有事件触发，则直接取消此次等待，剩下的会在下轮的uv__run_pending处理，因为要去处理定时器事件    // timeout如果为0则马上进入下次循环不等待    uv__io_poll(loop, timeout);     // 更新一下mertic一些统计相关，和事件循环好像没啥关系    uv__metrics_update_idle_time(loop);    // ⭐️ 遍历并执行复查（Check）事件    uv__run_check(loop);    // ⭐️ 对于正在关闭的句柄（一些异步操作引用的底层资源释放）对其进行清理工作，如close事件    uv__run_closing_handles(loop);    if (mode == UV_RUN_ONCE) &#123;       // 单次模式下更新下最新更新时间，再把定时器清理完下面就break，确保退出时没有一些定时器到期没执行      uv__update_time(loop);      uv__run_timers(loop);    &#125;    //  又检查一遍是否还有活跃事件，因为在上述一系列操作，有可能一些事件已经处理了    r = uv__loop_alive(loop);    // 只执行一次的退出    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)      break;  &#125;  if (loop-&gt;stop_flag != 0)  // 重置flag便于下次事件循环    loop-&gt;stop_flag = 0;  return r;&#125;\n\nuv_backend_timeout 正常是查询最近的定时器间隔，有几种情况返回 0，即有一些更重要的事要做而不是同步等待 io 事件\n\n其中idle_handles 由setImmediate 设置执行一些高优任务，马上进入下一次循环处理setImmediate回调\n一次事件循环总结\n\n\nuv_loop_alive(env-&gt;event_loop())\n\n即上面提到的 uv__loop_alive， 判断有没有活跃的事件（事件监听 I/O、定时器等）\n总结严格意义上来说对开发者写代码来说是单线程的，但是对于底层来说是多线程（例如源码中会有 SafeMap 这种线程安全的 map）。由于对于开发者来说是单线程，所以在 Node.js 日程开发中通常不会存在线程竞争的问题和线程锁的一些概念\n子进程从上面的单线程机制可知 Node.js 使用事件循环机制来实现高并发的 I/O 操作。但是如果代码中遇到 CPU 密集型场景，主线程将会长时间阻塞，无法处理额外的请求。为了解决这个问题，并充分发挥多核 CPU 的性能，Node 提供了 child_process 模块用于创建子进程。通过将 CPU 密集型操作分配给子进程处理，主线程可以继续处理其他请求，从而提高性能主要提供了 4 个方法\n\nspawn(command[, args][, options])：以指定的命令及参数数组创建一个子进程。可以通过流来处理子进程的输出和错误信息，大数据量\n\nconst &#123; spawn &#125; = require(&quot;child_process&quot;);const ls = spawn(&quot;ls&quot;, [&quot;-lh&quot;, &quot;/usr&quot;]);ls.stdout.on(&quot;data&quot;, (data) =&gt; &#123;  console.log(`stdout: $&#123;data&#125;`);&#125;);ls.stderr.on(&quot;data&quot;, (data) =&gt; &#123;  console.error(`stderr: $&#123;data&#125;`);&#125;);ls.on(&quot;close&quot;, (code) =&gt; &#123;  console.log(`子进程退出码：$&#123;code&#125;`);&#125;);\n\n\nexec(command[, options][, callback])：对 spawn() 函数的封装，可以直接传入命令行执行，并以回调函数的形式返回输出和错误信息\n\nconst &#123; exec &#125; = require(&quot;child_process&quot;);exec(&quot;ls -lh /usr&quot;, (error, stdout, stderr) =&gt; &#123;  if (error) &#123;    console.error(`exec error: $&#123;error&#125;`);    return;  &#125;  console.log(`stdout: $&#123;stdout&#125;`);  console.error(`stderr: $&#123;stderr&#125;`);&#125;);\n\n\nexecFile(file[, args][, options][, callback])：类似于 exec() 函数，但默认不会创建命令行环境（相应的无法使用一些 shell 的操作符），而是直接以传入的文件创建新的进程，性能略微优于 exec()。\n\nconst &#123; execFile &#125; = require(&quot;child_process&quot;);execFile(&quot;ls&quot;, [&quot;-lh&quot;, &quot;/usr&quot;], (error, stdout, stderr) =&gt; &#123;  if (error) &#123;    console.error(`execFile error: $&#123;error&#125;`);    return;  &#125;  console.log(`stdout: $&#123;stdout&#125;`);  console.error(`stderr: $&#123;stderr&#125;`);&#125;);\n\n\nfork(modulePath[, args][, options])：内部使用 spawn()实现 ，只能用于创建 node.js 程序的子进程，默认会建立父子进程之间的 IPC 信道来传递消息\n\nconst &#123; fork &#125; = require(&quot;child_process&quot;);const lsProcess = fork(&quot;./test.js&quot;);lsProcess.on(&quot;message&quot;, (msg) =&gt; &#123;  console.log(`收到子进程的消息：$&#123;msg&#125;`);&#125;);lsProcess.on(&quot;close&quot;, (code) =&gt; &#123;  console.log(`子进程退出码：$&#123;code&#125;`);&#125;);\n\n\njs - lib/child_process.js\n\nconst child_process = require(&quot;internal/child_process&quot;);const &#123; ChildProcess &#125; = child_process;function spawn(file, args, options) &#123;  //...  const child = new ChildProcess();  //....  return child;&#125;module.exports = &#123;  _forkChild,  ChildProcess,  exec,  execFile,  execFileSync,  execSync,  fork,  spawn: spawnWithSignal,  spawnSync,&#125;;\n\n\nlib/internal/child_process.js\n\nconst &#123; Process &#125; = internalBinding(&quot;process_wrap&quot;);this._handle = new Process();ChildProcess.prototype.spawn = function (options) &#123;  //..  const err = this._handle.spawn(options);  //..&#125;;\n\n\nc++ - src/node_binding.cc\n\n\n\n\n\n\nsrc/process_wrap.cc\n\n\n\nCluster基于child_process node 提供了专门用于创建多进程网络服务的[cluster](https://nodejs.org/api/cluster.html)模块创建多个子进程，并在每个子进程中启动一个独立的 HTTP 服务器进行监听和处理客户端请求\nconst cluster = require(&quot;cluster&quot;);const http = require(&quot;http&quot;);const numCPUs = require(&quot;os&quot;).cpus().length;if (cluster.isMaster) &#123;  console.log(`Master $&#123;process.pid&#125; is running`);  // 创建多个子进程  for (let i = 0; i &lt; numCPUs; i++) &#123;    cluster.fork();  &#125;  // 监听子进程退出事件，自动重启  cluster.on(&quot;exit&quot;, (worker, code, signal) =&gt; &#123;    console.log(`Worker $&#123;worker.process.pid&#125; died`);    cluster.fork();  &#125;);&#125; else &#123;  console.log(`Worker $&#123;process.pid&#125; started`);  // 每个子进程的pid是不一样  // 在每个子进程中启动 HTTP 服务器  http    .createServer((req, res) =&gt; &#123;      res.writeHead(200);      res.end(&quot;Hello, world!&quot;);    &#125;)    .listen(8000);&#125;\n\n如何解决多个工作进程监听一个端口的问题\n\n从 js 层面分析\n\n\n入口区分 - 子进程环境变量含NODE_UNIQUE_ID，在创建子进程时传入\n\n// lib/cluster.jsconst childOrMaster = &quot;NODE_UNIQUE_ID&quot; in process.env ? &quot;child&quot; : &quot;master&quot;;module.exports = require(`internal/cluster/$&#123;childOrMaster&#125;`);\n\n\nhttp.createServer -&gt; lib/_http_server.js#Server - lib/_http_server.js#Server 继承于 TCP 的lib/net.js#Server\nlisten方法调用的是lib/net.js#Server\n\n// lib/net.jsServer.prototype.listen = function (...args) &#123;  // ....  // 关键逻辑  if (typeof options.port === &quot;number&quot; || typeof options.port === &quot;string&quot;) &#123;    validatePort(options.port, &quot;options.port&quot;);    backlog = options.backlog || backlogFromArgs;    // start TCP server listening on host:port    if (options.host) &#123;      lookupAndListen(        this,        options.port | 0,        options.host,        backlog,        options.exclusive,        flags      );    &#125; else &#123;      // Undefined host, listens on unspecified address      // Default addressType 4 will be used to search for master server      listenInCluster(        this,        null,        options.port | 0,        4,        backlog,        undefined,        options.exclusive      );    &#125;    return this;  &#125;  //....&#125;;\n\nlookupAndListen内部其实也是对option.host进行调dns模块查询host后调的listenInCluster\n// 工作进程function listenInCluster(  server,  address,  port,  addressType,  backlog,  fd,  exclusive,  flags) &#123;  exclusive = !!exclusive;  if (cluster === undefined) cluster = require(&quot;cluster&quot;);  // isMaster是通过NODE_UNIQUE_ID是否存在判断  // 非cluster的http模块直接起服务NODE_UNIQUE_ID是空  if (cluster.isMaster || exclusive) &#123;    server._listen2(address, port, addressType, backlog, fd, flags);    return;  &#125;  const serverQuery = &#123;    address: address,    port: port,    addressType: addressType,    fd: fd,    flags,  &#125;;  cluster._getServer(server, serverQuery, listenOnMasterHandle);  function listenOnMasterHandle(err, handle) &#123;    // 获取handler后挂载到子进程server上    server._handle = handle;    server._listen2(address, port, addressType, backlog, fd, flags);  &#125;&#125;\n\n在 listenInCluster 函数中，会判断当前的进程是否是主进程，\n\n如果是则直接进行调用_listen2监听server。_listen2就是 cluster 出现之前的监听函数\n\nServer.prototype._listen2 = setupListenHandle; // legacy alias\n\n如果不是，则通过工作进程查询到主进程的 handle （const &#123; TCP &#125; = internalBinding(&#39;tcp_wrap&#39;); ，c++层暴露的用于处理 TCP 的对象），然后在主进程的 handle 上进行监听\n\ncluster._getServer实现主要逻辑是向当前工作进程发送一个类型为 queryServer 的消息，这个消息会被处理成 cluster 内部消息后发送给主进程\n// lib/internal/cluster/child.jscluster._getServer = function(obj, options, cb) &#123;// ...  const message = &#123;    act: &#x27;queryServer&#x27;,    index,    data: null,    ...options  &#125;;  message.address = address;  send(message, (reply, handle) =&gt; &#123;    else    // 进这个分支      rr(reply, indexesKey, cb);              // Round-robin. //...  &#125;);  obj.once(&#x27;listening&#x27;, () =&gt; &#123;    //..    send(message);    //...  &#125;);&#125;;\n\n主进程有相应的响应 queryServer 消息的地方\n// lib/internal/cluster/master.jsfunction onmessage(message, handle) &#123;//...  else if (message.act === &#x27;queryServer&#x27;)    queryServer(worker, message);//...&#125;function queryServer(worker, message) &#123;//....// 唯一标识 const key = `$&#123;message.address&#125;:$&#123;message.port&#125;:$&#123;message.addressType&#125;:` +              `$&#123;message.fd&#125;:$&#123;message.index&#125;`;  let handle = handles.get(key);  if (handle === undefined) &#123;    let address = message.address;    //第一次进入时，会创建RoundRobinHandle，RoundRobinHandle内部有实际监听端口的逻辑    let constructor = RoundRobinHandle;    handle = new constructor(key, address, message);    //....    handles.set(key, handle);  &#125;  if (!handle.data)    handle.data = message.data;    // 添加当前工作进程加入到RoundRobinHandle工作队列  handle.add(worker, (errno, reply, handle) =&gt; &#123;    const &#123; data &#125; = handles.get(key);    send(worker, &#123;      errno,      key,      ack: message.seq,      data,      ...reply    &#125;, handle);  &#125;);&#125;// lib/internal/cluster/round_robin_handle.jsfunction RoundRobinHandle(key, address, &#123; port, fd, flags &#125;) &#123;   //...  this.server = net.createServer(assert.fail);  //...  this.server.listen(address);// 主进程处理请求分发  this.server.once(&#x27;listening&#x27;, () =&gt; &#123;    this.handle = this.server._handle;    this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);  &#125;);&#125;\n\nRoundRobinHandle 也会覆盖主进程的Server.handle 的 onconnection 逻辑，将其替换成 round-robin 逻辑，即this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);\n再回到这个代码\n  // 工作进程  cluster._getServer(server, serverQuery, listenOnMasterHandle);// _getServer实现  send(message, (reply, handle) =&gt; &#123;  // ....    else    // 进这个分支    // reply      rr(reply, indexesKey, cb);              // Round-robin. //...  &#125;);  function listenOnMasterHandle(err, handle) &#123;    // 获取handler后挂载到子进程server上    server._handle = handle;    server._listen2(address, port, addressType, backlog, fd, flags);  &#125;\n\n在 rr 函数中创建一个 fake handler 返回\n\n\n\n\n这个 handler 就是上面 rr 函数中获取的 handler，而_listen2内部调用的实际是 fake handler 中的 listen 空函数，实际上工作进程并没有对端口进行监听RoundRobinHandle 的distribute实现\n// lib/internal/cluster/round_robin_handle.jsRoundRobinHandle.prototype.distribute = function (err, handle) &#123;  ArrayPrototypePush(this.handles, handle);  const [workerEntry] = this.free; // this.free is a SafeMap  // 选择一个空闲的进程处理  if (ArrayIsArray(workerEntry)) &#123;    const &#123; 0: workerId, 1: worker &#125; = workerEntry;    this.free.delete(workerId);    this.handoff(worker);  &#125;&#125;;RoundRobinHandle.prototype.handoff = function (worker) &#123;  //...  const handle = ArrayPrototypeShift(this.handles);  const message = &#123; act: &quot;newconn&quot;, key: this.key &#125;;  //...  // 取出handler分发给子进程，消息的act为newconn  sendHelper(worker.process, message, handle, (reply) =&gt; &#123;    // 使用轮询进行分发    if (reply.accepted) handle.close();    else this.distribute(0, handle); // Worker is shutting down. Send to another.    this.handoff(worker);  &#125;);&#125;;\n\n工作进程处理newconn消息\n// lib/internal/cluster/child.js// sendHelper分发的事件会带上cmd: &#x27;NODE_CLUSTER&#x27;，NODE_前缀的会触发internalMessageprocess.on(&quot;internalMessage&quot;, internal(worker, onmessage));send(&#123; act: &quot;online&quot; &#125;);function onmessage(message, handle) &#123;  if (message.act === &quot;newconn&quot;) onconnection(message, handle);  else if (message.act === &quot;disconnect&quot;)    ReflectApply(_disconnect, worker, [true]);&#125;function onconnection(message, handle) &#123;  // 在子进程接收到handle引用后，它会重新创建一个与主进程相对应的 handle 对象，从而实现对共享资源的访问  const key = message.key;  const server = handles.get(key);  const accepted = server !== undefined;  send(&#123; ack: message.seq, accepted &#125;);  if (accepted)    // lib/net.js里面tcp server的onconnection处理    server.onconnection(0, handle);&#125;\n\n\n\n总结当主进程的 RoundRobinHandle 接收到一个监听请求时，它会调用distribute函数将客户端的 handle（socket 对象） 传递给工作进程。具体的逻辑为：将这个 handle 保存到队列中，并从工作进程队列中获取一个空闲的工作进程。如果存在空闲的工作进程，则从队列中取出一个工作进程并向其发送act: &quot;newconn&quot; 消息，以将 handle 传递给工作进程。工作进程会使用此 handle 与客户端建立连接，并向主进程发送一条消息表示是否接受了请求。主进程通过 accepted 属性来判断工作进程是否已经接受了请求。如果是则关闭与客户端的连接，并让其与工作进程进行通信。最后，主进程会不断地轮询上述过程以处理更多的客户端请求\n\n多线程为了降低 js 对于 CPU 密集型任务计算的负担，node.js v10 之后引入了 worker_threads。可以在 nodejs 进程内可以创建多个线程。主线程和 worker 线程之间可以通过parentPort实现通信，worker 线程之间可以使用 MessageChannel 进行通信。多个线程之间可以使用SharedArrayBuffer实现共享内存，无需序列化\nconst &#123;  Worker,  isMainThread,  parentPort,  workerData,&#125; = require(&quot;worker_threads&quot;);if (isMainThread) &#123;  // 主线程创建共享内存  const sharedBuffer = new SharedArrayBuffer(1024);  const worker = new Worker(__filename, &#123; workerData: sharedBuffer &#125;);  // 向子线程发送共享内存的引用  worker.postMessage(sharedBuffer);  // 接收子线程发送的消息  worker.on(&quot;message&quot;, (data) =&gt; &#123;    console.log(&quot;sharedBuffer&quot;, sharedBuffer);  &#125;);&#125; else &#123;  // 子线程接收主线程发送的共享内存引用，并使用Atomics操作进行读写  const sharedBuffer = workerData;  const sharedArray = new Int32Array(sharedBuffer);  setInterval(() =&gt; &#123;    const oldValue = Atomics.load(sharedArray, 0);    const newValue = oldValue + 1;    Atomics.store(sharedArray, 0, newValue);    parentPort.postMessage(`Current value in shared memory: $&#123;newValue&#125;`);  &#125;, 1000);&#125;\n\n多线程下共享内存为避免者竞态条件。node.js 也提供了Atomics对象用于执行原子操作，可以保证多个线程对共享内存的读写操作原子性\n","categories":["node"],"tags":["node"]},{"title":"Node.js 宣布一个新的 --experimental-modules【译】","url":"/Node.js%20%E5%AE%A3%E5%B8%83%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%20--experimental-modules%E3%80%90%E8%AF%91%E3%80%91.html","content":"\n\n\n在2017年，Node.js 8.9.0发布了对ECMAScript模块的实验性支持。这种ECMAScript模块的支持是需要在后面加上--experimental-modules标识来运行。\n现在，主流浏览器都能通过&lt;script type=”module”&gt;标签支持ECMAScript 模块 (ES modules) 。各种项目npm包都使用了ES模块编写，并且可以通过&lt;script type= &quot; module &quot; &gt;在浏览器中直接使用。支持导入映射（import maps）即将登陆Chrome。import map将让浏览器支持node.js风格的包名导入。\n这些采用ES模块方面的进展大大加快了Node.js对ES模块的支持速度。既然已经有其他运行时和环境在使用ES模块，那么Node.js支持这个JavaScript标准就更重要了。\nNodejs最初将ES模块作为一个保留实验特性的原因是为了提供时间让社区去讨论和反馈这种设计。Modules Team建立出来就是为了对这些反馈提供支持，最终导致了一个ES模块的新实现。我们很高兴地宣布它将作为Node.js 12版本的一部分发布。它将取代旧的实验模块实现，并且将使用相同的标志（--experimental-modules）。我们希望这个新实现能够解决社区的许多问题，并且能够在2019年10月Node.js 12达到LTS状态之前作为Node.js的一部分正式发布（不需要再带--experimental-modules）\n--experimental-modules包含了什么与之前的版本一样，这个新的实验性模块为Node.js增加了以下支持:\n\nES2015 import语句可以引用那些使用ES模块语法编写的Javascript文件。文件可以被引用为相对url (&#39;./file.mjs &#39;)、绝对file:// url (&#39;file:///opt/app/file.mjs &#39;)、包名(&#39; es-module-package &#39;)或包名路径(&#39;es-module-package/lib/file.mjs &#39;)的形式。\n\nimport语句引用的ES模块文件可以指定默认导出(import _ from ‘es-module-package’)、命名导出(import &#123; shuffle &#125; from ‘es-module-package’) 和命名空间导出(import * as fs from ‘fs’)。所有的Node.js内置模块(如fs和path)都支持这三种类型的导出。\n\nimport语句引用CommonJS文件（当前所有使用require、module.exports编写的Node.js模块）只能使用CommonJS默认导出(import _ from ‘commonjs-package’)。这项工作在进展中并且未来可能会发生改变\n\nES模块文件中的export语句可以指定引用的导入语句为默认导出或命名导出。\n\n动态import()表达式可以用来从CommonJS或者ES模块导入ES模块文件。需要注意的是，这个语句返回的是一个promise\n\nimport.meta.url的值为当前ES模块文件的绝对url。\n\n可以编写加载器（Loaders）来修改Node.Js对于ES模块的行为。这项工作仍然在进行中\n\nNode.js可以将ES模块文件作为程序的初始入口运行\n\n文件作为ES模块被加载是在严格模式下的，如果是CommonJS的话需要在每个文件的最头部加上&#39;use strict&#39;\n\n.mjs结尾的文件在import语句和通过node命令行运行时都将被显式当作ES模块\n\n\n并且，新版本的 --experimental-modules 添加了以下特性：\n.js文件中的import和export语法我们听到了一些非常强烈的反馈Nodejs需要提供一种方式在.js文件中使用import和export语法\n新的--experimental-modules提供了两种方式实现，一种是通过package.json中的type字段，另一种是输入通过传入参数--eval, --print or STDIN添加一个--input-type标示\npackage.json type 字段在你的项目package.json中添加’type’:’module’字段，Node.js就会把项目中所有的.js文件当作ES模块\n如果项目中的一些文件使用了CommonJS并且你不能立即转换它们，你可以把那些文件重命名为.mjs或者把它们放到一个子文件夹然后添加一个package.json包含&#123; “type”: “commonjs” &#125;,这样那些.js文件会被当作CommonJS处理\n当Node.js想要加载任何文件的时候，它将会查找文件当前目录下的package.json文件，找不到的话将向上查找直到根目录。这种行为非常类似于babel的.babelrc文件。这种新的方式允许nodejs使用package级别的元数据和配置，类似于babel和其它工具目前使用的样子\n--input-type flag使用-—input-type=module作为ES模块运行字符串输入(-—eval、-—print或STDIN)。—-input-type的值为-—input-type=module或—input-type=commonjs。\n.cjs扩展名只有.mjs文件扩展名被当作ES模块，新的.cjs文件扩展名将被当作CommonJS模块。.cjs扩展名是当.mjs和.js当作es模块的时候，保留项目中的CommonJS文件用到的。\n显式文件名默认情况下在新的--experimental-modules下，import语句中的文件扩展名是强制性的：import ‘./file.js’并不同于 import ‘./file’。但是，CommonJS风格的自动扩展名处理行为可以通过--es-module-specifier-resolution=node来开启（默认是es-module-specifier-resolution=explicit）。包名引入仍然不变，例如import fs from ‘fs\n我们提供了--es-module-specifier-resolution=node可选使用Commonjs风格扩展名和的解析。但是我们默认关闭了它，在我们去除--experimental-modules之前，用于收集用户对于完全指定路径(fully specified paths)的反馈。你可以在这里找到关于这个话题的讨论。\n这种设计的主要原因是，通过我们提供的特定解决办法，去鼓励开发者们编写浏览器和node共享的代码\nmodule.createRequireFromPathCommonJS的全局变量（如require, exports, module, __filename, __dirname）在ES模块中将不会定义。但是可以使用module.createRequireFromPath() 去创造一个commonJS require函数在ES模块上下文中使用\n只能引入Javascript以前的--experimental-modules 允许导入JSON语句和原生模块。现在这个已经删除了，默认不能导入JSON语句和原生模块，您可以使用module.createRequireFromPath()来实现原先的功能。\n实验性标记--experimental-json-modules可以支持json文件的导入。我们正在用浏览器对这个特性进行标准化，并且Node.js希望我们的支持能与最终的标准保持一致。\n其它也有正在进行的工作，以涵盖WASM和其他未来潜在的模块类型。Node.js以后将以符合规范的方式增加对这些模块类型的支持。\nnpm包中的ES模块代码这是一项正在进行的工作，可能会发生变化。通过package.json的main字段类型指定入口文件（这个文件是ES模块）。你可以使用ES模块创建一个包。如果文件扩展名是.mjs或者package.json包含&#39;type&#39;:&#39;module&#39;Node.js的话，Node.js将它作为ES模块加载。\n目前，无法创建一个既可以通过require(&#39;pkg&#39;)又可以import ‘pkg’来使用的npm包。我们正在努力解决这一问题，并且可能有对上述内容的修改。特别是，Node.js可能会选择&#39;main&#39;以外的字段来定义包的ES模块入口点。但我们意识到社区已经接受了&#39;main&#39;字段,所以这也不太可能这样做因为很多包已经使用了module去引入ES模块的javascript，但可能没有评估在node.js中使用(因为文件名的扩展缺省的,或者代码里面包含require表达式)。在解决这个问题之前，请不要发布任何打算给Node.js使用的ES模块的npm包。\n工作进展上面所有的这些都是作为Node.js 12 --experimental-modules的一部分。在我们的规划中，在 2019年10月 Node.js 12 达到 LTS 并移除--experimental-modules标识之前，我们希望有一些潜在的改进：\n\n加载器（Loader）功能。加载器正在进一步开发以支持进程隔离、多加载器和具有较低级别hook的多领域支持。在标记移除之前，–loader API仍然会有很大的变化。\n双重的CommonJS/ES模块包。我们希望为包作者提供一种标准的方式来发布一个包，这个包既可以被require到CommonJS，也可以被import到ES模块中。\n更容易的require。使用Module.createRequireFromPath()包含许多的模版文件。我们希望提供一种更简单的方式在ES模块代码中进行require\n包路径映射（原文：Package path maps）.我们想要提供一种包内路径到文件的映射。例如允许像import sdk from ‘some-service/sdk’从‘some-service/sdk’到./src/sdk/public-api.mjs的。\n自动入口点模块类型检查。这将提供一种方式来基于静态分析运行Javascript代码（CommonJS或ES模块）\n\n就是这样!我们希望你喜欢这个新的--experimental-modules，并期待您的反馈。模块团队的工作在https://github.com/nodejs/modules公开。\n","categories":["node"],"tags":["node"]},{"title":"React 19 升级指南","url":"/React%2019%20%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97.html","content":"\n\n\n前言React 已于近日发布了 v19 的 beta 版本，同时为了帮助后续的 v19 升级，也同时发布了 v18.3.0的正式版， 与 v18.2 版本完全相同，但添加了弃用 API 的警告和其他为 React 19 所需的更改\n\n安装使用新版 JSX Transform为了改善打包体积和可以在 JSX 文件中无需手动引入 React，在 2020 年 React 引入了新的 JSX Transform。如果在 React 19 中没有使用这个新的 JSX Transform 会有一个报错提示\n\n\n\n如果已经使用了新版 JSX Transform 则可以忽略此步骤\n安装最新版本的 React 和 ReactDomnpm install react@beta react-dom@beta\n\n如果使用 TypeScript，则还需要更新相关类型包。等到 React 19 发布 release 版本后可以就像往常一样从@types/react和@types/react-dom安装类型包。在当前 beta 版本中需要在package.json为类型包配置overrides 锁定版本以确保不同包中的类型是可用的\n&#123;  &quot;dependencies&quot;: &#123;    &quot;@types/react&quot;: &quot;npm:types-react@beta&quot;,    &quot;@types/react-dom&quot;: &quot;npm:types-react-dom@beta&quot;  &#125;,  &quot;overrides&quot;: &#123;    &quot;@types/react&quot;: &quot;npm:types-react@beta&quot;,    &quot;@types/react-dom&quot;: &quot;npm:types-react-dom@beta&quot;  &#125;&#125;\n\nBreaking changesrender 过程中的错误不再二次抛出在之前的 React 版本中，渲染过程中抛出的错误会被捕获并重新抛出。在 DEV 模式下，我们还会记录到 console.error，导致出现重复的错误日志。\n在 React 19 中，改进了错误处理方式，通过不重新抛出来减少重复信息：\n\n未捕获的错误：未被错误边界捕获的错误将调用给 window.reportError\n已捕获的错误：被错误边界捕获的错误将报告将调用给 console.error这个改变不应该影响大多数应用，但如果生产错误报告依赖于错误被重新抛出，则可能需要更新错误处理。为了支持这一点，React 19 添加了新的createRoot和hydrateRoot用于自定义错误处理：\n\nconst root = createRoot(container, &#123;  onUncaughtError: (error, errorInfo) =&gt; &#123;    // ... log error report  &#125;,  onCaughtError: (error, errorInfo) =&gt; &#123;    // ... log error report  &#125;&#125;);\n\n废弃 React API 移除移除propTypes和函数组件的defaultPropspropTypes是用于运行时校验组件 props 的属性，在 Reactv15.5.0已经被标记为废弃，在 v19这个正式删除\n另外函数组件的defaultProps也已经移除（使用 ES6 默认参数替代），由于 class 组件没有相应的 ES6 语法替代因此仍会保留\n// Beforeimport PropTypes from &#x27;prop-types&#x27;;function Heading(&#123;text&#125;) &#123;  return &lt;h1&gt;&#123;text&#125;&lt;/h1&gt;;&#125;Heading.propTypes = &#123;  text: PropTypes.string,&#125;;Heading.defaultProps = &#123;  text: &#x27;Hello, world!&#x27;,&#125;;\n\n// Afterinterface Props &#123;  text?: string;&#125;function Heading(&#123;text = &#x27;Hello, world!&#x27;&#125;: Props) &#123;  return &lt;h1&gt;&#123;text&#125;&lt;/h1&gt;;&#125;\n\n移除使用contextTypes和getChildContext的 Legacy ContextLegacy Context 在2018.10（v16.6.0）已被弃用\nLegacy Context 仅适用于使用contextTypes和getChildContext API 的类组件，并由于易于忽略的微妙错误而被contextType替换。在 React 19 中，将删除 Legacy Context 以使 React 更小更快。仍在类组件中使用 Legacy Context，则需要迁移到新的contextType API：\n// Beforeimport PropTypes from &#x27;prop-types&#x27;;class Parent extends React.Component &#123;  //...  static childContextTypes = &#123;    foo: PropTypes.string.isRequired,  &#125;;  getChildContext() &#123;    return &#123; foo: &#x27;bar&#x27; &#125;;  &#125;  //...  render() &#123;    return &lt;Child /&gt;;  &#125;&#125;class Child extends React.Component &#123;  //...  static contextTypes = &#123;    foo: PropTypes.string.isRequired,  &#125;;  //...  render() &#123;    return &lt;div&gt;&#123;this.context.foo&#125;&lt;/div&gt;;  &#125;&#125;\n\n// After//...const FooContext = React.createContext();//....class Parent extends React.Component &#123;  render() &#123;    return (      &lt;FooContext value=&#x27;bar&#x27;&gt;        &lt;Child /&gt;      &lt;/FooContext&gt;    );  &#125;&#125;class Child extends React.Component &#123;  //...  static contextType = FooContext;  //...  render() &#123;    return &lt;div&gt;&#123;this.context&#125;&lt;/div&gt;;  &#125;&#125;\n\n移除字符串 refs字符串 refs 在2018.3（v16.3.0）被弃用\n在被替换为 ref 回调方式之前类组件支持字符串 refs，但存在多个缺点。在 React 19 中，将删除字符串引用以使 React 更简单易懂\n// Beforeclass MyComponent extends React.Component &#123;  componentDidMount() &#123;    this.refs.input.focus();  &#125;  render() &#123;    return &lt;input ref=&#x27;input&#x27; /&gt;;  &#125;&#125;\n\n如果仍在使用类组件中的字符串引用，则需要迁移到 refs 回调的形式：\n// Afterclass MyComponent extends React.Component &#123;  componentDidMount() &#123;    this.input.focus();  &#125;  render() &#123;    return &lt;input ref=&#123;input =&gt; this.input = input&#125; /&gt;;  &#125;&#125;\n\n移除模块模式工厂模块模式工厂在2019.8（v16.9.0）被弃用。\n// Beforefunction FactoryComponent() &#123;  return &#123; render() &#123; return &lt;div /&gt;; &#125; &#125;&#125;\n\n这种用法其实很少使用，支持它会使 React 比必要的更大和更慢。在 React 19 中，将删除对模块模式工厂的支持，需要迁移到常规函数：\n// Afterfunction FactoryComponent() &#123;  return &lt;div /&gt;;&#125;\n\n移除React.createFactorycreateFactory 在2020.2（v16.13.0）已被弃用。\n// Beforeimport &#123; createFactory &#125; from &#x27;react&#x27;;const button = createFactory(&#x27;button&#x27;);\n\n在 JSX 得到广泛支持之前使用 createFactory 很常见，但是现在已经可以用 JSX 替换。在 React 19 中，将删除 createFactory，需要迁移到 JSX\n// Afterconst button = &lt;button /&gt;;\n\n移除react-test-renderer/shallow在 React 18 中，更新了react-test-renderer/shallow并重新导出react-shallow-renderer。在 React 19 中，将删除react-test-render/shallow，而直接安装该软件包：\nnpm install react-shallow-renderer --save-dev\n\n- import ShallowRenderer from &#x27;react-test-renderer/shallow&#x27;;+ import ShallowRenderer from &#x27;react-shallow-renderer&#x27;;\n\n废弃 ReactDOM API 移除移除react-dom/test-utils移除ReactDOM.renderReactDOM.render在2022 年 3 月（v18.0.0）已被弃用。\n// Beforeimport &#123;render&#125; from &#x27;react-dom&#x27;;render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));\n\n在 React 19 中，将删除 ReactDOM.render，需要迁移到使用ReactDOM.createRoot：\n// Afterimport &#123;createRoot&#125; from &#x27;react-dom/client&#x27;;const root = createRoot(document.getElementById(&#x27;root&#x27;));root.render(&lt;App /&gt;);\n\n移除ReactDOM.hydrateReactDOM.hydrate在2022 年 3 月（v18.0.0）已被弃用。在 React 19 中，将删除 ReactDOM.hydrate，需要迁移到使用ReactDOM.hydrateRoot\n// Beforeimport &#123;hydrate&#125; from &#x27;react-dom&#x27;;hydrate(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;));// Afterimport &#123;hydrateRoot&#125; from &#x27;react-dom/client&#x27;;hydrateRoot(document.getElementById(&#x27;root&#x27;), &lt;App /&gt;);\n\n移除unmountComponentAtNodeReactDOM.unmountComponentAtNode在2022.3（v18.0.0）已被弃用。在 React 19 中需要迁移到使用hydrateRoot和createRoot对应的root.unmount()\n// BeforeunmountComponentAtNode(document.getElementById(&#x27;root&#x27;));// Afterroot.unmount();\n\n移除ReactDOM.findDOMNodeReactDOM.findDOMNode 在2018 年 10 月（v16.6.0）已被弃用\n// Beforeimport &#123;findDOMNode&#125; from &#x27;react-dom&#x27;;function AutoselectingInput() &#123;  useEffect(() =&gt; &#123;    const input = findDOMNode(this);    input.select()  &#125;, []);  return &lt;input defaultValue=&quot;Hello&quot; /&gt;;&#125;\n\n可以使用 DOM 引用替换 ReactDOM.findDOMNode\n// Afterfunction AutoselectingInput() &#123;  const ref = useRef(null);  useEffect(() =&gt; &#123;    ref.current.select();  &#125;, []);  return &lt;input ref=&#123;ref&#125; defaultValue=&quot;Hello&quot; /&gt;&#125;\n\n新增废弃废弃element.ref属性从 React 19 开始，现在可以将ref作为函数组件的 prop 访问\n如果直接访问 element.ref会出现警告\nfunction MyInput(&#123;placeholder, ref&#125;) &#123;  return &lt;input placeholder=&#123;placeholder&#125; ref=&#123;ref&#125; /&gt;&#125;//...&lt;MyInput ref=&#123;ref&#125; /&gt;\n\n\n\n新的函数组件将不再需要forwardRef，在未来的版本中，React 将弃用并删除forwardRef\n但是传递给类的 refs 不会作为 props 传递，因为refs引用的是组件实例\n废弃react-test-renderer弃用react-test-renderer。react-test-renderer实现了自己的渲染器环境与用户使用的环境不匹配并依赖于 React 内部的实现细节\n在 React 19 中，react-test-renderer会打印了一个弃用警告，并切换到并发渲染。建议将测试迁移到@testing-library/react或@testing-library/react-native以获得更良好支持的测试体验\n一些值得一提的变动StrictMode 变化React 19 包括了对 Strict Mode 的几个修复和改进。在开发中，当在 Strict Mode 下进行双重渲染时，useMemo和useCallback将重用第一次渲染时的结果进行第二次渲染。已经兼容Strict Mode的组件也不会发生差异。与所有Strict Mode行为一样，这些功能为的是在开发过程中主动暴露组件中的错误，以便在它们被发布到生产环境之前修复。例如在开发过程中，Strict Mode将在初始挂载时双重调用ref回调函数，以模拟当挂载的组件被 Suspense 回退替换时的情况\n移除 UMD 产物UMD 曾经被广泛使用作为一种无需构建步骤即可加载 React 的便捷方式。现在有现代化的替代方案可以将模块作为脚本加载到 HTML 文档中。从 React 19 开始，React 将不再生成 UMD 构建，以减少其测试和发布过程的复杂性。\n为了使用脚本标签加载 React 19，可以使用基于 ESM 的 CDN，例如esm.sh\n&lt;script type=&quot;module&quot;&gt;  import React from &quot;https://esm.sh/react@19/?dev&quot;  import ReactDOMClient from &quot;https://esm.sh/react-dom@19/client?dev&quot;  ...&lt;/script&gt;\n\n依赖于 React 内部的库可能会影响升级此版本包含对 React 内部的更改，可能会影响那些忽略 React 官方警告不要使用像SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED这样的内部机制的库。这些更改是为了实现 React 19 中的一些优化，但不会破坏遵循官方指南使用的库。\n根据版本策略，这些更新不被列为重大更改，并且不包括有关如何升级它们的文档。建议删除依赖于内部机制的任何代码。\n为了反映使用内部机制的影响，已将SECRET_INTERNALS后缀重命名为：\n_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE\n将来将使用更多方式阻止从 React 访问内部，以防止使用并确保用户不会被阻止升级\nTypeScript 变化移除废弃的 TypeScript 类型根据 React 19 中删除的相关 API 清理了相关 TypeScript 类型。同时提供了一个types-react-codemod工具可以帮助迁移已有的类型\nnpx types-react-codemod@latest preset-19 ./path-to-app\n\nref 返回内容必须是清理函数由于引入了ref清理函数，从ref回调返回任何其他内容现在将被 TypeScript 报错。修复方法通常是停止使用隐式返回：\n- &lt;div ref=&#123;current =&gt; (instance = current)&#125; /&gt;+ &lt;div ref=&#123;current =&gt; &#123;instance = current&#125;&#125; /&gt;\n\n原始代码返回HTMLDivElement的实例，TypeScript 无法确定是否清理函数。\nuseRef需要传递参数通过更改类型使得 useRef 现在需要接收一个参数。这显著简化了它的类型签名。现在它的行为更像 createContext\n// @ts-expect-error: Expected 1 argument but saw noneuseRef();// PassesuseRef(undefined);// @ts-expect-error: Expected 1 argument but saw nonecreateContext();// PassescreateContext(undefined);\n\n现在也意味着所有的引用都是可变的。不再会遇到以下的问题，传递 number类型但是使用 null 初始化\n// beforeconst ref = useRef&lt;number&gt;(null);// Cannot assign to &#x27;current&#x27; because it is a read-only propertyref.current = 1;\n\nMutableRef现已弃用，建议使用单个RefObject类型，该类型将始终由useRef返回：\ninterface RefObject&lt;T&gt; &#123;  current: T&#125;declare function useRef&lt;T&gt;: RefObject&lt;T&gt;\n\nuseRef 仍然有一个方便的重载 useRef(null)，它自动返回 RefObject&lt;T | null&gt;。为了简化由于 useRef 所需参数的迁移，添加了一个方便的重载 useRef(undefined)，它自动返回 RefObject&lt;T | undefined&gt;。\nReactElement类型变化如果元素被标记为ReactElement，则ReactElement的props现在默认为unknown而不是any。如果向ReactElement传递类型参数则不会受到影响\ntype Example2 = ReactElement&lt;&#123; id: string &#125;&gt;[&quot;props&quot;];//   ^? &#123; id: string &#125;\n\n但是如果依赖默认设置，则需要处理unknown：\ntype Example = ReactElement[&quot;props&quot;];//   ^? Before, was &#x27;any&#x27;, now &#x27;unknown&#x27;\n\nTypeScript 中的 JSX namespace 变化类型中删除全局JSX命名空间转而使用React.JSX。防止全局类型的污染和不同 UI 库之间利用 JSX 产生冲突\n现在，需要在declare module中的JSX命名空间的模块进行修改\n// global.d.ts+ declare module &quot;react&quot; &#123;    namespace JSX &#123;      interface IntrinsicElements &#123;        &quot;my-element&quot;: &#123;          myElementProps: string;        &#125;;      &#125;    &#125;+ &#125;\n\n准确的模块说明符取决于在tsconfig.json的compilerOptions中指定的 JSX 运行时：\n\n对于&quot;jsx&quot;: &quot;react-jsx&quot;，将是 react/jsx-runtime。\n对于 &quot;jsx&quot;: &quot;react-jsxdev&quot;，将是 react/jsx-dev-runtime。\n对于 &quot;jsx&quot;: &quot;react&quot; 和 &quot;jsx&quot;: &quot;preserve&quot;，它将是 react。\n\n更好的useReducer类型useReducer类型推断得到了改善。然而这需要一个破坏性的变化，其中useReducer不再接受完整的reducer类型作为类型参数，而是需要接收State和Action的类型\n新的最佳实践是不要向 useReducer 传递类型参数。\n- useReducer&lt;React.Reducer&lt;State, Action&gt;&gt;(reducer)+ useReducer(reducer)\n\n这可能在边缘情况下无法正常工作，例如可以通过在元组中传递Action来显式输入状态和操作：\n- useReducer&lt;React.Reducer&lt;State, Action&gt;&gt;(reducer)+ useReducer&lt;State, [Action]&gt;(reducer)\n\n如果内联定义 reducer，建议注释函数参数：\n- useReducer&lt;React.Reducer&lt;State, Action&gt;&gt;((state, action) =&gt; state)+ useReducer((state: State, action: Action) =&gt; state)\n\n这也是如果将 reducer 移动到useReducer调用之外需要做的\nconst reducer = (state: State, action: Action) =&gt; state;\n\n参考React 19 Beta Upgrade Guide\nReact 19 Beta\n\n","categories":["react"],"tags":["react"]},{"title":"React Labs： 我们最近在做什么——2023 年 3 月","url":"/React%20Labs%EF%BC%9A%20%E6%88%91%E4%BB%AC%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%E2%80%94%E2%80%942023%20%E5%B9%B4%203%20%E6%9C%88.html","content":"\n\n\n\n 本文翻译自：https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023\n\nReact Server ComponentsReact Server Components(下文简称 RSC) 是由 React 团队设计的新应用程序架构。\n我们首先在一个介绍性演讲和一个RFC中分享了我们对 RSC 的研究。简要概括一下，我们正在引入一种新型组件——Server Components，它们可以提前运行，并且不包含在你的 JavaScript bundle 中。RSC 可以在构建过程中运行，让你从文件系统中读取或获取静态内容。它们也可以在服务器上运行，让你无需构建 API 即可访问数据层。你可以通过 props 将数据从 Server Components 传递到浏览器中的交互式 Client Components。\nRSC 将服务端中心多页应用程序的简单“请求/响应”心智模型与客户端为中心的单页应用程序的无缝交互结合起来提供最佳体验。\n自上次更新以来，我们已经合并了React Server Components RFC以验证该提议。我们解决了与React Server 模块约定提案有关的未决问题，并与合作伙伴达成共识，采用&quot;use client&quot;约定。这些文档还充当符合 RSC 兼容实现所需支持的规范。\n最大的变化是我们引入了async/await作为从 Server Components 进行数据提取的主要方法。我们还计划通过引入一个名为use的新 hook，从客户端支持数据加载，该 hook 将数据从Promise中取出来。虽然我们无法在客户端应用程序中的任意组件中支持async/await，但是当你将客户端应用程序构建为与 RSC 应用程序类似的结构时，我们计划添加对其的支持\n既然我们已经很好地解决了数据提取问题，我们正在探索另一个方向：从客户端向服务器发送数据，以便可以执行数据库变更和实现表单逻辑。我们通过让你在服务器/客户端之前传递Server Action函数来做到这一点，客户端可以调用这些函数来无缝调用 RPC。Server Action可以在 JavaScript 加载之前提供渐进式增强表单\nReact Server Component 已经内置在[Next.js App Router](Next.js App Router)中。这演示了路由与 RSC 作为基本组件之间深度集成的示例，但这不是构建符合 RSC 兼容路由器和框架的唯一方法。 RSC 规范和实现提供了功能明确分离。 React Server Components 旨在成为可跨兼容 React 框架工作的组件规范。\n通常建议使用现有框架，但如果需要构建自己定制化框架也是可能的。构建符合 RSC 兼容框架并不像我们希望的那样容易，这主要是由于需要进行深度打包集成。目前的打包工具并没有为在服务器和客户端之间拆分单个模块图提供完整的支持。这就是为什么现在我们直接与打包工具开发者合作，以便将 RSC 的基本组件集成进去。\n资源加载Suspense让你可以指定在组件的数据或代码仍在加载时屏幕上显示什么内容。这使得用户可以逐步看到更多内容，而页面正在加载以及在路由器导航期间加载更多数据和代码\n我们正在努力将 Suspense 与样式表、字体和图像的加载生命周期完全整合在一起，以便 React 考虑它们来确定内容是否准备好显示。即使没有更改 React 组件编写方式，在更新方面也会以更一致且令人愉悦的方式。作为优化措施，我们还将提供手动预装像字体这样的资源直接从组件中提取资源。\n我们目前正在实现这些功能，并将很快有更多分享。\nDocument Metadata应用程序中的不同页面和屏幕可能具有不同的元数据，例如 title 标签、描述和其它特定于此屏幕的meta 标签。从维护的角度来看，将此信息保持接近页面或屏幕的 React 组件更加可扩展。但是，这些元数据的 HTML 标签需要在文档 head 中，通常在应用程序根部渲染组件中呈现。\n今天，通常可以使用以下两种技术解决这个问题。\n一种方案是呈现一个特殊的第三方组件，将 title、meta 和其它 tag 移到head标签中。这适用于大部分浏览器，但有很多客户端不会运行客户端 JavaScript（例如 Open Graph 解析器），因此这种技术并不普适\n另一种方案是将页面在服务端渲染分成两步。首先渲染主要内容并收集所有此类标记。然后使用这些tag渲染文档的head。最后将文档head和内容发送到浏览器中。这种方法可行但无法利用 React 18 的 Streaming Server Renderer 的优势，因为必须等待所有内容渲染完成后才能发送文档和head\n因此我们正在添加内置支持，可以在组件树中任何位置直接呈现 title、meta 和 link 标签。在所有环境中，包括完全客户端代码、SSR 和未来的 RSC 中都可以使用相同的方式工作。我们很快将分享更多关于这个功能的细节\nReact Optimizing Compiler自我们上次更新以来，我们一直在积极迭代 React Forget 的设计，这是一个针对 React 的优化编译器。我们以前曾将其称为“自动记忆化编译器”，从某种意义上说这是正确的。但是，构建编译器帮助我们更深入地了解了 React 的编程模型。更好地理解 React Forget 的一种方法是将其视为自动响应式编译器。\nReact 的核心思想是开发人员将用户界面定义为当前状态的函数。可以使用普通 JavaScript 值（数字、字符串、数组、对象）和标准 JavaScript 语法（if/else、for 等）来描述组件逻辑。心智模型是当应用程序状态更改时，React 会重新渲染。我们认为这个简单的心理模型和接近 JavaScript 语义的原则是 React 编程模型中的重要原则。\n问题在于，React 有时过于反应迅速：它可能会重新渲染太多次。例如，在 JavaScript 中，我们没有低成本的方式来比较两个对象或数组是否相等（具有相同的键和值），因此在每次渲染时创建一个新对象或数组可能会导致 React 做出比必要更多的工作 。这意味着开发人员必须明确地记忆组件以避免对更改过度响应。\nReact Forget 的目标是确保 React 应用程序具有恰到好处的响应性：即仅在状态值有意义地更改时重新渲染应用程序。从实现的角度来看，这意味着自动记忆化，但我们认为反应性框架是更好地理解 React 和 Forget 的一种方法。可以将其视为 React 当前重新渲染时更改对象标识时，React Forge 会在语义值改变时重新渲染-但不会产生深层比较的运行时成本。\n在具体进展方面，自我们上次更新以来，我们已经大量迭代了编译器设计以符合这种自动响应的方法，并纳入了内部使用编译器的反馈意见。去年末开始对编译器进行了一些重大重构之后，我们现在开始在 Meta 的有限领域中将编译器用于生产。一旦我们证明它可以用于生产环境中并成功开源后，我们计划开源它。\n最后，很多人对编译器是如何工作感兴趣。当我们证明了该编译器并进行开源后，期待分享更多细节内容。但是现在有一些细节可以分享：\n该编译器的核心几乎完全与 Babel 脱钩，并且核心编译器 API 是（大致上）输入旧 AST 输出新 AST（同时保留源位置数据）。在底层，我们使用自定义代码表示和转换管道来进行低级语义分析。但是，编译器的主要公共接口将通过 Babel 和其他构建系统插件进行。为了便于测试，我们目前有一个 Babel 插件，它是一个非常薄的包装器，它调用编译器生成每个函数的新版本并将其交换。\n过去几个月中，在对编译器进行重构时，我们希望专注于细化核心编译模型以确保能够处理复杂性（例如条件、循环、变量重新赋值和修改等）。但是 JavaScript 有很多表达每个功能的方法：if/else、三元运算符、for、for-in、for-of等。试图支持完整语言会延迟我们验证核心模型的时间节点。相反，我们从语言中选择了一小部分但代表性较强的子集：let/const、if/else 语句、for 循环、对象数组原始值函数调用和其他一些特性。随着我们对核心模型信心增强并改进内部抽象层次结构，在受支持的语言子集中扩展支持范围。关于尚未支持的语法，我们也明确地记录了未经支持的输入的诊断日志并跳过编译。我们拥有工具，可以在 Meta 的代码库上尝试编译器并查看最常见的不受支持特性，以便我们可以优先处理它们。我们将继续逐步扩展以支持整个语言。\n使 React 组件中的普通 JavaScript 具有响应式需要具有深刻语义理解的编译器，使其能够准确理解代码实际在做什么。通过采取这种方法，我们正在创建一个 JavaScript 中用于响应式操作的系统，它可以让你使用语言的全部表现力编写任何复杂度产品代码，而不是仅限于特定领域语言。\nOffscreen RenderingOffscreen rendering 是 React 中即将推出的一种能力，可以在不增加额外性能开销的情况下，在后台渲染屏幕。你可以将其视为content-visibility CSS 属性的一种版本，它不仅适用于 DOM 元素，而且适用于 React 组件。在我们的研究中，我们发现了不同的用例：\n\n路由可以在后台预渲染屏幕，这样当用户导航到它们时就可以立即使用。\n\n标签切换组件可以保留隐藏标签的状态，这样用户就可以在不丢失进度的情况下切换。\n\n虚拟化列表组件可以预先渲染可见窗口上方和下方的额外 padding。\n\n打开弹框或弹出窗口时，应用程序中的其余部分可以进入“后台”模式，以便事件和更新对除模态以外的所有内容都被禁止。\n\n\n大多数 React 开发人员不会直接与 React offscreen APIs 交互。相反，offscreen rendering 将被集成到路由器和 UI 库等组件中，并且使用这些库的开发人员将自动受益而无需进行额外工作。\n关键思想是应该能够在不改变编写组件方式情况下呈现任何 React 树形结构。当组件被离屏渲染时，它不会实际挂载，直到组件变得可见，其效果不会触发。例如，如果组件使用useEffect在首次出现时记录分析数据，则预渲染不会影响这些分析数据的准确性。同样，在组件离开屏幕时，它的效果也将被卸载。offscreen rendering 的一个关键特性是你可以在不丢失其状态的情况下切换组件的可见性。\n自我们上次更新以来，在 Meta 内部我们已经测试了 React Native 应用程序上 Android 和 iOS 版本中预渲染的实验版本，并取得了积极表现。我们还改进了如何将悬挂与离屏呈现结合使用——在离屏树中悬停将不会触发悬挂回退操作。我们剩下的工作是完成暴露给库开发人员的基本元素。我们希望在今年晚些时候发布 RFC 并提供实验 API 进行测试和反馈\nTransition TracingTransition Tracing API 是 React 中的一个 API，可以帮助检测React Transition变慢的原因并进行排查。在我们上次更新后，我们已经完成了 API 的初始设计并发表了RFC。基本功能也已被实现。该项目目前处于暂停状态。我们欢迎对 RFC 提供反馈，并期待恢复其开发以提供更好的 React 性能测量工具。这将特别适用于基于 React Transitions 构建的路由器，例如Next.js App Router。\n\n","categories":["react"],"tags":["react"]},{"title":"React Native性能优化：应该做和不应该做的","url":"/React%20Native%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%9A%E5%BA%94%E8%AF%A5%E5%81%9A%E5%92%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E5%81%9A%E7%9A%84.html","content":"\n\n\n在使用一些框架例如React Native去实际开发移动端应用的时候，性能是一个重要的问题。React Native默认情况下的性能是没有问题的，但是在实际开发React Native的时候，我们也可能会遇到一些性能相关的问题。\n这些问题是很难通过组件本身修复去解决的。在这篇文章中，我们会提供一些建议来优化开发React Native遇到的一些性能问题。\n使用Image缓存解决方案React Native在自带的组件库中提供了Image组件，可以用例展示图片。但是这个组件没有解决以下这些问题的开箱即用的解决方案：\n\n屏幕中渲染大量图片\n一般情况下性能比较低\n从缓存中加载性能比较低\n会有加载闪烁\n\nReact Native中的Image组件处理缓存图片的时候会像web 浏览器一样的行为，会可能导致上面提到的问题。可以通过使用第三方库react-native-fast-image来解决上面的这些问题。这个库在iOS和安卓上都可用并且能够有效的缓存图片\n使用适当大小的图片如果React Native APP依赖于使用大量的图像，那么优化图像对于APP的性能是很重要的。如果图片的尺寸没有得到合适的优化，渲染大量图片会导致在设备上占用大量的内存。这可能会导致APP崩溃\n一些可以在React Native中有效优化图片的方案包括：\n\n使用PNG格式的图片而不是JPG\n使用尺寸更小的图片\n使用WEBP格式的图片。可以在iOS和Android平台减少29%的二进制大小。\n\n避免不必要的渲染React Native是基于React的库并且处理组件渲染的形式类似于React.js。因此在React中可用的优化方法也适用于React Native。一个优化方法就是避免不必要的渲染，在函数组件中可以通过使用React.memo()来完成。\nReact.memo是被用来进行处理记忆化（memoization）。记忆化的理念是：如果一个组件接收相同的props超过一次，它将会使用之前一次缓存的props。并且函数组件只会进行一次渲染返回jsx\n例如下面Parent组件和Child组件的例子。Parent组件有一个count的state变量，每次button点击的时候更新count\n当button点击的时候，即使Child组件的props属性text没有改变，每次Parent组件渲染都会造成Child组件的重新渲染。Child组件没有做任何和Parent组件有关的操作而仅仅是展示一些静态文本。这个行为可以通过把Child组件用React.memo()包着来进行优化\n// Parent.jsconst Parent = () =&gt; &#123;  const [count, setCount] = useState(0);  return (    &lt;View style=&#123;&#123; flex: 1, justifyContent: &#x27;center&#x27;, alignItems: &#x27;center&#x27; &#125;&#125;&gt;      &lt;Button title=&#x27;Press me&#x27; onPress=&#123;() =&gt; setCount(count + 1)&#125; /&gt;      &lt;Child text=&#x27;Placeholder text&#x27; /&gt;    &lt;/View&gt;  );&#125;;// Child.jsconst Child = React.Memo((&#123; text &#125;) =&gt; &#123;  return &lt;Text&gt;&#123;text&#125;&lt;/Text&gt;;&#125;);\n\n\n\nAnimated库中使用nativeDriverReact Native中有很多方法可以写动画，最常用的方法就是使用Animated库\nAnimated\nAnimated会在动画执行之前，通过nativeDriver把动画发送到原生bridge中，这有助于动画独立于被阻塞的JavaScript线程执行，动画会执行比较流畅而不会丢帧\n通过设置useNativeDriver的值为true，可以在Animated库中使用nativeDriver。下面的例子就是在ScrollView组件的onScroll事件中使用useNativeDriver\n&lt;ScrollView  showsVerticalScrollIndicator=&#123;false&#125;  scrollEventThrottle=&#123;1&#125;  onScroll=&#123;Animated.event(    [&#123; nativeEvent: &#123; contentOffset: &#123; y: animatedValue &#125; &#125; &#125;],    &#123; useNativeDriver: true &#125;  )&#125;&gt;  // 组件的内容&lt;/ScrollView&gt;\n\n使用Flipper进行调试React Native 0.62.0版本介绍了一个新的调试工具Flipper。 这是一个给iOS、安卓和React Native使用的平台 。它直接集成在原生代码中，并且在React Native中开箱即用。\n使用Flipper调试app不需要远程调试。需要一个本地连接的Metro实例来与React Native应用进行交互。它可通过React DevTools来检查组件树并检查React组件的state和属性。\n它使用原生插件生态系统来调试iOS和Android应用程序。这些插件可用于设备日志、崩溃报告、检查网络请求、检查应用程序的本地数据库、检查缓存的图像等。\n使用HermesHermes是一个专为移动端应用优化的开源javascript引擎。React Native 0.60.4版本之后，Hermes在安卓也可用了。这有利于减少app的下载体积（安卓APK）、降低内存消耗和降低APP的可交互时间\n在安卓APP中开启Hermes引擎，需要打开build.gradle并且修改如下：\ndef enableHermes = project.ext.react.get(&quot;enableHermes&quot;, true);\n\n自React Native 0.64-rc.0版本后，Hermes也能用于iOS平台。需要打开Podfile并且修改如下：\nuse_react_native!(:path =&gt; config[:reactNativePath], :hermes_enabled =&gt; true\n\n不要在源代码中保留console表达式在Javascript应用包括React Native应用中，用console.log调试是最常用的调试方法之一。然而，在构建React Native应用时，将console语句留在源代码中可能对JavaScript线程造成一些瓶颈。\n一个解决方法就是使用babel-plugin-transform-remove-console删除掉console语句。在终端通过下面的方法安装\nyarn add babel-plugin-transform-remove-console\n\n然后修改 .babelrc文件如下来删除所有的console语句\n&#123;  &quot;env&quot;: &#123;    &quot;production&quot;: &#123;      &quot;plugins&quot;: [&quot;transform-remove-console&quot;]    &#125;  &#125;&#125;\n\n\n\n不要使用Scrollview渲染一个大列表数据有一些方法可以在React Native中使用滚动列表。其中两种最常用的方式就是使用ScrollView和FlatList组件\nScrollView用起来很简单，通常用于使用JavaScript的map()函数遍历一个数组。 例如：\n&lt;ScrollView&gt;  &#123;items.map(item =&gt; &#123;    return &lt;Item key=&#123;item.id.toString()&#125; /&gt;;  &#125;)&#125;&lt;/ScrollView&gt;\n\nScrollView会一次性渲染所有的子组件，在需要渲染的子组件数量不多的时候会比较好用。但在处理大量的数据的时候会影响到APP的性能。\n为了解决渲染大量数据的情况，React Native提供了一个FlatList组件。这个组件能够懒加载子组件列表，这样APP就不会消耗大量的内存\n例如：\n&lt;FlatList  data=&#123;elements&#125;  keyExtractor=&#123;item =&gt; `$&#123;items.id&#125;`&#125;  renderItem=&#123;(&#123; item &#125;) =&gt; &lt;Item key=&#123;item.id.toString()&#125; /&gt;&#125;/&gt;\n\n结论React Native是一个用于构建跨平台应用的开源框架。它以JavaScript为核心，并调用原生组件来构建移动端界面和功能。它会是一个高性能框架只要注意考虑到性能\n","categories":["react"],"tags":["react"]},{"title":"React中的浅比较是如何工作的","url":"/React%E4%B8%AD%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html","content":"\n\n\n浅比较这个概念在React开发过程中很常见。它在不同的过程中扮演着关键的角色，也可以在React组件生命周期的几个地方找到。判断class组件是否应该更新、React hood的依赖数组、通React.memo 缓存处理等例子\n如果曾经阅读过官方的React文档，我们可能会经常到看到浅比较这个概念。但通常只是一个比较简单的解释。所以，本文将研究浅比较的概念，它到底是什么、如何工作，并会得到一些我们可能不知道的结论\n深入浅比较的实现最直接了解浅比较的方式就是去深入它的实现。相应的代码可以在React Github项目的shared包中的shallowEqual.js找到。代码如下\nimport is from &#x27;./objectIs&#x27;;import hasOwnProperty from &#x27;./hasOwnProperty&#x27;;function shallowEqual(objA: mixed, objB: mixed): boolean &#123;  if (is(objA, objB)) &#123;    return true;  &#125;  if (    typeof objA !== &#x27;object&#x27; ||    objA === null ||    typeof objB !== &#x27;object&#x27; ||    objB === null  ) &#123;    return false;  &#125;  const keysA = Object.keys(objA);  const keysB = Object.keys(objB);  if (keysA.length !== keysB.length) &#123;    return false;  &#125;  // Test for A&#x27;s keys different from B.  for (let i = 0; i &lt; keysA.length; i++) &#123;    const currentKey = keysA[i];    if (      !hasOwnProperty.call(objB, currentKey) ||      !is(objA[currentKey], objB[currentKey])    ) &#123;      return false;    &#125;  &#125;  return true;&#125;\n\n\n\n这个函数做了不少事情，我们一步一步看这个函数\nfunction shallowEqual(objA: mixed, objB: mixed): boolean &#123;    // ...&#125;````函数接收两个入参作为被比较的对象。这个代码使用了`Flow`作为类型检测系统而不是使用`TypeScript`。两个函数的参数都使用了`Flow`中的`mixed`类型（类似`TypeScript`中的`unknnown`）。这表明它们可以是任意类型。```typescriptimport is from &#x27;./objectIs&#x27;;function shallowEqual(objA: mixed, objB: mixed): boolean &#123;  if (is(objA, objB)) &#123;    return true;  &#125;    // ...&#125;\n\n首先使用React的内部实现的is方法对两个函数参数进行比较。这个引入的is内部方法和js中的Object.js几乎没有区别。这个比较函数和常用的===基本相同，除了两个例外\n\nObject.is将+0和-0当作不相等，而===把他们当作相等\nObject.is把 Number.NaN和Number.NaN当作相等，而===把他们当作不相等\n\n基本上第一个条件分支能处理如下简单的情况：如果两个参数有相同的值，如原始值相等、或对象的引用相等，它们会被认为相等\nfunction shallowEqual(objA: mixed, objB: mixed): boolean &#123;    // ...  if (    typeof objA !== &#x27;object&#x27; ||    objA === null ||    typeof objB !== &#x27;object&#x27; ||    objB === null  ) &#123;    return false;  &#125;    // ...&#125;\n\n处理了简单情况下的值相等或者对象引用相等后我们需要去比较更复杂的结构。如果其中一个参数是原始值，前面的比较仍然会漏掉这种情况\n为了确保我们下面是比较两个复杂的数据结构，我们还需要检查是否其中一个参数不是对象或者是null。前一个检查确保我们处理的两个参数是对象或数组，而后一个检查是过滤掉null，因为的typeof null === &#39;object&#39;。如果两个条件都成立那么处理的两个参数肯定是不相等的(否则前面的判断就会将它们过滤)，所以浅比较返回false。\nfunction shallowEqual(objA: mixed, objB: mixed): boolean &#123;    // ...  const keysA = Object.keys(objA);  const keysB = Object.keys(objB);  if (keysA.length !== keysB.length) &#123;    return false;  &#125;    // ...&#125;\n\n现在可以确定我们只处理数组和对象。因此可以把重点放在复杂数据结构的比较上\n首先，我们可以简单比较它们的键的数量是否相等。如果不是，他们就不会浅比较相等，这可以提高检查的效率。我们使用Object.keys获取它们的键的数量。对于对象，键数组由实际的键组成；而对于数组，键数组将由数组的索引组成。\nimport hasOwnProperty from &#39;./hasOwnProperty&#39;;\n\nfunction shallowEqual(objA: mixed, objB: mixed): boolean &#123;\n    // ...\n\n  // Test for A&#39;s keys different from B.\n  for (let i = 0; i &lt; keysA.length; i++) &#123;\n    const currentKey = keysA[i];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !is(objA[currentKey], objB[currentKey])\n    ) &#123;\n      return false;\n    &#125;\n  &#125;\n\n  return true;\n&#125;\n\n最后，我们遍历两个函数参数的值并逐个比较它们是否相等。使用上一步中生成的键数组，并使用hasOwnProperty检查键是否实际上是对象自身的属性，使用Object.is函数进行值比较\n如果存在对象上的某个值不相等，那么通过浅比较就可以认为它们不相等。因此可以提前结束循环，并直接shallow wEqual函数返回false。如果所有的值都是相等那么我们可以通过浅比较函数判断两个参数相等，函数返回true\n有趣的东西我们已经了解了简单的比较和它背后的实现，也可以从中知道到一些有趣的东西:\n\n浅比较并不是使用全等===，而是使用Object.is\n\n浅比较中，空对象和空数组会被认为相等\n\n浅比较中，一个以索引值作为键的对象和一个在相应各下标处具有相同值的数组相等。如&#123;0:2,1:3&#125;等于[2,3]\n\n由于使用Object.is而不是使用===。+0和-0在浅比较中是不相等的。并且NaN和NaN也认为不相等。这也适用于复杂结构内部的比较\n\n虽然两个直接创建的对象(或数组)通过浅比较是相等的(&#123;&#125;和[])，但嵌套的数组、对象是不相等的。如&#123;someKey:&#123;&#125;和&#123;someKey:[]&#125;浅比较是不相等的)\n\n\n\n","categories":["react"],"tags":["react"]},{"title":"TypeScript Project References npm 包小实践","url":"/TypeScript%20Project%20References%20npm%20%E5%8C%85%E5%B0%8F%E5%AE%9E%E8%B7%B5.html","content":"\n\n\nnpm 包输出 es/cjs 产物在开发一个 npm 包时，通常需要同时输出 ES 模块和 CommonJS 模块的产物供不同的构建进行使用。在只使用tsc进行产物编译的情况下，我们通常可以通过配置两个独立的 tsconfig.json 配置文件，并在一个 npm script 中 执行两次 tsc 命令来实现\n项目结构假设我们的项目结构如下：\nmy-package/├── src/│   └── index.ts├── dist/│   ├── es/│   └── cjs/├── package.json├── tsconfig.es.json└── tsconfig.cjs.json\n\n配置 TypeScripttsconfig.es.json为 ES 模块创建一个 tsconfig.es.json 文件：\n&#123;    &quot;compilerOptions&quot;: &#123;        &quot;rootDir&quot;: &quot;src&quot;,        &quot;module&quot;: &quot;ESNext&quot;,        &quot;moduleResolution&quot;: &quot;Node&quot;,        &quot;outDir&quot;: &quot;dist/es&quot;    &#125;,    &quot;include&quot;: [&quot;src&quot;]&#125;\n\ntsconfig.cjs.json为 CommonJS 模块创建一个 tsconfig.cjs.json 文件：\n&#123;    &quot;compilerOptions&quot;: &#123;        &quot;rootDir&quot;: &quot;src&quot;,        &quot;module&quot;: &quot;CommonJS&quot;,        &quot;moduleResolution&quot;: &quot;Node&quot;,        &quot;outDir&quot;: &quot;dist/cjs&quot;    &#125;,    &quot;include&quot;: [&quot;src&quot;]&#125;\n\n配置构建脚本在 package.json 中，我们可以添加以下脚本来构建我们的项目，执行两次 tsc 并分别指定不同的配置文件\n&#123;    &quot;scripts&quot;: &#123;        &quot;build&quot;: &quot;tsc -p tsconfig.es.json &amp;&amp; tsc -p tsconfig.cjs.json&quot;,    &#125;&#125;\n\n通过运行 npm run build，可以生成同时包含 ES 模块和 CommonJS 模块的产物\nTypeScript 的 references 是什么TypeScript 的项目引用（Project References）是 TypeScript 3.0 引入的一项功能，允许一个 TypeScript 项目引用另一个 TypeScript 项目。这使得我们可以将大型代码库拆分为多个较小的项目，并且这些项目可以相互依赖\nProject References 的好处\n增量编译：当项目引用被正确配置时，TypeScript 只会重新编译发生变化的部分，从而大幅提升编译速度。\n模块化：通过项目引用，可以将代码库拆分为多个独立的、可复用的模块，提升代码的可维护性和可读性。\n类型安全：项目引用确保了项目之间的类型安全，避免了类型不一致的问题。\n\n配置要使用项目引用，需要在 tsconfig.json 中添加 references 字段。例如：\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;composite&quot;: true,    &quot;declaration&quot;: true,    &quot;outDir&quot;: &quot;./dist&quot;  &#125;,  &quot;include&quot;: [&quot;src&quot;],  &quot;references&quot;: [    &#123; &quot;path&quot;: &quot;../other-project&quot; &#125;  ]&#125;\n\n相应的子项目需要存在相应的tsconfig.json配置，并且配置compilerOptions.composite=true，这样才能被主项目引用。如\n&#123;    &quot;compilerOptions&quot;: &#123;        &quot;composite&quot;: true,        &quot;types&quot;: [],        &quot;rootDir&quot;: &quot;src&quot;,        &quot;module&quot;: &quot;ESNext&quot;,        &quot;moduleResolution&quot;: &quot;Node&quot;,        &quot;outDir&quot;: &quot;dist&quot;    &#125;&#125;\n\n使用 TypeScript 的 references 后如何实现一个命令 tsc 输出 ES 和 CommonJS 产物并且提升增量编译的性能仍以上面的项目结构为例子，我们使用 TypeScript 的项目引用来实现这个需求。\n项目结构假设我们的项目结构如下：\nmy-package/├── src/│   └── index.ts├── dist/│   ├── es/│   └── cjs/├── package.json├── tsconfig.json├── tsconfig.base.json├── tsconfig.es.json└── tsconfig.cjs.json\n\n首先，我们需要在根目录下创建一个 tsconfig.json 文件，用于配置项目引用：\n&#123;  &quot;files&quot;: [],  &quot;references&quot;: [    &#123; &quot;path&quot;: &quot;./tsconfig.es.json&quot; &#125;,    &#123; &quot;path&quot;: &quot;./tsconfig.cjs.json&quot; &#125;  ]&#125;\n\n配置 tsconfig.es.json为 ES 模块创建一个 tsconfig.es.json 文件：\n&#123;    &quot;extends&quot;: &quot;./tsconfig.base.json&quot;,    &quot;compilerOptions&quot;: &#123;      &quot;outDir&quot;: &quot;./dist/es&quot;,      &quot;module&quot;: &quot;ESNext&quot;    &#125;  &#125;\n\n配置 tsconfig.cjs.json为 CommonJS 模块创建一个 tsconfig.cjs.json 文件：\n&#123;    &quot;extends&quot;: &quot;./tsconfig.base.json&quot;,    &quot;compilerOptions&quot;: &#123;      &quot;outDir&quot;: &quot;./dist/cjs&quot;,      &quot;module&quot;: &quot;CommonJS&quot;    &#125;&#125;\n\n公共配置 tsconfig.base.json为了避免重复配置，我们可以创建一个 tsconfig.base.json 文件，包含通用的配置：\n&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;ES5&quot;,    &quot;declaration&quot;: true,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;esModuleInterop&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;composite&quot;: true,    &quot;rootDir&quot;: &quot;src&quot;  &#125;,  &quot;include&quot;: [&quot;src&quot;]&#125;\n\n构建脚本在 package.json 中，我们可以添加以下脚本来构建我们的项目\n&#123;  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;tsc -b&quot;  &#125;&#125;\n\n此时我们不再需要执行两次 tsc 命令，而是只需要执行一次 tsc -b 命令即可输出符合我们需求的 es + cjs 产物（和上面的两次执行 tsc 是一样的效果）。\n在这个场景下 TypeScript 会根据项目引用的配置，自动构建 ES 模块和 CommonJS 模块，并且只会重新编译发生变化的部分，从而提升增量编译的性能\n","categories":["node"],"tags":["node"]},{"title":"babel踩坑记录","url":"/babel%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95.html","content":"\n\n1、如果子模块和外部模块都有.babelrc时，babel处理子模块时，是使用的子模块的babelrc处理的。本质上是文件查找babelrc是从当前文件向上查找的，因为使用到子仓库的原因很容易把这个问题忽略了\n解决方法：外部模块不使用babelrc，而是使用babel.config.js文件代替。如\nmodule.exports = function(api) &#123;  api.cache(true)  const presets = [    [      &#x27;@babel/preset-env&#x27;,      &#123;        modules: false      &#125;    ],    &#x27;@babel/preset-react&#x27;,    &#x27;@babel/preset-typescript&#x27;  ]  const plugins = [&#x27;@babel/plugin-proposal-class-properties&#x27;]  return &#123;    presets,    plugins  &#125;&#125;\n\n2、如果babel使用了@babel/preset-typescript插件，自己写的babel转换插件，需要手动指定babel文件位置\n    const result = babel.transform(source, &#123;      plugins: [        &#123;          visitor: &#123;...          &#125;        &#125;      ],      filename: &#x27;./babel.config.js&#x27;    &#125;)   ...\n不然就会报错Error: [BABEL] unknown: Configuration contains string/RegExp pattern, but no filename was passed to Babel\n","categories":["工程化"],"tags":["工程化"]},{"title":"deno 初体验，实战记录一个node项目迁移到deno需要做什么","url":"/deno%20%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%8C%E5%AE%9E%E6%88%98%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%AAnode%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0deno%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88.html","content":"\n\n\n\n本文以csdnsynchexo迁移到deno实现进行一步步探索说明。\n\n\ncsdnsynchexo是一个爬取 csdn 博客内容生成 hexo 源文件内容的简单工具，正常版本使用 nodejs 实现，。最近 node 之父 ry 大神的 deno 也发布了 1.0，就想实践一下，从 node 版本迁移升级到 deno。本文主要记录一个 nodejs 应用迁移到 deno 需要做哪些工作，还涉及到一些非常基础的 deno 概念。如果你熟悉 nodejs，阅读本文的难度几乎为 0\n\n迁移后项目github地址\n安装deno安装文档\n文档中有很多方式，我们按需选择即可。这里我直接选择mac的脚本安装形式。执行一个脚本然后按照提示设置环境变量即可\ncurl -fsSL https://deno.land/x/install/install.sh | sh# 根据提示设置环境变量# add the directory to your $HOME/.zshrc (or similar)export DENO_INSTALL=&quot;/Users/name/.deno&quot;export PATH=&quot;$DENO_INSTALL/bin:$PATH&quot;\n\n安装deno vscode 插件这个插件的作用如下：\n\n区别于node中的ts， deno中引入文件必须以.ts结尾（有详细后缀），而在node环境下是不需要的，这个插件能解决这个问题，会提示你需要加后缀\n\n\ndeno可以引入远程文件路径，这个插件可以根据路径下载下来的文件，自动推断对应包的类型（依赖了DENO_INSTALL和PATH环境变量）\n\nvscode商店直接搜索安装即可。地址\n我这里遇到了一个问题：安装好这个插件后，vscode还是会出现找不到Deno的报错（issue不少人也遇到了这个问题，如果无问题，则忽略后面），应该是缺少对应 Deno 的声明文件。这里直接用npm i typescript-deno-plugin把deno的声明文件安装下来（或者手动将声明文件拷贝一份）。\n# 还是用了node和npm...npm install --save-dev typescript-deno-plugin typescript\n\n第三方依赖模块的迁移既然deno和node都是执行的 ts/js代码，那么其实只要解决了第三方包和 api 问题，逻辑都一样直接用的，那么本项目的第三方依赖如下，只要解决了这些依赖的问题就可以了\n&#123;    &quot;dependencies&quot;: &#123;        &quot;cheerio&quot;: &quot;^1.0.0-rc.2&quot;,        &quot;commander&quot;: &quot;^2.19.0&quot;,        &quot;filenamify&quot;: &quot;^4.1.0&quot;,        &quot;node-fetch&quot;: &quot;^2.1.2&quot;,        &quot;sitdown&quot;: &quot;^1.1.6&quot;    &#125;&#125;\n\n（deno实现了w3c api标准，已经了内置了fetch，所以我们的node-fetch不再需要了）\n\n模块迁移指南参考\n\n按照官方推荐，Deno项目中建议用一个deps.ts文件来统一管理所有依赖，别的地方直接从deps.ts统一引入，例如本项目的deps.ts如下\nexport &#123; default as cheerio &#125; from &quot;https://dev.jspm.io/cheerio&quot;;export &#123; default as sitdown &#125; from &quot;https://dev.jspm.io/sitdown&quot;;export &#123; default as Command &#125; from &quot;https://deno.land/x/denomander/mod.ts&quot;;export * as fs from &quot;https://deno.land/std/node/fs.ts&quot;;export * as path from &quot;https://deno.land/std/node/path.ts&quot;;export &#123; default as filenamify &#125; from &quot;https://dev.jspm.io/filenamify&quot;;\n\n那么问题来了，这些模块如何找呢。模块迁移指南中也有大概的介绍，这里简单描述下\n1、首先推荐到pika中去寻找这个模块，如果搜出来能直接用，不会报红，表明可以完美在 deno 中使用，直接用pika中的模块链接在deps.ts中引入即可。pika中都自带了.d.ts类型文件，配合deno vscode插件就能实现类型的推断\n例如这里的cheerio就直接在deno中使用\n\n2、如果这个模块在pika中不支持（或者pika抽风..好像很多模块莫名奇妙 404 或者 502），则用https://dev.jspm.io/模块名的地址引入，这些引入一般是没有 ts 声明文件的，可能需要手动引入下对应库的声明文件或者直接添加@ts-ignore忽略掉对应的 ts。（dev.jspm.io中的模块可能用了某些 deno 不支持的 api？..需要判断了）\n// cheerio是通过dev.jspm.io引入的，无类型文件// @ts-ignoreconst $ = cheerio.load(html, &#123;    decodeEntities: true,&#125;);\n\n3、如果 1、2 找不到，则谷歌搜索deno 对应模块名看有没有合适的替代方案了。例如本项目，就是用denomander代替 node 的commander\n由于 deno 自带了typescript支持，我们无需ts-node、tsc等命令即可直接执行ts文件了\nnode 原生 api 的迁移对于node的原生模块，deno提供了对应的兼容包(它们存在于 deno 标准库的node包下)，例如fs、path等。但是兼容是不完全的，例如缺失某些 api（fs里面不提供流式操作）、一些node原生包也没支持。所以能做的就是尽量使用Denoapi 实现，实在不行就用node包下的看看。我这个项目迁移基本满足了需求…\n\ncsdnsynchexo有不少调用fs的文件操作，主要是创建文件、写文件。\nDeno把所有的 api 都放在了Deno这个命名空间下了…Deno使用await实现异步，全局顶层可以直接使用await了\n简单举例..\n// node中判断文件是否存在import fs from &quot;fs&quot;;export const fsExistsSync = (way: string): boolean =&gt; &#123;    try &#123;        fs.accessSync(way, fs.constants.W_OK);    &#125; catch (e) &#123;        return false;    &#125;    return true;&#125;;// 对应的deno api实现export const fsExistsSync = (way: string): boolean =&gt; &#123;    try &#123;        Deno.statSync(way);    &#125; catch (e) &#123;        return false;    &#125;    return true;&#125;;\n\n// 生成文件，写文件操作const writeStream = fs.createWriteStream(    path.join(output, `./$&#123;filenamify(title)&#125;.md`),    &quot;utf8&quot;);writeStream.write(`title: $&#123;title&#125;\\n`);writeStream.close();// denoconst file = Deno.createSync(path.join(output, `./$&#123;filenamify(title)&#125;.md`));const encoder = new TextEncoder();Deno.writeSync(file.rid, encoder.encode(`title: $&#123;title&#125;\\n`));Deno.close(file.rid);\n\npath.join好像没有对应实现，我们直接使用标准库std下的node的path即可\n其实没啥难度…到 deno 文档找一遍有没有类似的 api 即可\n执行程序对于 node，deno 有严格的权限管理，例如如果我们需要网络权限，必须添加--allow-net才能实现网络请求。\n本项目会用到文件读写、网络请求权限，所以我们执行的时候需要deno run --allow-read --allow-net --allow-write ./src/index.ts hsync --config=./config.json执行\n可能你还怀念npm..每次执行一堆参数很爽，我们可以利用Makefile来实现脚本编写\n# makefilerun:\tdeno run --allow-read  --allow-net --allow-write ./src/index.ts hsync --config=./config.jsoncache:\tdeno cache ./src/index.ts\n\n直接根目录下新建makefile文件，这时候我们直接执行make run即可执行我们的程序了..可见，成功搞定\n\n打包deno bundle自带打包和tree shaking功能，可以将我们的代码打包成单文件\ndeno install可以将我们的代码生成可执行文件进行直接使用\n可以建立对应的make脚本\nbundle:\tdeno bundle ./src/index.ts ./hsync.jsinstall:\tdeno install --allow-read  --allow-net --allow-write -n hsync ./src/index.ts\n\nclideno cli 对比node就强大很多了。具备了测试、打包、运行、格式化等于一体\nSUBCOMMANDS:    bundle         Bundle module and dependencies into single file    cache          Cache the dependencies    completions    Generate shell completions    doc            Show documentation for a module    eval           Eval script    fmt            Format source files    help           Prints this message or the help of the given subcommand(s)    info           Show info about cache or info related to source file    install        Install script as an executable    repl           Read Eval Print Loop    run            Run a program given a filename or url to the module    test           Run tests    types          Print runtime TypeScript declarations    upgrade        Upgrade deno executable to given version\n\n经过一系列操作，一个简单的 node 项目就迁移成 deno 项目了，今天经历了从装 deno 到使用 deno。对于 deno 的直观感受如下\n优点\n1、自带 ts 支持，不要再装ts-node、babel等东西\n2、deno命令具备了测试、打包、运行、格式化等于一体，不需按照额外一堆东西\n缺点\n1、第三方库报错信息不好看，因为是一个远程 url，需要点过去，没有本地那么直观\n2、目前生态还不太好\n","categories":["deno"],"tags":["deno"]},{"title":"javascript装饰器进入stage3了","url":"/javascript%E8%A3%85%E9%A5%B0%E5%99%A8%E8%BF%9B%E5%85%A5stage3%E4%BA%86.html","content":"\n\n\n前言\n\n在3月底，js的装饰器提案终于进入了stage3，同时其metadata部分单独拆开仍处于stage2阶段详见。但是此装饰器却非平时我们广泛使用的装饰器。通过本文我们将了解下该js提案下装饰器的用法并对比和先前装饰器提案下用法的区别\ndecorator提案的历史在babel-plugin-proposal-decorators的文档我们可以看到，decorator提案之前主要经历了3个阶段+目前进入stage3阶段移除metadata的版本共4个版本。下文分别简称（legacy、2018-09、2021-12、stage3）\n\n\n\n\n\nlegacy \nstage 1阶段的提案，也是目前广为使用的用法，也基本等同于Typescript中开启experimentalDecorators的用法\n\n2018-09\n在2018.9进入stage2阶段后的提案，此时用法已经完全和stage1不一样\n\n2021-12\n2021.12针对此前的stage2提案又做了一次修改，用法又做了一点小修改\n\nstage3\n最近正式进入stage3的提案。对比2021-12只是去掉了metadata部分，提案本身没有太大的改变。不出意外这也是以后作为标准的装饰器\n\n\n详细用法legacy我们广为使用的用法。即Typescript中tsconfig中配置experimentalDecorators:true\n&#123;\t&quot;compileOptions&quot;: &#123;\t\t&quot;experimentalDecorators&quot;: true\t&#125;&#125;\n\n或者@babel/plugin-proposal-decorators配置\nlegacy: true。注意：最新的@babel/plugin-proposal-decorators已经将该配置迁移到version字段，即version: legacy\nlegacy下的装饰器更具体用法可以参考此前写的一篇文章2020的最后一天，不妨了解下装饰器。\n装饰器函数的签名主要如下\n\n类装饰器 (Class Decorators)类装饰器作用于类的构造函数，可用于修改或者替换一个 class 定义。一个装饰器函数签名如下：\ntype decorator = (target: Function) =&gt; Function | void;\n\n它接收被装饰的 class 作为target函数的参数，如果装饰器函数有返回值，则使用这个返回值作为新的 class\n\n属性装饰器 （Property Decorators）1、第一个参数。如果装饰的是静态方法，则是这个类 Target 本身；如果装饰的是原型方法，则是类的原型对象 Target.prototype\n2、第二个参数。这个属性的名称\ntype decorator = (  target: Target | Target.prototype,  propertyKey: string) =&gt; void;\n方法装饰器 (Method Decorators) + 访问器装饰器 (Accessor Decorators)1、第一个参数。如果装饰的是静态方法，则是这个类Target本身；如果装饰的是原型方法，则是类的原型对象Target.prototype\n2、第二个参数。这个方法的名称\n3、第三个参数，这个方法的属性描述符，通过descriptor.value可以直接拿到这个方法\n如果属性装饰器有返回值，这个返回值讲作为这个方法的属性描述符。对象的属性描述符就是调用Reflect.getOwnPropertyDescriptor(target, propertyKey)的返回值\n\n\ntype decorator = (  target: Target | Target.prototype,  propertyKey: string,  descriptor: PropertyDescriptor) =&gt; Function | void;\n\n\n参数装饰器 (Parameter Decorators)1、第一个参数。如果装饰的是静态方法的参数，则是这个类Target本身；如果装饰的是原型方法的参数，则是类的原型对象Target.prototype\n2、第二个参数。参数所处的函数名称\n3、第三个参数，该参数位于函数参数列表的位置下标(number)\ntype decorator = (target: Target | Target.prototype,propertyKey: string,parameterIndex: number) =&gt; void;\n\nstage3\n本次进入stage3提案的用法\n\n装饰器函数签名如下：\ntype Decorator = (value: Input, context: &#123;  kind: string;  name: string | symbol;  access: &#123;    get?(): unknown;    set?(value: unknown): void;  &#125;;  isPrivate?: boolean;  isStatic?: boolean;  addInitializer?(initializer: () =&gt; void): void;&#125;) =&gt; Output | void;\n\n装饰器函数包含两个入参参数\n1、被装饰的值本身\n2、被装饰值的上下文信息\n\nkind :&quot;class&quot;|&quot;method&quot;|&quot;getter&quot;|&quot;setter&quot;|&quot;field&quot;|&quot;accessor&quot;。表示装饰器的类型\nname 装饰值的名称\naccess 同个该属性读写值\nisStatic 是否静态属性\nisPrivate 是否私有属性\naddInitializer 用于执行一些初始化逻辑\n\n各种不同类型的装饰器如下\n\n方法装饰器\ntype ClassMethodDecorator = (value: Function, context: &#123;  kind: &quot;method&quot;;  name: string | symbol;  access: &#123; get(): unknown &#125;;  isStatic: boolean;  isPrivate: boolean;  addInitializer(initializer: () =&gt; void): void;&#125;) =&gt; Function | void;\n\n方法装饰器接收被装饰的方法作为第一个参数并可选的返回一个函数。返回的函数将替代原先的函数。方法装饰器可作用于静态方法或者原型方法\n\n访问器装饰器\ntype ClassGetterDecorator = (value: Function, context: &#123;  kind: &quot;getter&quot;;  name: string | symbol;  access: &#123; get(): unknown &#125;;  isStatic: boolean;  isPrivate: boolean;  addInitializer(initializer: () =&gt; void): void;&#125;) =&gt; Function | void;type ClassSetterDecorator = (value: Function, context: &#123;  kind: &quot;setter&quot;;  name: string | symbol;  access: &#123; set(value: unknown): void &#125;;  isStatic: boolean;  isPrivate: boolean;  addInitializer(initializer: () =&gt; void): void;&#125;) =&gt; Function | void;\n\n访问器装饰器和方法装饰器类似，接收被装饰器的原始方法，可以返回一个函数替代原始方法\n\n属性装饰器\ntype ClassFieldDecorator = (value: undefined, context: &#123;  kind: &quot;field&quot;;  name: string | symbol;  access: &#123; get(): unknown, set(value: unknown): void &#125;;  isStatic: boolean;  isPrivate: boolean;&#125;) =&gt; (initialValue: unknown) =&gt; unknown | void;\n\n和访问器装饰器、方法装饰器区别，属性装饰器的第一个参数为undefined。属性装饰器可以返回一个初始化函数，返回的初始化函数的入参为原始属性值，返回值为替代原始的属性值\n\n类装饰器\ntype ClassDecorator = (value: Function, context: &#123;  kind: &quot;class&quot;;  name: string | undefined;  addInitializer(initializer: () =&gt; void): void;&#125;) =&gt; Function | void;\n\n类装饰器第一个参数为被装饰的类，可以返回一个新的类去替代原有的类\n\n\n此外stage3对比legacy提案特有的两个用法\n\n类自动访问器（Class Auto-Accessors）类自动访问器是一种新定义的行为。通过在类属性名前加上accessor关键字进行使用\nclass C &#123;  accessor x = 1;&#125;// 与常规字段不同，自动访问器在类原型上定义了 getter 和 setter。getter 和 setter 默认获取和设置私有字段上的值// 等同如下代码class C &#123;  #x = 1;  get x() &#123;    return this.#x;  &#125;  set x(val) &#123;    this.#x = val;  &#125;&#125;\n\n类自动访问器也可以被装饰，装饰器函数签名如下\ntype ClassAutoAccessorDecorator = (  value: &#123;    get: () =&gt; unknown;    set(value: unknown) =&gt; void;  &#125;,  context: &#123;    kind: &quot;accessor&quot;;    name: string | symbol;    access: &#123; get(): unknown, set(value: unknown): void &#125;;    isStatic: boolean;    isPrivate: boolean;    addInitializer(initializer: () =&gt; void): void;  &#125;) =&gt; &#123;  get?: () =&gt; unknown;  set?: (value: unknown) =&gt; void;  initialize?: (initialValue: unknown) =&gt; unknown;&#125; | void;\n\n和普通的属性访问器略有区别，装饰器函数第一个参数的入参是一个包含原型上get/set函数的对象。可以通过返回一个包含get/set函数的对象来取代被装饰值的行为。也可以通过initialize函数修改初始值\n\naddInitializer初始化逻辑函数stage3的装饰器函数中context参数入参会有一个addInitializer函数，它可以接收一个回调，用于执行一些初始化逻辑。一个实际的用法是例如注册web component。\nfunction customElement(name) &#123;  (value, &#123; addInitializer &#125;) =&gt; &#123;    addInitializer(function() &#123;      customElements.define(name, this);    &#125;);  &#125;&#125;@customElement(&#x27;my-element&#x27;)class MyElement extends HTMLElement &#123;  static get observedAttributes() &#123;    return [&#x27;some&#x27;, &#x27;attrs&#x27;];  &#125;&#125;// 等同如下代码class MyElement &#123;  static get observedAttributes() &#123;    return [&#x27;some&#x27;, &#x27;attrs&#x27;];  &#125;&#125;let initializersForMyElement = [];MyElement = customElement(&#x27;my-element&#x27;)(MyElement, &#123;  kind: &quot;class&quot;,  name: &quot;MyElement&quot;,  addInitializer(fn) &#123;    initializersForMyElement.push(fn);  &#125;,&#125;) ?? MyElement;for (let initializer of initializersForMyElement) &#123;  initializer.call(MyElement);&#125;\n\n如果是legacy提案，我们是无法通过装饰器一步到位去注册web component的，必须手动调用customElements.define(name, xxx)\n\n\n2018-09&amp;2021-12由于这两种用法在实际中很少特别使用这里只作简单差异化介绍\n\n2018-09只接收一个descriptor参数，并返回一个新的descriptor参数作为替代。例如方法装饰器接收的descriptor如下\n&#123;  kind: &quot;method&quot;  key: String, Symbol or Private Name,  placement: &quot;static&quot;, &quot;prototype&quot; or &quot;own&quot;,  ...Property Descriptor (argument to Object.defineProperty),  method: The method itself&#125;\n2021-12和stage3几乎完全一样，只是stage3在2021-12的基础上去除了metadata的部分\ntype Decorator = (value: Input, context: &#123;  kind: string;  name: string | symbol;  access: &#123;    get?(): unknown;    set?(value: unknown): void;  &#125;;  isPrivate?: boolean;  isStatic?: boolean;  addInitializer?(initializer: () =&gt; void): void;   // 被移除的getMetadata 和 setMetadataa  getMetadata(key: symbol);  setMetadata(key: symbol, value: unknown); &#125;) =&gt; Output | void;\n\nmetadata本文就不展开介绍，详情可参考\n\n\n总结stage3对比legacy\n\n除了上面提到的语法区别。legacy装饰器是用“Target”（由当前被装饰目标决定是类本身还是类的原型）调用的，而在stage3中，不再提供这个Target给装饰器函数 \nlegacy装饰器会提供一个完整的descriptor对象，而stage3中只提供被装饰的值以及和它有关的上下文对象。在stage3中修改一个属性的attribute是不可能的，并且 getter 和 setter 不是“合并”而是单独被装饰\n\nstage3对比2018-09  \n\n上面提到的语法的区别\n功能上stage3是2018-09的子集\n\n参考tc39/proposal-decorators\n","categories":["原生"],"tags":["原生"]},{"title":"preact hook源码逐行解析","url":"/preact%20hook%E6%BA%90%E7%A0%81%E9%80%90%E8%A1%8C%E8%A7%A3%E6%9E%90.html","content":"\n\n\n\n本文通过对preact的hook源码分析，理解和掌握react/preact的hook用法以及一些常见的问题。虽然react和preact的实现上有一定的差异，但是对于hook的表现来说，是基本一致的。对于 preact的hook`分析，我们很容易旧记住 hook 的使用和防止踩一些误区\n\npreact hook 作为一个单独的包preact/hook引入的，它的总代码包含注释区区 300 行。\n在阅读本文之前，先带着几个问题阅读：\n1、函数组件是无状态的，那么为什么 hook 让它变成了有状态呢？\n2、为什么 hook 不能放在 条件语句里面\n3、为什么不能在普通函数执行 hook\n基础前面提到，hook在preact中是通过preact/hook内一个模块单独引入的。这个模块中有两个重要的模块内的全局变量：1、currentIndex：用于记录当前函数组件正在使用的 hook 的顺序（下面会提到）。2、currentComponent。用于记录当前渲染对应的组件。\npreact hook 的实现对于原有的 preact 是几乎零入侵。它通过暴露在preact.options中的几个钩子函数在preact的相应初始/更新时候执行相应的hook逻辑。这几个钩子分别是_render=&gt; 组件的render方法=&gt;diffed=&gt;_commit=&gt;umount\n\n\\_render位置。执行组件的 render 方法之前执行，用于执行_pendingEffects（_pendingEffects是不阻塞页面渲染的 effect 操作，在下一帧绘制前执行）的清理操作和执行未执行的。这个钩子还有一个很重要的作用就是让 hook 拿到当前正在执行的render的组件实例options\n\noptions._render = vnode =&gt; &#123;  // render 钩子函数  if (oldBeforeRender) oldBeforeRender(vnode);  currentComponent = vnode._component;  currentIndex = 0;  if (currentComponent.__hooks) &#123;    // 执行清理操作    currentComponent.__hooks._pendingEffects.forEach(invokeCleanup);    // 执行effect    currentComponent.__hooks._pendingEffects.forEach(invokeEffect);    currentComponent.__hooks._pendingEffects = [];  &#125;&#125;;\n\n结合_render在 preact 的执行时机，可以知道，在这个钩子函数里是进行每次 render 的初始化操作。包括执行/清理上次未处理完的 effect、初始化 hook 下标为 0、取得当前 render 的组件实例。\n\ndiffed位置。 vnode 的 diff 完成之后，将当前的_pendingEffects推进执行队列，让它在下一帧绘制前执行，不阻塞本次的浏览器渲染。\n\noptions.diffed = vnode =&gt; &#123;  if (oldAfterDiff) oldAfterDiff(vnode);  const c = vnode._component;  if (!c) return;  const hooks = c.__hooks;  if (hooks) &#123;    // 下面会提到useEffect就是进入_pendingEffects队列    if (hooks._pendingEffects.length) &#123;      // afterPaint 表示本次帧绘制完，下一帧开始前执行      afterPaint(afterPaintEffects.push(c));    &#125;  &#125;&#125;;\n\n\n\\_commit位置。初始或者更新 render 结束之后执行_renderCallbacks，在这个\\_commit中只执行 hook 的回调，如useLayoutEffect。（_renderCallbacks是指在preact中指每次 render 后，同步执行的操作回调列表，例如setState的第二个参数 cb、或者一些render后的生命周期函数、或者forceUpdate的回调）。\n\noptions._commit = (vnode, commitQueue) =&gt; &#123;  if (options._commit) options._commit(root, commitQueue);  commitQueue.some(component =&gt; &#123;    // 执行上次的_renderCallbacks的清理函数    component._renderCallbacks.forEach(invokeCleanup);    // _renderCallbacks有可能是setState的第二个参数这种的、或者生命周期、或者forceUpdate的回调。    // 通过_value判断是hook的回调则在此出执行    component._renderCallbacks = component._renderCallbacks.filter(cb =&gt;      cb._value ? invokeEffect(cb) : true    );  &#125;);  if (oldCommit) oldCommit(vnode, commitQueue);&#125;;\n\n\nunmount。 组件的卸载之后执行effect的清理操作\n\noptions.unmount = vnode =&gt; &#123;  if (oldBeforeUnmount) oldBeforeUnmount(vnode);  const c = vnode._component;  if (!c) return;  const hooks = c.__hooks;  if (hooks) &#123;    // _cleanup 是effect类hook的清理函数，也就是我们每个effect的callback 的返回值函数    hooks._list.forEach(hook =&gt; hook._cleanup &amp;&amp; hook._cleanup());  &#125;&#125;;\n\n对于组件来说加入的 hook 只是在 preact 的组件基础上增加一个__hook 属性。在 preact 的内部实现中，无论是函数组件还是 class 组件， 都是实例化成 PreactComponent，如下数据结构\nexport interface Component extends PreactComponent&lt;any, any&gt; &#123;  __hooks?: &#123;    // 每个组件的hook存储    _list: HookState[];    // useLayoutEffect useEffect 等    _pendingEffects: EffectHookState[];  &#125;;&#125;\n\n对于问题 1 的回答，通过上面的分析，我们知道，hook最终是挂在组件的__hooks属性上的，因此，每次渲染的时候只要去读取函数组件本身的属性就能获取上次渲染的状态了，就能实现了函数组件的状态。这里关键在于getHookState这个函数。这个函数也是整个preact hook中非常重要的\nfunction getHookState(index) &#123;  if (options._hook) options._hook(currentComponent);  const hooks =    currentComponent.__hooks ||    (currentComponent.__hooks = &#123; _list: [], _pendingEffects: [] &#125;);  // 初始化的时候，创建一个空的hook  if (index &gt;= hooks._list.length) &#123;    hooks._list.push(&#123;&#125;);  &#125;  return hooks._list[index];&#125;\n\n这个函数是在组件每次执行useXxx的时候，首先执行这一步获取 hook 的状态的（以useEffect为例子）。所有的hook都是使用这个函数先获取自身 hook 状态\nexport function useEffect(callback, args) &#123;  //....  const state = getHookState(currentIndex++);  //.....&#125;\n\n这个currentIndex在每一次的render过程中是从 0 开始的，每执行一次useXxx后加一。每个hook在多次render中对于记录前一次的执行状态正是通过currentComponent.__hooks中的顺序决定。所以如果处于条件语句，如果某一次条件不成立，导致那个useXxx没有执行，这个后面的 hook 的顺序就发生错乱并导致 bug。\n例如\nconst Component = () =&gt; &#123;  const [state1, setState1] = useState();  // 假设condition第一次渲染为true，第二次渲染为false  if (condition) &#123;    const [state2, setState2] = useState();  &#125;  const [state3, setState3] = useState();&#125;;\n\n第一次渲染后，__hooks = [hook1,hook2,hook3]。第二次渲染，由于const [state2, setState2] = useState();被跳过，通过currentIndex取到的const [state3, setState3] = useState();其实是hook2。就可能有问题。所以，这就是问题 2，为什么 hook 不能放到条件语句中。\n经过上面一些分析，也知道问题 3 为什么 hook 不能用在普通函数了。因为 hook 都依赖了 hook 内的全局变量currentIndex和currentComponent。而普通函数并不会执行options.render钩子重置currentIndex和设置currentComponent，当普通函数执行 hook 的时候，currentIndex为上一个执行 hook 组件的实例的下标，currentComponent为上一个执行 hook 组件的实例。因此直接就有问题了。\nhook 分析虽然 preact 中的 hook 有很多，数据结构来说只有 3 种HookState结构，所有的 hook 都是在这 3 种的基础上实现的。这 3 种分别是\n\nEffectHookState (useLayoutEffect useEffect useImperativeHandle)\n\nexport interface EffectHookState &#123;  // effect hook的回调函数  _value?: Effect;  // 依赖项  _args?: any[];  // effect hook的清理函数，_value的返回值  _cleanup?: Cleanup;&#125;\n\n\nMemoHookState （**useMemo** useRef useCallback）\n\nexport interface MemoHookState &#123;  // useMemo的返回值  _value?: any;  // 前一次的依赖数组  _args?: any[];  //useMemo传入的callback  _callback?: () =&gt; any;&#125;\n\n\nReducerHookState (useReducer useState ``)\n\nexport interface ReducerHookState &#123;  _value?: any;  _component?: Component;&#125;\n\n\nuseContext 这个比较特殊\n\nMemoHookStateMemoHook是一类用来和性能优化有关的 hook\nuseMemo作用：把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算\n// 例子const Component = props =&gt; &#123;  // 假设calculate是个消耗很多的计算操作  const result = calculate(props.xx);  return &lt;div&gt;&#123;result&#125;&lt;/div&gt;;&#125;;\n\n默认情况下，每次Component渲染都会执行calculate的计算操作，如果calculate是一个大计算量的函数，这里会有造成性能下降，这里就可以使用useMemo来进行优化了。这样如果calculate依赖的值没有变化，就不需要执行这个函数，而是取它的缓存值。要注意的是calculate对外部依赖的值都需要传进依赖项数组，否则当部分值变化是，useMemo却还是旧的值可能会产生 bug。\n// 例子const Component = props =&gt; &#123;  // 这样子，只会在props.xx值改变时才重新执行calculate函数，达到了优化的目的  const result = useMemo(() =&gt; calculate(props.xx), [props.xx]);  return &lt;div&gt;&#123;result&#125;&lt;/div&gt;;&#125;;\n\nuseMemo源码分析\nfunction useMemo(callback, args) &#123;  // state是MemoHookState类型  const state = getHookState(currentIndex++);  // 判断依赖项是否改变  if (argsChanged(state._args, args)) &#123;    // 存储本次依赖的数据值    state._args = args;    state._callback = callback;    // 改变后执行`callback`函数返回值。    return (state._value = callback());  &#125;  return state._value;&#125;\n\nuseMemo的实现逻辑不复杂，判断依赖项是否改变，改变后执行callback函数返回值。值得一提的是，依赖项比较只是普通的===比较，如果依赖的是引用类型，并且直接改变改引用类型上的属性，将不会执行callback。\nuseCallback作用：接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memorized 版本，该回调函数仅在某个依赖项改变时才会更新\n假设有这样一段代码\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  const handle = () =&gt; console.log(number);  return &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;;&#125;;\n\n对于每次的渲染，都是新的 handle，因此 diff 都会失效，都会有一个创建一个新的函数，并且绑定新的事件代理的过程。当使用useCallback后则会解决这个问题\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  // 这里，如果number不变的情况下，每次的handle是同一个值  const handle = useCallback(() =&gt; () =&gt; console.log(number), [number]);  return &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;;&#125;;\n\n有一个坑点是，[number]是不能省略的，如果省略的话，每次打印的log永远是number的初始值 0\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  // 这里永远打印0  const handle = useCallback(() =&gt; () =&gt; console.log(number), []);  return &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;;&#125;;\n\n至于为什么这样，结合useMomo的实现分析。useCallback是在useMemo的基础上实现的，只是它不执行这个 callback，而是返回这个 callback，用于执行。\nfunction useCallback(callback, args) &#123;  // 直接返回这个callback，而不是执行  return useMemo(() =&gt; callback, args);&#125;\n\n我们想象一下，每次的函数组件执行，都是一个全新的过程。而我们的 callback 只是挂在MemoHook的_value字段上，当依赖没有改变的时候，我们执行的callback永远是创建的那个时刻那次渲染的形成的闭包函数。而那个时刻的number就是初次的渲染值。\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  // 这里永远打印0  const handle = useCallback(    () =&gt; /** 到了后面的时候，我们的handle并不是执行这次的callback，而是上次的那个记录的callback*/ () =&gt;      console.log(number),    []  );  return &lt;button onClick=&#123;handle&#125;&gt;按钮&lt;/button&gt;;&#125;;\n\nuseMemo和useCallback对于性能优化很好用，但是并不是必须的。因为对于大多数的函数来说，一方面创建/调用消耗并不大，而记录依赖项是需要一个遍历数组的对比操作，这个也是需要消耗的。因此并不需要无脑useMemo和useCallback，而是在一些刚好的地方使用才行\nuseRef作用：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数（initialValue）。就是在函数组件中替代React.createRef的功能或者类似于this.xxx的功能。在整个周期中，ref 值是不变的\n用法一：\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  const inputRef = useRef(null)  const focus = useCallback(    () =&gt;inputRef.focus(),    []  );  return&lt;div&gt;  &lt;input ref=&#123;inputRef&#125;&gt;   &lt;button onClick=&#123;focus&#125;&gt;按钮&lt;/button&gt;  &lt;/div&gt;;&#125;;\n\n用法二：类似于this\n// 例子const Component = props =&gt; &#123;  const [number, setNumber] = useState(0);  const inputRef = useRef(null)  const focus = useCallback(    () =&gt;inputRef.current.focus(),    []  );  return&lt;div&gt;  &lt;input ref=&#123;node =&gt; inputRef.current = node&#125;&gt;   &lt;button onClick=&#123;focus&#125;&gt;按钮&lt;/button&gt;  &lt;/div&gt;;&#125;;\n\n之所以能这么用，在diff过程中于applyRef这个函数，react也是类似。（diff中，通过applyRef将dom对象挂到对应的ref上）\nexport function applyRef(ref, value, vnode) &#123;  try &#123;    if (typeof ref == &quot;function&quot;) ref(value);    else ref.current = value;  &#125; catch (e) &#123;    options._catchError(e, vnode);  &#125;&#125;\n\n查看useRef的源码。\nfunction useRef(initialValue) &#123;  return useMemo(() =&gt; (&#123; current: initialValue &#125;), []);&#125;\n\n可见 就是初始化的时候创建一个&#123;current:initialValue&#125;，不依赖任何数据，需要手动赋值修改\nReducerHookStateuseReduceruseReducer和使用redux非常像。\n用法：\n// reducer就是平时redux那种reducer函数// initialState 初始化的state状态// init 一个函数用于惰性计算state初始值const [state, dispatch] = useReducer(reducer, initialState, init);\n\n计数器的例子。\nconst initialState = 0;function reducer(state, action) &#123;  switch (action.type) &#123;    case &quot;increment&quot;:      return &#123; number: state.number + 1 &#125;;    case &quot;decrement&quot;:      return &#123; number: state.number - 1 &#125;;    default:      return state;  &#125;&#125;function init(initialState) &#123;  return &#123; number: initialState &#125;;&#125;function Counter() &#123;  const [state, dispatch] = useReducer(reducer, initialState, init);  return (    &lt;div&gt;      &#123;state.number&#125;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n对于熟悉redux的同学来说，一眼明了。后面提到的useState旧是基于useReducer实现的。\n源码分析\nexport function useReducer(reducer, initialState, init) &#123;  const hookState = getHookState(currentIndex++);  // 前面分析过ReducerHookState的数据结构，有两个属性  // _value 当前的state值  // _component 对应的组件实例  if (!hookState._component) &#123;    // 初始化过程    // 因为后面需要用到setState更新，所以需要记录component的引用    hookState._component = currentComponent;    hookState._value = [      // init是前面提到的惰性初始化函数，传入了init则初始值是init的计算结果      // 没传init的时候是invokeOrReturn。这里就是直接返回初始化值      /***       *        * ```js       * invokeOrReturn 很精髓       * 参数f为函数，返回 f(arg)       * 参数f非函数，返回f       * function invokeOrReturn(arg, f) &#123;            return typeof f === &quot;function&quot; ? f(arg) : f;          &#125;       * ```      */      !init ? invokeOrReturn(undefined, initialState) : init(initialState),      action =&gt; &#123;        // reducer函数计算出下次的state的值        const nextValue = reducer(hookState._value[0], action);        if (hookState._value[0] !== nextValue) &#123;          hookState._value[0] = nextValue;          // setState开始进行下一轮更新          hookState._component.setState(&#123;&#125;);        &#125;      &#125;    ];  &#125;  // 返回当前的state  return hookState._value;&#125;\n\n更新state就是调用 demo 的dispatch，也就是通过reducer(preState,action)计算出下次的state赋值给_value。然后调用组件的setState方法进行组件的diff和相应更新操作(这里是preact和react不太一样的一个地方，preact 的函数组件在内部和 class 组件一样使用 component 实现的)。\nuseStateuseState大概是 hook 中最常用的了。类似于 class 组件中的 state 状态值。\n用法\nconst Component = () =&gt; &#123;  const [number, setNumber] = useState(0);  const [index, setIndex] = useIndex(0);  return (    &lt;div&gt;      &#123;/* setXxx可以传入回调或者直接设置值**/&#125;      &lt;button onClick=&#123;() =&gt; setNumber(number =&gt; number + 1)&#125;&gt;        更新number      &lt;/button&gt;      &#123;number&#125;      //      &lt;button onClick=&#123;() =&gt; setIndex(index + 1)&#125;&gt;更新index&lt;/button&gt;      &#123;index&#125;    &lt;/div&gt;  );&#125;;\n\n上文已经提到过，useState是通过useReducer实现的。\nexport function useState(initialState) &#123;  /***       *        * ```js       * function invokeOrReturn(arg, f) &#123;            return typeof f === &quot;function&quot; ? f(arg) : f;          &#125;       * ```      */  return useReducer(invokeOrReturn, initialState);&#125;\n\n只要我们给useReduecr的reducer参数传invokeOrReturn函数即可实现useState。回顾下useState和useReducer的用法\nconst [index, setIndex] = useIndex(0);setIndex(index =&gt; index + 1);// orsetIndex(1);//-----const [state, dispatch] = useReducer(reducer, initialState);dispatch(&#123; type: &quot;some type&quot; &#125;);\n\n1、对于setState直接传值的情况。reducer（invokeOrReturn）函数，直接返回入参即可\n// action非函数，reducer(hookState._value[0], action)结果为actionconst nextValue = reducer(hookState._value[0], action);\n\n2、对于setState直接参数的情况的情况。\n// action为函数，reducer(hookState._value[0], action)结果为action(hookState._value[0])const nextValue = reducer(hookState._value[0], action);\n\n可见，useState其实只是传特定reducer的useReducer一种实现。\nEffectHookState\nuseEffect 和 useLayoutEffect\n\n这两个 hook 的用法完全一致，都是在 render 过程中执行一些副作用的操作，可来实现以往 class 组件中一些生命周期的操作。区别在于，useEffect 的 callback 执行是在本次渲染结束之后，下次渲染之前执行。 useLayoutEffect则是在本次会在浏览器 layout 之后，painting 之前执行，是同步的。\n\n用法。传递一个回调函数和一个依赖数组，数组的依赖参数变化时，重新执行回调。\n/** * 接收一个包含一些必要副作用代码的函数，这个函数需要从DOM中读取layout和同步re-render *  `useLayoutEffect` 里面的操作将在DOM变化之后，浏览器绘制之前 执行 * 尽量使用`useEffect`避免阻塞视图更新 * * @param effect Imperative function that can return a cleanup function * @param inputs If present, effect will only activate if the values in the list change (using ===). */export function useLayoutEffect(effect: EffectCallback, inputs?: Inputs): void;/** * 接收一个包含一些必要副作用代码的函数。 * 副作用函数会在浏览器绘制后执行，不会阻塞渲染 * * @param effect Imperative function that can return a cleanup function * @param inputs If present, effect will only activate if the values in the list change (using ===). */export function useEffect(effect: EffectCallback, inputs?: Inputs): void;\n\ndemo\nfunction LayoutEffect() &#123;  const [color, setColor] = useState(&quot;red&quot;);  useLayoutEffect(() =&gt; &#123;    alert(color);  &#125;, [color]);  useEffect(() =&gt; &#123;    alert(color);  &#125;, [color]);  return (    &lt;&gt;      &lt;div id=&quot;myDiv&quot; style=&#123;&#123; background: color &#125;&#125;&gt;        颜色      &lt;/div&gt;      &lt;button onClick=&#123;() =&gt; setColor(&quot;red&quot;)&#125;&gt;红&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setColor(&quot;yellow&quot;)&#125;&gt;黄&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; setColor(&quot;blue&quot;)&#125;&gt;蓝&lt;/button&gt;    &lt;/&gt;  );&#125;\n\n从 demo 可以看出，每次改变颜色，useLayoutEffect的回调触发时机是在页面改变颜色之前，而useEffect的回调触发时机是页面改变颜色之后。它们的实现如下\nexport function useLayoutEffect(callback, args) &#123;  const state = getHookState(currentIndex++);  if (argsChanged(state._args, args)) &#123;    state._value = callback;    state._args = args;    currentComponent._renderCallbacks.push(state);  &#125;&#125;export function useEffect(callback, args) &#123;  const state = getHookState(currentIndex++);  if (argsChanged(state._args, args)) &#123;    state._value = callback;    state._args = args;    currentComponent.__hooks._pendingEffects.push(state);  &#125;&#125;\n\n它们的实现几乎一模一样，唯一的区别是useLayoutEffect的回调进的是_renderCallbacks数组，而useEffect的回调进的是_pendingEffects。\n前面已经做过一些分析，_renderCallbacks是在\\_commit钩子中执行的，在这里执行上次renderCallbacks的effect的清理函数和执行本次的renderCallbacks。\\_commit则是在preact的commitRoot中被调用，即每次 render 后同步调用（顾名思义 renderCallback 就是 render 后的回调，此时 DOM 已经更新完，浏览器还没有 paint 新一帧，上图所示的 layout 后 paint 前）因此 demo 中我们在这里alert会阻塞浏览器的 paint，这个时候看不到颜色的变化。\n而_pendingEffects则是本次重绘之后，下次重绘之前执行。在 hook 中的调用关系如下\n1、 options.differed 钩子中（即组件 diff 完成后），执行afterPaint(afterPaintEffects.push(c))将含有_pendingEffects的组件推进全局的afterPaintEffects队列\n2、afterPaint中执行执行afterNextFrame(flushAfterPaintEffects)。在下一帧 重绘之前，执行flushAfterPaintEffects。同时，如果 100ms 内，当前帧的 requestAnimationFrame 没有结束(例如窗口不可见的情况)，则直接执行flushAfterPaintEffects。flushAfterPaintEffects函数执行队列内所有组件的上一次的_pendingEffects的清理函数和执行本次的_pendingEffects。\n几个关键函数\n/** * 绘制之后执行回调 * 执行队列内所有组件的上一次的`_pendingEffects`的清理函数和执行本次的`_pendingEffects`。 */function flushAfterPaintEffects() &#123;  afterPaintEffects.some(component =&gt; &#123;    if (component._parentDom) &#123;      // 清理上一次的_pendingEffects      component.__hooks._pendingEffects.forEach(invokeCleanup);      // 执行当前_pendingEffects      component.__hooks._pendingEffects.forEach(invokeEffect);      component.__hooks._pendingEffects = [];    &#125;  &#125;);  // 清空afterPaintEffects  afterPaintEffects = [];&#125;/** *preact的diff是同步的，是宏任务。   newQueueLength === 1 保证了afterPaint内的afterNextFrame(flushAfterPaintEffects)只执行一遍。因为会调用n次宏任务的afterPaint结束后，才会执行flushAfterPaintEffects一次将所有含有pendingEffect的组件进行回调进行* */afterPaint = newQueueLength =&gt; &#123;  if (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) &#123;    prevRaf = options.requestAnimationFrame;    // 执行下一帧结束后，清空 useEffect的回调    (prevRaf || afterNextFrame)(flushAfterPaintEffects);  &#125;&#125;;/** * 希望在下一帧 重绘之前，执行callback。同时，如果100ms内，当前帧的requestAnimationFrame没有结束(例如窗口不可见的情况)，则直接执行callback */function afterNextFrame(callback) &#123;  const done = () =&gt; &#123;    clearTimeout(timeout);    cancelAnimationFrame(raf);    setTimeout(callback);  &#125;;  const timeout = setTimeout(done, RAF_TIMEOUT);  const raf = requestAnimationFrame(done);&#125;\n\nuseImperativeHandleuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起\n// React文档的例子function FancyInput(props, ref) &#123;  const inputRef = useRef();  // 第一个参数是 父组件 ref  // 第二个参数是返回，返回的对象会作为父组件 ref current 属性的值  useImperativeHandle(ref, () =&gt; (&#123;    focus: () =&gt; &#123;      inputRef.current.focus();    &#125;  &#125;));  return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;FancyInput = forwardRef(FancyInput);function App()&#123;  const ref = useRef()  return &lt;div&gt;  &lt;FancyInput ref=&#123;ref&#125;/&gt;  &lt;button onClick=&#123;()=&gt;ref.focus()&#125;&gt;click&lt;/button&gt;  &lt;/div&gt;&#125;\n\n默认情况下，函数组件是没有ref属性，通过forwardRef(FancyInput)后，父组件就可以往子函数组件传递ref属性了。useImperativeHandle的作用就是控制父组件不能在拿到子组件的ref后为所欲为。如上，父组件拿到FancyInput后，只能执行focus，即子组件决定对外暴露的 ref 接口，class组件是无法做到的。\nfunction useImperativeHandle(ref, createHandle, args) &#123;  useLayoutEffect(    () =&gt; &#123;      if (typeof ref === &quot;function&quot;) ref(createHandle());      else if (ref) ref.current = createHandle();    &#125;,    args == null ? args : args.concat(ref)  );&#125;\n\nuseImperativeHandle的实现也是一目了然，因为这种是涉及到 dom 更新后的同步修改，所以是用useLayoutEffect实现的。从实现可看出，useImperativeHandle也能接收依赖项数组的\ncreateContext接收一个 context 对象（Preact.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。当组件上层最近的&lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。\n使用 context 最大的好处就是避免了深层组件嵌套时，需要一层层往下通过 props 传值。使用 createContext 可以非常方便的使用 context 而不用再写繁琐的Consumer\nreact context\nconst context = Preact.createContext(null);const Component = () =&gt; &#123;  // 每当Context.Provider value=&#123;&#123;xx:xx&#125;&#125;变化时，Component都会重新渲染  const &#123; xx &#125; = useContext(context);  return &lt;div&gt;&lt;/div&gt;;&#125;;const App = () =&gt; &#123;  return (    &lt;Context.Provider value=&#123;&#123; xx: xx &#125;&#125;&gt;      &lt;Component&gt;&lt;/Component&gt;    &lt;/Context.Provider&gt;  );&#125;;\n\nuseContext实现\nfunction useContext(context) &#123;  // 每个`preact`组件的context属性都保存着当前全局context的Provider引用，不同的context都有一个唯一id  // 获取当前组件 所属的Context Provider  const provider = currentComponent.context[context._id];  if (!provider) return context._defaultValue;  const state = getHookState(currentIndex++);  if (state._value == null) &#123;    // 初始化的时候将当前 组件订阅 Provider的value变化    // 当Provider的value变化时，重新渲染当前组件    state._value = true;    provider.sub(currentComponent);  &#125;  return provider.props.value;&#125;\n\n可以看出，useContext会在初始化的时候，当前组件对应的Context.Provider会把该组件加入订阅回调(provider.sub(currentComponent))，当 Provider value 变化时，在 Provider 的shouldComponentUpdate周期中执行组件的 render。\n//.....// Provider部分源码    Provider(props) &#123;      //....      // 初始化Provider的时候执行的部分        this.shouldComponentUpdate = _props =&gt; &#123;          if (props.value !== _props.value) &#123;            subs.some(c =&gt; &#123;              c.context = _props.value;              // 执行sub订阅回调组件的render              enqueueRender(c);            &#125;);          &#125;        &#125;;        this.sub = c =&gt; &#123;          subs.push(c);          let old = c.componentWillUnmount;          c.componentWillUnmount = () =&gt; &#123;            // 组件卸载的时候，从订阅回调组件列表中移除            subs.splice(subs.indexOf(c), 1);            old &amp;&amp; old.call(c);          &#125;;        &#125;;      &#125; //....\n\n总结： preact和react在源码实现上有一定差异，但是通过对 preact hook 源码的学习，对于理解 hook 的很多观念和思想是非常有帮助的。\n\n最后附上带了注释的 hook 源码\nimport &#123; options &#125; from &quot;preact&quot;;/\\*_ @type &#123;number&#125; _/let currentIndex;/\\*_ @type &#123;import(&#x27;./internal&#x27;).Component&#125; _/let currentComponent;/\\*_ @type &#123;Array&lt;import(&#x27;./internal&#x27;).Component&gt;&#125; _/let afterPaintEffects = [];let oldBeforeRender = options.\\_render;options.\\_render = vnode =&gt; &#123;// render 钩子函数if (oldBeforeRender) oldBeforeRender(vnode);currentComponent = vnode.\\_component;currentIndex = 0;if (currentComponent.**hooks) &#123;// 执行清理操作currentComponent.**hooks.\\_pendingEffects.forEach(invokeCleanup);// 执行 effectcurrentComponent.**hooks.\\_pendingEffects.forEach(invokeEffect);currentComponent.**hooks.\\_pendingEffects = [];&#125;&#125;;// \\_pendingEffects paint 后调用// \\_renderCallbacks render 后同步调用// render（执行 render 方法之前） -&gt; diffed（diff 结束） -&gt; \\_commit(初始或者更新生命周期结束之后) -&gt; unmount（卸载）let oldAfterDiff = options.diffed;options.diffed = vnode =&gt; &#123;if (oldAfterDiff) oldAfterDiff(vnode);const c = vnode.\\_component;if (!c) return;const hooks = c.\\_\\_hooks;if (hooks) &#123;if (hooks.\\_pendingEffects.length) &#123;afterPaint(afterPaintEffects.push(c));&#125;&#125;&#125;;let oldCommit = options.\\_commit;options.\\_commit = (vnode, commitQueue) =&gt; &#123;commitQueue.some(component =&gt; &#123;component.\\_renderCallbacks.forEach(invokeCleanup);// \\_renderCallbacks 有可能是 setState 的第二个参数这种的、或者生命周期、或者 forceUpdate 的回调。// 通过\\_value 判断是 hook 的回调component.\\_renderCallbacks = component.\\_renderCallbacks.filter(cb =&gt;cb.\\_value ? invokeEffect(cb) : true);&#125;);if (oldCommit) oldCommit(vnode, commitQueue);&#125;;let oldBeforeUnmount = options.unmount;options.unmount = vnode =&gt; &#123;if (oldBeforeUnmount) oldBeforeUnmount(vnode);const c = vnode.\\_component;if (!c) return;const hooks = c.\\_\\_hooks;if (hooks) &#123;hooks.\\_list.forEach(hook =&gt; hook.\\_cleanup &amp;&amp; hook.\\_cleanup());&#125;&#125;;/\\*\\*- Get a hook&#x27;s state from the currentComponent- @param &#123;number&#125; index The index of the hook to get- @returns &#123;import(&#x27;./internal&#x27;).HookState&#125;  _/  function getHookState(index) &#123;  if (options.\\_hook) options.\\_hook(currentComponent);  // Largely inspired by:  // _ https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs  // _ https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs  // Other implementations to look at:  // _ https://codesandbox.io/s/mnox05qp8  const hooks =  currentComponent.**hooks ||  (currentComponent.**hooks = &#123; \\_list: [], \\_pendingEffects: [] &#125;);// 初始化的时候新 hook 的情况if (index &gt;= hooks.\\_list.length) &#123;hooks.\\_list.push(&#123;&#125;);&#125;return hooks.\\_list[index];&#125;/\\*\\*- @param &#123;import(&#x27;./index&#x27;).StateUpdater&lt;any&gt;&#125; initialState  \\*/  export function useState(initialState) &#123;  return useReducer(invokeOrReturn, initialState);  &#125;/\\*\\*- @param &#123;import(&#x27;./index&#x27;).Reducer&lt;any, any&gt;&#125; reducer- @param &#123;import(&#x27;./index&#x27;).StateUpdater&lt;any&gt;&#125; initialState- @param &#123;(initialState: any) =&gt; void&#125; [init]- @returns &#123;[ any, (state: any) =&gt; void ]&#125;  _/  export function useReducer(reducer, initialState, init) &#123;  /\\*\\* @type &#123;import(&#x27;./internal&#x27;).ReducerHookState&#125; _/  const hookState = getHookState(currentIndex++);  if (!hookState.\\_component) &#123;  hookState.\\_component = currentComponent;      hookState._value = [        !init ? invokeOrReturn(undefined, initialState) : init(initialState),        action =&gt; &#123;          const nextValue = reducer(hookState._value[0], action);          if (hookState._value[0] !== nextValue) &#123;            hookState._value[0] = nextValue;            hookState._component.setState(&#123;&#125;);          &#125;        &#125;      ];  &#125;return hookState.\\_value;&#125;/\\*\\*- @param &#123;import(&#x27;./internal&#x27;).Effect&#125; callback- @param &#123;any[]&#125; args  _/  export function useEffect(callback, args) &#123;  /\\*\\* @type &#123;import(&#x27;./internal&#x27;).EffectHookState&#125; _/  const state = getHookState(currentIndex++);  if (argsChanged(state.\\_args, args)) &#123;  state.\\_value = callback;  state.\\_args = args;      currentComponent.__hooks._pendingEffects.push(state);  &#125;  &#125;/\\*\\*- @param &#123;import(&#x27;./internal&#x27;).Effect&#125; callback- @param &#123;any[]&#125; args  _/  export function useLayoutEffect(callback, args) &#123;  /\\*\\* @type &#123;import(&#x27;./internal&#x27;).EffectHookState&#125; _/  const state = getHookState(currentIndex++);  if (argsChanged(state.\\_args, args)) &#123;  state.\\_value = callback;  state.\\_args = args;      currentComponent._renderCallbacks.push(state);  &#125;  &#125;export function useRef(initialValue) &#123;return useMemo(() =&gt; (&#123; current: initialValue &#125;), []);&#125;/\\*\\*- @param &#123;object&#125; ref- @param &#123;() =&gt; object&#125; createHandle- @param &#123;any[]&#125; args  \\*/  export function useImperativeHandle(ref, createHandle, args) &#123;  useLayoutEffect(  () =&gt; &#123;  if (typeof ref === &quot;function&quot;) ref(createHandle());  else if (ref) ref.current = createHandle();  &#125;,  args == null ? args : args.concat(ref)  );  &#125;/\\*\\*- @param &#123;() =&gt; any&#125; callback- @param &#123;any[]&#125; args  _/  export function useMemo(callback, args) &#123;  /\\*\\* @type &#123;import(&#x27;./internal&#x27;).MemoHookState&#125; _/  const state = getHookState(currentIndex++);  if (argsChanged(state.\\_args, args)) &#123;  state.\\_args = args;  state.\\_callback = callback;  return (state.\\_value = callback());  &#125;return state.\\_value;&#125;/\\*\\*- @param &#123;() =&gt; void&#125; callback- @param &#123;any[]&#125; args  \\*/  export function useCallback(callback, args) &#123;  return useMemo(() =&gt; callback, args);  &#125;/\\*\\*- @param &#123;import(&#x27;./internal&#x27;).PreactContext&#125; context  \\*/  export function useContext(context) &#123;  const provider = currentComponent.context[context._id];  if (!provider) return context.\\_defaultValue;  const state = getHookState(currentIndex++);  // This is probably not safe to convert to &quot;!&quot;  if (state.\\_value == null) &#123;  state.\\_value = true;  provider.sub(currentComponent);  &#125;  return provider.props.value;  &#125;/\\*\\*- Display a custom label for a custom hook for the devtools panel- @type &#123;&lt;T&gt;(value: T, cb?: (value: T) =&gt; string | number) =&gt; void&#125;  \\*/  export function useDebugValue(value, formatter) &#123;  if (options.useDebugValue) &#123;  options.useDebugValue(formatter ? formatter(value) : value);  &#125;  &#125;// Note: if someone used Component.debounce = requestAnimationFrame,// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.// Perhaps this is not such a big deal./\\*\\*- Schedule afterPaintEffects flush after the browser paints- @type &#123;(newQueueLength: number) =&gt; void&#125;  _/  /_ istanbul ignore next \\*/  let afterPaint = () =&gt; &#123;&#125;;/\\*\\*- 绘制之后执行回调  \\*/  function flushAfterPaintEffects() &#123;  afterPaintEffects.some(component =&gt; &#123;  if (component.\\_parentDom) &#123;  // 清理上一次的 Effect  component.**hooks.\\_pendingEffects.forEach(invokeCleanup);  // 执行当前 effect  component.**hooks.\\_pendingEffects.forEach(invokeEffect);  component.\\_\\_hooks.\\_pendingEffects = [];  &#125;  &#125;);  afterPaintEffects = [];  &#125;const RAF_TIMEOUT = 100;/\\*\\*- 希望在下一帧 重绘之前，执行 callback。同时，如果 100ms 内，当前帧没有结束(例如窗口不可见的情况)，则直接执行 callback  \\*/  function afterNextFrame(callback) &#123;  const done = () =&gt; &#123;  clearTimeout(timeout);  cancelAnimationFrame(raf);  setTimeout(callback);  &#125;;  const timeout = setTimeout(done, RAF_TIMEOUT);  const raf = requestAnimationFrame(done);  &#125;/_ istanbul ignore else _/if (typeof window !== &quot;undefined&quot;) &#123;let prevRaf = options.requestAnimationFrame;afterPaint = newQueueLength =&gt; &#123;if (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) &#123;prevRaf = options.requestAnimationFrame;      // 执行下一帧结束后，清空 useEffect的回调      (prevRaf || afterNextFrame)(flushAfterPaintEffects);    &#125;&#125;;&#125;/\\*\\*- 执行清理 effect 操作。- @param &#123;import(&#x27;./internal&#x27;).EffectHookState&#125; hook  \\*/  function invokeCleanup(hook) &#123;  if (hook.\\_cleanup) hook.\\_cleanup();  &#125;/\\*\\*- 执行 effect hook 的 cb，并将清理函数赋值给\\_cleanup- Invoke a Hook&#x27;s effect- @param &#123;import(&#x27;./internal&#x27;).EffectHookState&#125; hook  \\*/  function invokeEffect(hook) &#123;  const result = hook.\\_value();  if (typeof result === &quot;function&quot;) hook.\\_cleanup = result;  &#125;/\\*\\*- 判断两个数组是否变化- @param &#123;any[]&#125; oldArgs- @param &#123;any[]&#125; newArgs  \\*/  function argsChanged(oldArgs, newArgs) &#123;  return !oldArgs || newArgs.some((arg, index) =&gt; arg !== oldArgs[index]);  &#125;/\\*\\*- 执行或者返回  \\*/  function invokeOrReturn(arg, f) &#123;  return typeof f === &quot;function&quot; ? f(arg) : f;  &#125;\n","categories":["react"],"tags":["react"]},{"title":"setImmediate() vs setTimeout() 在 JavaScript 中的区别","url":"/setImmediate()%20vs%20setTimeout()%20%E5%9C%A8%20JavaScript%20%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB.html","content":"\n\n\n在 JavaScript 中，setImmediate() 和 setTimeout() 都用于调度任务，但它们的工作方式不同。\nJavaScript 的异步特性JavaScript 以其非阻塞、异步行为而闻名，尤其是在 Node.js 环境中。如果你曾经参与过涉及定时器或回调的项目，你可能遇到过 setTimeout()，甚至 setImmediate()。乍一看，这两个函数似乎做的是同一件事——调度任务以便稍后运行。但如果你曾经一起运行它们，你可能会注意到一些有趣的行为。\n尽管它们的目的相似，但 setImmediate() 和 setTimeout() 在底层的操作方式不同。如果你想知道为什么 setImmediate() 回调似乎一个接一个地运行，而 setTimeout() 回调则是间隔开的，本指南将为你解析其中的原因。\n这不仅仅是 JavaScript 的一个怪癖；它与 Node.js 如何管理异步任务密切相关。理解这两个函数之间的差异将帮助你更好地控制代码的时间和执行顺序，这对于大型应用程序尤其重要，因为即使是时间上的微小失误也可能导致难以发现的错误。\n我们将深入探讨事件循环，它如何处理这些定时器，以及为什么在一起使用它们时事情并不总是按预期发生。到最后，你将更清楚地了解何时使用 setTimeout() 或 setImmediate()，以满足你所需的时间行为。\n行为差异setImmediate(() =&gt; &#123;  console.log(&quot;setImmediate 1&quot;);&#125;);setTimeout(() =&gt; &#123;  console.log(&quot;setTimeout 1&quot;);&#125;, 0);setTimeout(() =&gt; &#123;  console.log(&quot;setTimeout 2&quot;);&#125;, 0);setImmediate(() =&gt; &#123;  console.log(&quot;setImmediate 2&quot;);&#125;);\n\n当你运行这段代码时，你可能期望 setTimeout 回调按定义的顺序执行，然后是 setImmediate 回调。但你在控制台中看到的是：\nsetTimeout 1setImmediate 1setImmediate 2setTimeout 2\n\n如果这让你感到困惑，不要担心。让我们解开其中的原因。\n事件循环要理解这一点，我们需要快速了解 Node.js 如何管理异步操作。Node.js 的异步特性核心是事件循环。\n在 Node.js 中，事件循环处理不同的阶段，每个阶段负责执行某些类型的回调。它帮助管理非阻塞任务，确保函数可以异步执行。在这些阶段中，有不同的队列。对于本次讨论，有两个队列是重要的：\n\n宏任务队列：这是 setTimeout 和 setImmediate 等任务所在的地方。\n微任务队列：这是 promises (Promise.then()) 和 process.nextTick() 回调所在的地方。\n\n事件循环的工作原理要理解 setTimeout() 和 setImmediate() 的工作原理，我们需要看看 Node.js 中的事件循环。事件循环允许 Node.js 处理异步代码。它在不同的阶段处理不同类型的操作，每个阶段负责特定的任务。\n   ┌───────────────────────────┐┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │     pending callbacks     ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       ││  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤  connections, ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │           check           ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘\n\n\n定时器阶段：这是处理 setTimeout() 回调的地方。即使是 0 毫秒的延迟，它们也要等到下一次循环迭代才能执行。\n待处理回调阶段：处理已完成的 I/O 事件，但我们的示例中没有，所以跳过这个阶段。\n检查阶段：setImmediate() 回调在这里运行。它们在 I/O 任务之后立即执行，但在 setTimeout() 回调之前。\n轮询阶段：处理新的传入 I/O 操作，如文件读取或网络请求。如果没有 I/O，事件循环会跳过这个阶段。\n下一次循环迭代：在检查阶段之后，事件循环回到处理下一个定时器阶段，在那里 setTimeout() 回调最终运行。\n\nsetTimeout() 的 0 延迟当你使用 setTimeout() 并设置延迟为 0 时，你实际上是在告诉 Node.js 在当前操作完成后尽快运行回调。然而，重要的是要记住，“尽快”仍然取决于事件循环的阶段。\nsetTimeout(() =&gt; &#123;  console.log(&quot;setTimeout 1 with 0 delay&quot;);&#125;, 0);setImmediate(() =&gt; &#123;  console.log(&quot;setImmediate 1&quot;);&#125;);setTimeout(() =&gt; &#123;  console.log(&quot;setTimeout 2 with 0 delay&quot;);&#125;, 0);\n\n输出结果：\nsetTimeout 1 with 0 delaysetImmediate 1setTimeout 2 with 0 delay\n\n即使延迟为 0，setTimeout() 回调仍然需要等待定时器阶段的下一次循环，因此不会立即运行。相反，它被放置在宏任务队列中，以便在下一个可用机会执行。\nsetImmediate()另一方面，setImmediate() 设计用于在 I/O 事件完成后执行回调，在同一事件循环迭代中。这意味着 setImmediate() 回调在额外的定时器（如 setTimeout()）执行之前被处理，特别是在没有 I/O 的情况下。\n在我们的示例中，由于没有 I/O 发生，两个 setImmediate() 回调会一个接一个地执行，然后才轮到第二个 setTimeout() 回调。\n为什么 setImmediate 回调会一起运行？\n相同的事件循环周期：两个 setImmediate 调用在事件循环的同一个周期（或循环）中被放置到宏任务队列中。Node.js 按顺序处理这些任务。\n**优先于 setTimeout()**：即使 setTimeout() 设定了 0 延迟，这也不保证立即执行。setImmediate() 回调在当前周期中优先于 setTimeout() 任务。\n\n现实世界的类比想象一下在餐馆点餐和饮料。\n\n你点了一道菜（代表 setTimeout(0)）。\n厨师将其添加到订单队列中，一旦准备好就会送达。\n同时，你要了一杯水（setImmediate()），由于它快速且容易准备，服务员会在你的食物完成之前立即送达。\n\n在这个类比中，水（快速任务）首先被处理，即使两个订单几乎同时下达。菜（稍微复杂一些）稍后送达。\n这种情况总是发生吗？不一定。setImmediate() 和 setTimeout() 的行为可能取决于代码中发生的其他异步操作。如果有 I/O 操作，执行顺序可能会改变，因为 setImmediate() 只会在 I/O 事件完成后运行。\nconst fs = require(&quot;fs&quot;);fs.readFile(&quot;example.txt&quot;, () =&gt; &#123;  setTimeout(() =&gt; &#123;    console.log(&quot;setTimeout after I/O&quot;);  &#125;, 0);  setImmediate(() =&gt; &#123;    console.log(&quot;setImmediate after I/O&quot;);  &#125;);&#125;);\n\n输出结果：\nsetImmediate after I/OsetTimeout after I/O\n\n在这种情况下，setImmediate() 总是在 setTimeout() 之前运行，因为事件循环在 I/O 回调之后优先处理 setImmediate()。\n当没有 I/O 事件时，两个 setImmediate() 回调会一个接一个地运行，然后才轮到 setTimeout() 回调。\nprocess.nextTick() 和 Promises以下示例展示了 Node.js 中各种异步操作的处理方式：\nsetTimeout(() =&gt; &#123;  console.log(&quot;setTimeout&quot;);&#125;, 0);setImmediate(() =&gt; &#123;  console.log(&quot;setImmediate&quot;);&#125;);Promise.resolve().then(() =&gt; &#123;  console.log(&quot;Promise then&quot;);&#125;);process.nextTick(() =&gt; &#123;  console.log(&quot;process.nextTick&quot;);&#125;);\n\n输出结果：\nprocess.nextTickPromise thensetTimeoutsetImmediate\n\n\nprocess.nextTick()：这将在任何其他任务之前运行，甚至在微任务（如 Promises）之前。\nPromise.then()：这是一个微任务，因此它在当前操作之后但在宏任务（如 setTimeout() 和 setImmediate()）之前运行。\nsetTimeout()：在微任务处理完之后运行。\nsetImmediate()：尽管它类似于 setTimeout()，但它在事件循环周期的后期运行，在当前 I/O 操作之后。\n\nNode.js 的异步行为有时可能会令人困惑，特别是在处理 setTimeout() 和 setImmediate() 时。关键是理解事件循环以及任务在不同阶段的调度方式。\n\nsetImmediate() 在 I/O 事件之后和当前事件循环周期内运行。\nsetTimeout() 在指定的延迟之后运行，即使延迟为 0，它也会为下一次事件循环迭代调度任务。\n当没有 I/O 操作时，setImmediate() 会在下一个 setTimeout() 之前连续执行。\n\n理解这些差异有助于你精确控制代码的运行时间，这在高性能应用程序中至关重要，因为时间和效率非常重要。\n参考setImmediate() vs setTimeout() in JavaScript\n","categories":["node 原生"],"tags":["node 原生"]},{"title":"一个超方便一键将 csdn 博客生成 hexo 源文件的工具","url":"/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%96%B9%E4%BE%BF%E4%B8%80%E9%94%AE%E5%B0%86%20csdn%20%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90%20hexo%20%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E5%85%B7.html","content":"\n\n\n\n这个工具很早之前写的了。新年疫情原因宅家太无聊了，简单写下文档使用说明….\n\n\n2020.5.01 更新，支持不传递 cookie，此时则为直接爬去 html 解析\n\n\n2020.2.15 更新：无需下载依赖的可执行程序参考\n\n大家在日常写博客的过程中，肯定会遇到想迁移博客的时候。例如我之前就遇到想把 csdn 博客文章迁移到 hexo 上。hexo 的文章源文件就是一些符合特定格式 markdown 的文章。因此要实现也比较简单，对 csdn 博客首页 进行爬虫，（都是一些一些基础的获取标签之类的内容操作了，不详细讲了），然后生成符合特定格式 markdown 即可。\nQuick Start\n前提已经安装 nodejs\n\n1、全局安装工具\nnpm i -g csdnsynchexo\n\n2、获取 csdn 的 cookie（可选）\n\n若不配置 cookie，则爬 html 解析，这种情况是无法获取到标签的。若提供，则使用 api 进行爬取https://blog-console-api.csdn.net/v1/editor/getArticle?id=本人文章id\n\ntips: (这里这么做是因为 csdn 的文章详情api只需要有任意的已登陆的合法 cookie 就能够根据文章 id 拉取信息了。csdn 的模拟登录破解不出来 T T)\n2.1 登录后，点击将这个 url复制下面这段的 cookie 到配置文件或者指定运行。\n3、配置文件\n在当前目录下新建config.json，内容如下\n\ntips: json 记得去掉注释。就是//后面的内容\n\n// config.json&#123;  &quot;csdn&quot;: &quot;https://blog.csdn.net/flytam&quot;, // 要爬取的csdn博客地址  &quot;output&quot;: &quot;./example&quot;, // 输出hexo文章源markdown的目录  &quot;cookie&quot;: &quot;xxxx&quot; // 可选，若提供cookie，只能爬取自己的文章&#125;\n\n4、执行生成\nhsync --config ./config.json\n\n5、结果\n\n可以看到，我们的 hexo 源文件就生成成功了\n码字不易。本工具仓库地址。如果觉得有用，你的 star 是我最大的动力 - -\n","categories":["node"],"tags":["node"]},{"title":"一个超方便将现有博客生成VuePress2文档站的插件","url":"/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%96%B9%E4%BE%BF%E5%B0%86%E7%8E%B0%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90VuePress2%E6%96%87%E6%A1%A3%E7%AB%99%E7%9A%84%E6%8F%92%E4%BB%B6.html","content":"\n\n\n一个超方便将现有博客生成vuepress2文档站的插件闲来无事，研究了一下vuepress2和它的插件机制，写了一个可以一键通过已有博客生成vuepress2的文档站的vuepress2插件vuepress-plugin-blog-sync\n效果在vuepress2中简单引入即可达到将政采云掘金博客一键生成vuepress2页面，效果✨ 详见Demo\n\n使用安装插件\nnpm i vuepress-plugin-blog-sync\n\n按照vuepress文档初始化后，vuepress.config.ts中修改成如下配置引入插件即可达到效果\n// vuepress.config.tsimport &#123; defaultTheme, defineUserConfig &#125; from &#x27;vuepress&#x27;import &#123; blogSyncPlugin &#125; from &#x27;vuepress-plugin-blog-sync&#x27;export default defineUserConfig(&#123;  lang: &#x27;zh-CN&#x27;,  title: &#x27;vuepress-plugin-blog-sync Demo&#x27;,  description: &#x27;Input juejin/csdn/github/etc, output vuepress2 web site&#x27;,  base: &#x27;/vuepress-plugin-blog-sync/&#x27;,  plugins: [    blogSyncPlugin(&#123;      syncConfig: &#123;        type: &#x27;juejin&#x27;,        userId: &#x27;3456520257288974&#x27;,      &#125;,    &#125;),  ],  theme: defaultTheme(&#123;    navbar: [&#123;      text: &#x27;Github&#x27;,      link: &#x27;https://github.com/flytam/vuepress-plugin-blog-sync&#x27;,    &#125;],  &#125;),&#125;)\n\n实现主要利用了之前自己开发的csdnsynchexo提供的爬取网站文章的能力结合vuepress2提供的插件能力，150行代码即可实现，源码详见，下面简单介绍下相关实现点\n文章拉取在vuepress2的onInitialized中进行拉取（使用csdnsynchexo提供的run函数），并进行相关的数据处理，然后通过插件传递的app实例往app.pages中添加我们拉取回来的文章信息，这里按照category作为路由分类\n\n自动生成目录页为了便于统一导航，设计了一个目录页的自动生成的逻辑，同时用户也可以自己传递generateContent进行目录页的内容生成\n\n自动生成navbarvuepress2的插件不再提供配置导航栏的相关api。对于默认主题，提供了在config文件中类似以下的配置能力\nexport default defineUserConfig(&#123;// ...  theme: defaultTheme(&#123;    navbar: [&#123;      text: &#x27;Github&#x27;,      link: &#x27;https://github.com/flytam/vuepress-plugin-blog-sync&#x27;,    &#125;],  &#125;),&#125;)// ...\n通过查阅vuepress2源码我们可以得知。vuepress2在node侧编译时，会将主题的themeData相关信息输出到一个本地文件，在客户端打包时去引用该文件获取到navbar相关信息进行渲染导航栏\n输出themeData信息到一个本地文件\n\n显而易见，如果我们需要根据文章目录自动生成导航，就需要在生命周期中去将我们需要生成的导航信息写入到该文件的指定字段\n经过查阅文档和调试，可以在onPreparedhook中进行实现。并设计了默认会自动按照文章分类进行生成导航，也可以用户自己传递自定义函数来生成该导航的逻辑，自定义函数的两个入参分别是原来的导航对象和我们处理好的文章信息，返回一个新的导航对象用于替换掉原先的导航对象\n&#123;  /**     * 是否根据文章category自动生成navbar     * 默认主题     * @default true     */  navbar?: &#123;    custom?: (originNavbarConfig: DefaultThemeData[&#x27;navbar&#x27;], blogMetaContext: BlogMetaContext) =&gt; DefaultThemeData[&#x27;navbar&#x27;]  &#125; | false&#125;\n\n为了保证对代码文件修改操作的稳定性，这里引入babel进行ast转换进行修改该字段并修改，修改完成后写入原来的internal/themeData文件\n\n最后然后就搞定了。整个功能还是比较简单的。通过这样一个简单的插件编写，就能实现一个非常好玩的功能，并且也了解到vuepress2的源码和架构。还是挺不错的\n\n","categories":["node"],"tags":["node"]},{"title":"两个小优化，webpack打包速度飞起来","url":"/%E4%B8%A4%E4%B8%AA%E5%B0%8F%E4%BC%98%E5%8C%96%EF%BC%8Cwebpack%E6%89%93%E5%8C%85%E9%80%9F%E5%BA%A6%E9%A3%9E%E8%B5%B7%E6%9D%A5.html","content":"\n\n\nwebpack打包速度优化-js\n公司前端项目由于一些原因，很多业务都是放在同一仓库内（例如业务a、b、c，对应目录app/a app/b app/c），并且是用同一套webpack的配置进行打包，每次构建的时候通过传入特定的参数打包指定的业务\n\n优化1 使用babel7，@babel/preset-typescript替代ts-loader使用babel7并且使用@babel/preset-typescript代替ts-loader。一方面，babel7拥有着更快的速度，另一方面，ts-loader默认是会读取ts-config的，于是每次构建的时候ts-loader都会去检查全有业务的类型（即使我们只打包a业务）。\n需要注意的是升级babel7后，相关包名都变成@babel前缀，并且stage-x不再支持（大概原因是stage-x每年都会有变，有的提案可能被废弃导致有的语法被移除，但是却很多项目可能使用了，换成单独配置相关语法特性），需要转对应。以及，@babel/preset-typescript不在支持namespace 详情。\n迁移指南\n&quot;@babel/core&quot;: &quot;^7.0.0&quot;,&quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.0.0&quot;,&quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.4.4&quot;,&quot;@babel/preset-env&quot;: &quot;^7.0.0&quot;,&quot;@babel/preset-react&quot;: &quot;^7.0.0&quot;,&quot;@babel/preset-typescript&quot;: &quot;^7.3.3&quot;,\n\n一版而言对于react项目使用上面的即可。\n\n@babel/core babel的核心库\n@babel/plugin-proposal-class-properties 写react非常实用的类的箭头函数绑定\n@babel/plugin-proposal-decorators 装饰器语法\n@babel/preset-env es6+转换\n@babel/preset-react react jsx支持\n@babel/preset-typescript ts支持\n\nbabel7新增了babel.config.js型的配置，对比.babelrc。.babelrc是从每一个文件向上查找配置的，babel.config.js则不会。\n// babel.config.jsmodule.exports = function(api) &#123;  api.cache(true)  const presets = [    [      &#x27;@babel/preset-env&#x27;,      &#123;        modules: false      &#125;    ],    &#x27;@babel/preset-react&#x27;,    &#x27;@babel/preset-typescript&#x27;  ]  const plugins = [    [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; legacy: true &#125;],    [&#x27;@babel/plugin-proposal-class-properties&#x27;, &#123; loose: true &#125;]  ]  return &#123;    presets,    plugins  &#125;&#125;// webpack.js...        &#123;          test: /\\.(jsx?|tsx?)$/,          exclude: [&#x27;node_modules&#x27;],          use: [&#x27;babel-babel&#x27;]        &#125;,...\n\n\n优化2 happypack\nhappypack 是 webpack 的一个插件，目的是通过多进程模型，来加速代码构建。（这个提升还是很明显的）\n\n使用happypack加载babel-loader。\nlet HappyPack = require(&#x27;happypack&#x27;)let os = require(&#x27;os&#x27;)let happyThreadPool = HappyPack.ThreadPool(&#123; size: os.cpus().length &#125;)...        &#123;          test: /\\.(jsx?|tsx?)$/,          exclude: [&#x27;node_modules&#x27;],          use: [&#x27;happypack/loader?id=babel&#x27;]        &#125;,......    plugins: [      new HappyPack(&#123;        id: &#x27;babel&#x27;,        loaders: [          &#123;            loader: &#x27;babel-loader&#x27;          &#125;        ],        threadPool: happyThreadPool      &#125;)]...\n\n优化前\ndev babel6+ts-loader 56806msbuild babel6+happypack 29758ms \n\n优化后dev babel7+happypack 9576msbuild babel7+happypack 23838ms\n","categories":["工程化"],"tags":["工程化"]},{"title":"从一个webpack打包bug到探索resolve背后的机制","url":"/%E4%BB%8E%E4%B8%80%E4%B8%AAwebpack%E6%89%93%E5%8C%85bug%E5%88%B0%E6%8E%A2%E7%B4%A2resolve%E8%83%8C%E5%90%8E%E7%9A%84%E6%9C%BA%E5%88%B6.html","content":"\n\n\n背景最近在业务项目配置升级改造的时候遇到了一个诡异的运行时报错\n\n经过进一步调试发现，原因是在业务代码的lib/axios.ts的import axios, &#123; AxiosError, AxiosRequestConfig, AxiosResponse &#125; from &#39;axios&#39;;这行代码的引入居然是引入的 业务代码的lib/``axios``.ts而不是node_modules中的axios\n由于项目使用的是司内一个二次封装webpack的框架，找相关同学排查后发现是tsconfig-paths-webpack-plugin的一个bug导致。可以看到网上也有人提出了这个issue，并且可以看到有人也提了一个MR去修复这个问题。但是由于提出MR修复的老哥也表示不了解为啥这样改就好了，所作者也表示需要等有足够的单元测试才能将这个进行合并\n\nhttps://github.com/dividab/tsconfig-paths-webpack-plugin/issues/83https://github.com/dividab/tsconfig-paths-webpack-plugin/pull/85\n\n\n来都来了，不如就研究清楚这个bug是如何发生的，以及如何去修复\nwebpack resolve plugin原理首先tsconfig-paths-webpack-plugin这个plugin是做啥的？\n\nUse this to load modules whose location is specified in the paths section of tsconfig.json when using webpack. This package provides the functionality of the tsconfig-paths package but as a webpack plug-in.\n\n\nUsing this plugin means that you should no longer need to add alias entries in your webpack.config.js which correspond to the paths entries in your tsconfig.json. This plugin creates those alias entries for you, so you don’t have to!\n\n简单说，就是我们使用ts开发项目的时候通常需要配置tsconfig.compilerOptions.paths。默认情况下webpack是不认识这个配置的，通过配置这个webpack插件，即可实现无需在webpack中配置resolve.alias 即可让webpack打包时根据tsconfig的paths找到对应的文件。它底层是是依赖了tsconfig-path的createMatchPathAsync函数实现这个模块路径的查找功能\n还需要注意一点的是tsconfig-paths-webpack-plugin 是webpack的resolve plugin而不是常规的webpack plugin。两者的区别在于webpack plugin是配置在webpack的config.plugins字段，而webpack resolve plugin是配置在config.resolve.plugins字段。两种插件对应的api也不太一样，webpack plugin一般通过complier/compilation去监听生命周期处理webpack打包整个过程的一些行为；而resolve plugin则专注于处理模块resolve的过程。而webpack配置文件的config.resolve字段基本是都传递给enhanced-resolve这个库是实例化resolver的。webpack内部的模块解析打包的路径处理就是由enhanced-resolve去实现。\n下图来自webpack源码的createResolver就是enhanced-resolve提供的\n\n在查看tsconfig-paths-webpack-plugin的实现之前了解下enhanced-resolver的架构有助于我们更好地去查bug。\nenhanced-resolver 是一种基于core+plugin的运行机制。enhanced-resolver主要提供一个基础的resolver对象通过其resolve方法去处理模块路径查找；提供plugin的机制，基于tapable实现事件通信串联起webpack内部和resolver plugin之间的关系。resolver通过调用resolve/doResolve方法即可串联起来各个plugin进而实现模块查找。\nresolver基本用法：可参考https://github.com/webpack/enhanced-resolve#creating-a-resolver\nresolver的插件机制：\nresolver对象在实例化时内部注册了4个hook对象，hook都是tabable的实例，用到的hook类型如下\nresolve AsyncSeriesBailHook  tapAsync/tapPromise/callAsync/promise 执行过程中注册的回调返回非 undefined 时就会直接执行 callAsync 或者 promise 中的函数，并且注册的后续回调都不会执行resolveStep SyncHook 同步hook。call/tapnoResolve SyncHook 同步hook。call/tapresult AsyncSeriesHook tapAsync/tapPromise/callAsync/promise 顺序的执行注册的异步回调\n\nresolver的plugin其实就是遵循着从source来target去的一直执行流程。每个Plugin都是通过hook监听source事件触发，执行完本插件的逻辑后触发target事件到下一个对应的hook去。resolver的plugin之间的通信监听回调函数都是符合(request, resolveContext, callback: (err?: any, result: any) =&gt; void) =&gt; void 签名的格式\n\n  request：resolver模块请求对象，包含当前需要查找的文件的一些信息\n\n\n\n  resolveContext 贯穿整个流程的上下文对象\n  callback 函数，当前plugin执行完成后传递给下一个plugin的一些信息。result就是下一个plugin接收到的request\n\n如一个最简单的NextPlugin的代码如下。按照约定，每个resolve plugin都有一个source和target属性。source表示当前plugin是在source事件触发后执行；target表示当前plugin执行后会触发target事件\n// https://github.com/webpack/enhanced-resolve/blob/main/lib/NextPlugin.jsmodule.exports = class NextPlugin &#123;    /**     * @param &#123;string | ResolveStepHook&#125; source source     * @param &#123;string | ResolveStepHook&#125; target target     */    constructor(source, target) &#123;        this.source = source;        this.target = target;    &#125;    /**     * @param &#123;Resolver&#125; resolver the resolver     * @returns &#123;void&#125;     */    apply(resolver) &#123;        const target = resolver.ensureHook(this.target);        resolver            .getHook(this.source)            .tapAsync(&quot;NextPlugin&quot;, (request, resolveContext, callback) =&gt; &#123;                resolver.doResolve(target, request, null, resolveContext, callback);            &#125;);    &#125;&#125;;\n\n这个插件的逻辑就是监听source对应的事件，执行resolver对象的doResolve方法去查找模块，将结果传递给监听target事件的plugin\n// https://github.com/webpack/enhanced-resolve/blob/main/lib/ResolverFactory.js//...    plugins.push(        new NextPlugin(&quot;after-undescribed-resolve-in-package&quot;, &quot;resolve-in-package&quot;)    );\n\n如上代码表示监听undescribed-resolve-in-package 触发完成后，执行doResolve 后触发resolve-in-package事件。而enhanced-resolve本身基础功能的实现就是由若干个内置plugin一起实现\n\n整体的resolve的架构图如下\n\ntsconfig-paths-webpack-plugin原理经过上面的分析，这是一个resolve plugin，该plugin总体流程如下：\n\n hook是由监听的described-resolve事件后触发，将结果传递给resolve事件。\n 如果request请求的文件路径是.或者..前缀，则为相对路径，plugin不作处理。直接跳过处理流程，应用webpack默认resolve流程\n 如果是非相对路径，则通过matchPath函数查找实际模块路径，若实际模块路径不存在直接跳过处理流程，应用webpack默认resolve流程；若存在将结果传递给resolve hook进而找到模块\n\n简化后主要逻辑伪代码如下\n// https://github.com/dividab/tsconfig-paths-webpack-plugin/blob/master/src/plugin.ts#L230function createPluginCallback(  matchPath: TsconfigPaths.MatchPathAsync,  resolver: Resolver,  absoluteBaseUrl: string,  hook: Tapable,  extensions: ReadonlyArray&lt;string&gt;): TapAsyncCallback &#123;  return (    request: ResolveRequest,    resolveContext: ResolveContext,    callback: TapAsyncInnerCallback  ) =&gt; &#123;    // 锚点1    const innerRequest = getInnerRequest(resolver, request);    // 锚点2    if (      !innerRequest ||      innerRequest.startsWith(&quot;.&quot;) ||      innerRequest.startsWith(&quot;..&quot;)    ) &#123;      return callback();    &#125;    // 锚点3    matchPath(      innerRequest,      readJsonAsync,      fileExistAsync,      extensions,      (err, foundMatch) =&gt; &#123;        if (err) &#123;          return callback(err);        &#125;        if (!foundMatch) &#123;          return callback();        &#125;        const newRequest = &#123;          ...request,          request: foundMatch,          path: absoluteBaseUrl,        &#125;;        return resolver.doResolve(          hook,          newRequest,          &#123;&#125;,          &#123;&#125;,          (err2: Error, result2: ResolveRequest): void =&gt; &#123;            callback(undefined, result2);          &#125;        );      &#125;    );  &#125;;&#125;\n\n出现bug的原因\n最简复现demo\n\n 配置`compilerOptions.baseUrl = “./src”\n 建一个src/lib/axios文件\n src/index中import axios from &#39;axios&#39;\n\n\nBUG表现，index中import的axios居然是lib/axios！而不是node_modules中的，就会导致了错误。\n通过断点调试加上面的代码逻辑解读可以找出bug的原因\n\n 我们在index.ts import了axios，而axios的入口文件node_modules/axios/index.js有以下代码\n\nmodule.exports = require(&#x27;./lib/axios&#x27;);\n\n此时，到了resolve查找./lib/axios的流程。进入到锚点1的getInnerRequest函数，该函数做了一个处理并返回。而此时的request.relativePath值为. ， innerRequest值为./lib/axios。它们join后的结果就是lib/axios。\ninnerRequest = resolver.join(request.relativePath, innerRequest);\n\n通过锚点3的matchPath函数传入lib/axios 参数进行查找，显然这个时候查找的结果就是src/lib/axios文件了，此时这个文件在项目中又是存在的。于是，import axios最终就是import了src/lib/axios，这就产生了开头提的bug。这里的根本原因是axios入口文件内部的./lib/axios被错误处理了，按道理说这种相对路径导入是不应该被alias插件处理的。我们可以看到锚点2是有判断innerRequest是否相对路径，但是基于上面的分析可以知道getInnerRequest的结果必然是非相对路径的(resolver.join的背后其实是path.join的封装)。\n\n至于为何request.relativePath是.，通过上面的分析可知，tsconfig-paths-webpack-plugin是由described-resolve hook事件触发，在enhanced-resolve中可以找到触发described-resolve的是DescriptionFilePlugin\n\n对应的relativePath其实含义就是当前被request文件相对于所在包的路径，对于node_modules/axios的index.js来说就是.\n\n因此，锚点2用getInnerRequest的返回值来判断是否相对路径是个bug。getInnerRequest会将相对路径的request和relativePath 进行join导致丢失了前面的相对路径前缀\n正确的解法则是应该用request.request去判断，对于相对路径则plugin跳过处理。request.request对应就是源代码中的引入路径的部分\n\n解决解决的PR已经有了。但是维护者暂时还没合进。直接通过暴力修改文件名的方式虽然能暂时解决这个问题，但是这难免以后会再次踩坑。这时候可以通过patch-package方式来解决node_modules带来的问题\n\n package.json添加&quot;postinstall&quot;: &quot;patch-package&quot;\n\nnpm i -D patch-package\n\n\n 直接到node_modules/tsconfig-paths-webpack-plugin/lib/plugin.js对应位置修改为正确的代码\n 执行npx patch-package tsconfig-paths-webpack-plugin\n 此时会生成一个patch文件，将这个文件一同提交到git仓库\n\n\n\n 运行代码，没有再出现开头所示的报错，bug解除\n\n","categories":["工程化"],"tags":["工程化"]},{"title":"使用 rxjs 实现拖拽","url":"/%E4%BD%BF%E7%94%A8%20rxjs%20%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD.html","content":"\n\n\n\n最近看了一点rxjs的东西。现学现玩一下…..就来尝试下元素拖拽吧\n\n如果使用非rxjs而是普通的js实现思路也不难。\n一般实现拖拽的思路是：\n1、监听 drag 元素 的 mousedown，回调中设置标识开始拖动，计算出初始点击到元素左上角距离\n2、监听 document 的 mousemove，判断 1 中标识处于拖动，通过计算当前位置设置元素的样式\n3、监听 document 的 mouseup，设置标识停止拖动\n// 不使用rxjs实现。const drag = document.getElementById(&quot;drag&quot;);let isDrag = false;let initialX = null,    initialY = null;drag.addEventListener(&quot;mousedown&quot;, function(e) &#123;    isDrag = true;    const &#123; left, top &#125; = drag.getBoundingClientRect();    initialX = e.clientX - left;    initialY = e.clientY - top;&#125;);document.addEventListener(&quot;mouseup&quot;, function(e) &#123;    isDrag = false;&#125;);document.addEventListener(&quot;mousemove&quot;, function(e) &#123;    if (isDrag) &#123;        drag.style.left = `$&#123;e.clientX - initialX&#125;px`;        drag.style.top = `$&#123;e.clientY - initialY&#125;px`;    &#125;&#125;);\n\n接下来就是使用 rxjs 来实现了rxjs 中一切皆为流，那么肯定有一个 Observable 源。在拖拽操作中，我们的源肯定就是鼠标的事件了，所以我们这边建立 3 个源，分别是鼠标移动、鼠标点击、鼠标 mouseup\nconst target = document.getElementById(&quot;drag&quot;);const mouseDown = fromEvent(target, &quot;mousedown&quot;);const mouseMove = fromEvent(document, &quot;mousemove&quot;);const mouseUp = fromEvent(document, &quot;mouseup&quot;);\n\n接下来，一次拖拽操作的开始肯定是鼠标点击元素准备拖拽了。所以，入口Observable就是 mouseDown 这个 Observable 了。\nmouseDown.pipe(...)\n\n通过普通的 js 写拖拽我们知道我们开始肯定是需要获取鼠标点击区域到元素左上角的偏移距离，用于后面拖拽后设置元素的正确位置。这里用到了map操作符。和 js 的数组 map 有点像，输入一系列的值然后处理返回一系列新的值，这个过程都是 immutable 的哦。接下来我们就去计算这个偏移值\nmouseDown    .pipe(        map(e =&gt; &#123;            const &#123; left, top &#125; = e.target.getBoundingClientRect();            const clickOffsetX = e.clientX - left;            const clickOffsetY = e.clientY - top;            return &#123;                clickOffsetX,                clickOffsetY            &#125;;        &#125;))        ......\n\n接下来，就是在mousemove事件中去计算元素的位置并设置样式改变元素位置了。上面的pipe运算符就是将前一个操作符的输出作为下一个操作符的输入。\n我们知道拖拽的结束就是mouseup触发的时候，这时候需要takeUntil这个操作符。它的含义就是：解释源 Observable 会不停发射数据直到目标 Observable 发射数据。然后又是使用map去根据原来计算出来的偏移值和当前鼠标移动的值去计算元素的位置了\n...        map((&#123; clickOffsetX, clickOffsetY &#125;) =&gt; &#123;            return mouseMove.pipe(                takeUntil(mouseUp),                map(moveEvent =&gt; (&#123;                    x: moveEvent.clientX - clickOffsetX,                    y: moveEvent.clientY - clickOffsetY                &#125;))            );        &#125;)...\n\n上面我们map又接了一个map，类似于一个二维的Observable，如[[Observable]]。我们再借助concatAll打平成一维即可。整个Observable的处理过程就完成了，最后订阅Observable再设置元素的位置即可。完整代码如下。\n// 使用rxjs实现const &#123;    fromEvent,    operators: &#123; map, takeUntil, concatAll, withLatestFrom &#125;&#125; = rxjs;const target = document.getElementById(&quot;drag&quot;);const mouseDown = fromEvent(target, &quot;mousedown&quot;);const mouseMove = fromEvent(document, &quot;mousemove&quot;);const mouseUp = fromEvent(document, &quot;mouseup&quot;);mouseDown    .pipe(        map(e =&gt; &#123;            const &#123; left, top &#125; = e.target.getBoundingClientRect();            const clickOffsetX = e.clientX - left;            const clickOffsetY = e.clientY - top;            return &#123;                clickOffsetX,                clickOffsetY            &#125;;        &#125;),        map((&#123; clickOffsetX, clickOffsetY &#125;) =&gt; &#123;            return mouseMove.pipe(                takeUntil(mouseUp),                map(moveEvent =&gt; (&#123;                    x: moveEvent.clientX - clickOffsetX,                    y: moveEvent.clientY - clickOffsetY                &#125;))            );        &#125;),        concatAll()    )    .subscribe((&#123; x, y &#125;) =&gt; &#123;        target.style.left = `$&#123;x&#125;px`;        target.style.top = `$&#123;y&#125;px`;    &#125;);\ndemo\n后话：使用rxjs对于处理复杂的异步操作还是很好的，也包含了很多函数式编程的思想。不过要学习rxjs那种思想感觉还是要有一定的适应过程….慢慢来吧\n","categories":["rxjs"],"tags":["rxjs"]},{"title":"使用TypeScript并升级到React 18","url":"/%E4%BD%BF%E7%94%A8TypeScript%E5%B9%B6%E5%8D%87%E7%BA%A7%E5%88%B0React%2018.html","content":"\n\n\n为了支持React 18，React类型定义进行了升级，其中包含了一些break change。本文将讲述在TypeScript中如何升级到React 18\nReact 18和Definitely Typed在alpha和beta测试经历了相当长的一段时间后，React 18 于2022年3月29日正式发布。在第一个alpha版本发布的时候，TypeScript就提供了支持\n这是通过Definitely Typed(一个社区维护的各种TypeScript类型定义的库)的类型定义实现的)来使用。感谢Sebastian Silbermann的贡献，他在React18的类型定义工作中投入了大量的精力\n目前React 18已经发布并且React 18 的类型定义在 Sebastian 的pr合并后也进行了更新。许多项目会面临一些break change。本文章将介绍会产生哪些break change及如何解决\nDefinitely Typed和语义版本控制开发者习惯于在使用的软件中进行语义版本控制。通常来说在主版本的修改是表明有重大更改的。这正是React从v17升级到v18所做的事\nDefinitely Typed是不支持语义版本控制的\n这不是故意的。因为Definitely Typed特意将类型定义发布到npm的@types作用域下。例如，React的类型定义被发布到@types/react\n需要注意的是，npm 建立在语义版本控制之上。为了使类型定义的使用更容易，类型定义包的版本将等同于它支持的 npm 包的版本。对于 react的18.0.0，对应的类型定义是@types/react的18.0.0\n如果@types/react类型定义发生breaking change，则会发布新版本而不是增加主要或次要版本号\n修改将仅应用于修订号。这样做是为了通过npm维护当前更简单的类型消费模型\nReact 18: 类型上的breaking change综上所述，对于那些被广泛使用的类型定义包，都会尽量减少产生breaking change\n顺便说一句，Definitely Typed自动化工具将类型定义分为三类: “深受大家喜爱(Well-liked by everyone)”、”流行(Popular)”和”关键(Critical)”。感谢Andrew Branch的分享。被广泛使用的React被认为是”关键的”\n当Sebastian提交了一个pr来升级TypeScript的React类型定义时，就有机会来做一些重大的修改。这些修改可能并不都与React 18有直接关系但会修复React类型定义中长期存在的一些问题\nSebastian pr非常好，我建议你去看一下。以下是重大更改的摘要\n\n移除隐式children\n移除ReactFragment中的&#123;&#125;(related to 1.)\nthis.context变成unkown\nUsing noImplicitAny now enforces a type is supplied with useCallback\nnoImplicitAny应用到useCallback\n删除不推荐使用的类型与React官方保持一致\n\n在上述修改中，移除隐式children是最具破坏性的。Sebastian专门写了一篇博客来解释其原因。他还写了一个codemod来有利于进行这个代码迁移\n下面让我们开始将代码库的react升级到18吧！\n升级我将通过升级我阿姨的网站进行演示。这是一个简单的网站，升级的pr\n首先在package.json中升级React\n-    &quot;react&quot;: &quot;^17.0.0&quot;,-    &quot;react-dom&quot;: &quot;^17.0.0&quot;,+    &quot;react&quot;: &quot;^18.0.0&quot;,+    &quot;react-dom&quot;: &quot;^18.0.0&quot;,\n\n然后升级类型定义\n-    &quot;@types/react&quot;: &quot;^17.0.0&quot;,-    &quot;@types/react-dom&quot;: &quot;^17.0.0&quot;,+    &quot;@types/react&quot;: &quot;^18.0.0&quot;,+    &quot;@types/react-dom&quot;: &quot;^18.0.0&quot;,\n升级的时候需要检查lock依赖（yarn.lock / package-lock.json等），确保只有18版本的@types/react和react。\n现在依赖安装已完成，会看到以下报错\nProperty ‘children’ does not exist on type ‘LoadingProps’.ts(2339)\n代码如下\ninterface LoadingProps &#123;  // 你会注意到这里没有 `children` 属性 - 这就是出现错误的原因  noHeader?: boolean;&#125;// if props.noHeader is true then this component returns just the icon and a message// if props.noHeader is true then this component returns the same but wrapped in an h1const Loading: React.FunctionComponent&lt;LoadingProps&gt; = (props) =&gt;  props.noHeader ? (    &lt;&gt;      &lt;FontAwesomeIcon icon=&#123;faSnowflake&#125; spin /&gt; Loading &#123;props.children&#125; ...    &lt;/&gt;  ) : (    &lt;h1 className=&quot;loader&quot;&gt;      &lt;FontAwesomeIcon icon=&#123;faSnowflake&#125; spin /&gt; Loading &#123;props.children&#125; ...    &lt;/h1&gt;  );\n\n\n在这里看到的是去除隐式children的改动。在我们进行升级之前，所有React.Component和React.FunctionComponent都有一个children属性，它允许React用户在不声明children的情况下直接使用\n升级18后就不一样了。如果有一个带有子组件，则必须显式声明这个组件的类型\n在这个例子中，通过直接添加children属性的声明可以修复这个问题\ninterface LoadingProps &#123;  noHeader?: boolean;  children: string;&#125;\n\n但是，当可以让其他方式帮我们写代码的话，为什么还要写代码呢？\n我们可以使用Sebastian开发的codemod来替代手动修改代码。使用它直接通过以下的命令就可以：\nnpx types-react-codemod preset-18 ./src\n\n执行后，会看到如下提示：\n\n选择a并让codemod运行。对于这个项目，有37个文件更新了。所有文件都需要进行相同的修改。在每种情况下，组件的props都被React.PropsWithChildren包起来。例如Loading组件如下\n-const Loading: React.FunctionComponent&lt;LoadingProps&gt; = (props) =&gt;+const Loading: React.FunctionComponent&lt;React.PropsWithChildren&lt;LoadingProps&gt;&gt; = (props) =&gt;\n\nPropsWithChildren仅仅是将children属性添加，如下\ntype PropsWithChildren&lt;P&gt; = P &amp; &#123; children?: ReactNode | undefined &#125;;\n这就解决了上面遇到的编译问题，没有类型问题报错了\n总结通过本文我们已经学习到React 18是如何出现类型的破坏性更改，并知道可以使用codemod快速进行升级\n\n","categories":["react"],"tags":["react"]},{"title":"使用pkg打包node应用","url":"/%E4%BD%BF%E7%94%A8pkg%E6%89%93%E5%8C%85node%E5%BA%94%E7%94%A8.html","content":"\n\n\n\nnode相比其它C艹等语言的好处是直接装好node环境后node xxx.js就可以运行了，非常方便。但是这样的话别人就能直接看到源代码，而且每次部署都需要node环境，并且安装相关的依赖。\n\n此时pkg这个库就能解决介个问题。最近因为项目需求方需要，搞了下这方面的需求。\n正确的姿势。例如项目的入口文件是app.js\n1、项目根目录下安装pkg\nnpm i -D pkg\n\n2、打包配置\n参考pkg文档。pkg可以在任意系统上打包全平台的可执行文件。例如我的需求是需要打包win64位系统node8环境的包。只需要package.json的scripts下配置。.的话是去读取bin的入口文件。\n&quot;pkgwin&quot;: &quot;pkg . -t node8-win-x64 -o app&quot;,\n\nbin路径\n&quot;bin&quot;: &quot;./app.js&quot;\n\n需要注意的是pkg只会分析require的文件并打包在一起，\b如果是动态拼接的路径就不会打包进去。\n例如我的项目下有的是开启子进程的代码\nconst trackWorker = child_process.fork(`$&#123;__dirname&#125;/workers/trackChild.js`);\n\n此时，需要告诉pkg需要手动打包的文件\n&quot;pkg&quot;: &#123;  &quot;scripts&quot;: &quot;workers/**/*.js&quot;&#125;,\n\n这样就大功告成了\n4、实现自定义配置文件\n数据库等其它的配置我们肯定需要暴露出来的，毕竟打包出来就只有一个二进制文件。配置\b就需要特殊处理下。预期是打包出来最终运行的时候是\n\n目录\napp.exe\nconfig.json\n\n\n\n我们只需要改config.json的配置就行了。也很简单，就是读取配置的时候去读取json文件就行（文档也让我们尽量用json而不是js，因为node的模块\b加载制止我们的config.js代码会被执行，别人会读取到源码）\nconst fs = require(&quot;fs&quot;);const path = require(&quot;path&quot;);const configPath = path.join(process.execPath, &quot;../&quot;,&quot;./config.json&quot;);let isConfigExist = fs.existsSync(configPath);let jsonConfig = nullif (isConfigExist) &#123;  jsonConfig = JSON.parse(fs.readFileSync(configPath, &quot;utf8&quot;));&#125;\n\n5、部署\npm2也是可以直接部署可执行文件，不过使用这种部署的话就只能使用fork模式 ,\b而不能使用cluster模式。\n\n简单的说，pm2的cluster模式只能执行node。以node的cluster为基础，多进程。fork模式，单实例。不止node\n\n最后附上package.json和pm2的配置\n&#123;  &quot;name&quot;: &quot;webapi&quot;,  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;nodemon ./app.js&quot;,    &quot;pm2&quot;: &quot;pm2 start pm2.json&quot;,    &quot;pkgmac&quot;: &quot;pkg . -t node8-macos-x64 -o app&quot;,    &quot;pkgwin&quot;: &quot;pkg . -t node8-win-x64 -o app&quot;,    &quot;pkg&quot;: &quot;pkg . -t node10-win-x64 -o app&quot;  &#125;,  &quot;bin&quot;: &quot;./app.js&quot;,  &quot;pkg&quot;: &#123;    &quot;scripts&quot;: &quot;workers/**/*.js&quot;  &#125;,  &quot;dependencies&quot;: &#123;...  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;nodemon&quot;: &quot;^1.11.0&quot;,    &quot;pkg&quot;: &quot;^4.3.5&quot;  &#125;&#125;\n\n&#123;  &quot;apps&quot;: [    &#123;      &quot;name&quot;: &quot;webAPI&quot;,      &quot;script&quot;: &quot;app&quot;,      &quot;cwd&quot;: &quot;./&quot;,      &quot;error_file&quot;: &quot;./logs/app-err.log&quot;,      &quot;out_file&quot;: &quot;./logs/app-out.log&quot;,      &quot;log_date_format&quot;: &quot;YYYY-MM-DD HH:mm Z&quot;,      &quot;max_memory_restart&quot;: &quot;300M&quot;    &#125;  ]&#125;\n可能遇到问题：\n第一次打包的时候，会遇到下包很慢很可能超时的问题。如下：\n\n到https://github.com/zeit/pkg-fetch/releases下载对应的包，然后~/.pkh-cache/2.5/目录下，改名为fetched-v8.11.3-macos-x64（参考运行时下的包名字改）即可。参考https://github.com/zeit/pkg/issues/419\n","categories":["node"],"tags":["node"]},{"title":"初识web-components和todolist实现","url":"/%E5%88%9D%E8%AF%86web-components%E5%92%8Ctodolist%E5%AE%9E%E7%8E%B0.html","content":"\n\n\n\n在当下，前端三巨头vue react ng都是提倡组件化开发的，在原生领域，web-components也逐渐成为标准。近段时间大热的omi就是基于web-components实现的\n\nweb-components主要由3部分组成\n\ncustom-elements\nshadow-dom\nslot template\n\ncustom-elements从字面意思可以知道这是自定义元素的意思。区别于原生html元素，我们可以自己定义它的行为。按照是否从原生html元素继承，可分下面两类\n两类custom元素\nAutonomous custom elements。完全自定义元素\nCustomized built-in elements .从常规html元素继承的\n\n生命周期custom-elements 比较赞的一点是具有以下的生命周期\n\nconnectedCallback 连接到dom后触发类似于react的componentDidMount，当自定义元素首次加载到dom会触发，如果我们想获取传入的attributes来选择展示内容的话，需要将逻辑放在这个周期内而不是constructor中,constructor是取不到attributes的值，还需要注意的是，受html限制，通过html传入的attributes值都是字符串\n\ndisconnectedCallback 当自定义元素从DOM树中脱离触发对于绑定元素的事件监听，可以在这里进行解绑，防止内存泄漏\n\nadoptedCallback 当自定义元素移动到新的document触发\n\nattributeChangedCallback 自定义元素属性值改变时触发。这个需要配合static get observedAttributes()&#123;return [&#39;需要监听的属性&#39;]&#125;使用，表示哪些属性变化才会触发这个生命周期。对于动态attributes进行渲染，这个非常好用\n\n\n一个Autonomous custom elements web-components通常使用方法如下\nclass App extends HTMLElement &#123;  static get observedAttributes() &#123;    return [&#x27;text&#x27;];  &#125;  constructor() &#123;    super();    // 在constructor中初始化// 创建一个shadow元素，会css隔离的，一些原生html元素例如video等也是基于shadowdom实现的    const shadow = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);    const div = document.createElement(&#x27;div&#x27;);        // web-components内的样式，外部不影响    const style = document.createElement(&#x27;style&#x27;);        shadow.appendChild(style);    shadow.appendChild(div);  &#125;  connectedCallback() &#123;&#125;  disconnectedCallback() &#123;&#125;  adoptedCallback() &#123;&#125;  attributeChangedCallback(name, oldValue, newValue) &#123;&#125;&#125;customElements.define(&#x27;my-app&#x27;, App);\n如果是扩展原生元素的web-components则是类似\nclass CustomP extends HTMLParagraphElement &#123; ...&#125;customElements.define(&#x27;custom-p&#x27;, CustomP,&#123;extend:&#x27;p&#x27;&#125;);\n\nshadom-domshadom-dom操作和平常的dong操作差不多，对this.attachShadow(&#123;mode: &#39;open&#39;&#125;);。shadow-dom最大的好处就是实现了dom隔离。例如css只会对内部的shadow-dom有效，并不影响外部的元素。这应该是css最完美的解决方案了，目前很多组件化css解决方案css modules、各种css in js都不太优雅\n// this是custom-element    const shadow = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;);    const div = document.createElement(&#x27;div&#x27;);        const style = document.createElement(&#x27;style&#x27;);        shadow.appendChild(style);    shadow.appendChild(div);\ntemplate 和 slot 类似于vue的概念，用来实现html复用和插槽效果\ntemplate结合custom-elements用法 &lt;template id=&quot;my-paragraph&quot;&gt;  &lt;style&gt;    p &#123;      color: white;      background-color: #666;      padding: 5px;    &#125;  &lt;/style&gt;  &lt;p&gt;My paragraph&lt;/p&gt;&lt;/template&gt;\n // mdn例子customElements.define(&#x27;my-paragraph&#x27;,  class extends HTMLElement &#123;    constructor() &#123;      super();      let template = document.getElementById(&#x27;my-paragraph&#x27;);      let templateContent = template.content;      const shadowRoot = this.attachShadow(&#123;mode: &#x27;open&#x27;&#125;)        .appendChild(templateContent.cloneNode(true));  &#125;&#125;)\n\nslot用法则和vue的基本一致使用web-components的使用非常方便，有几种方法1、直接html中使用自定义标签\n&lt;custom-element&gt;&lt;/custom-element&gt;\n2、通过js引入\nconst CustomElement = customElements.get(&#x27;custom-element&#x27;);const customElement = new CustomElement();// ordocument.createElement(&#x27;custom-elemen&#x27;)// append进dom\n\n实际开发结合polymer体验更佳\n最后写了个web-compoennts todolist\ndemo \n代码如下\n// TodoList.jsclass TodoList extends HTMLElement &#123;  constructor() &#123;    super();    this.shadowdom = this.attachShadow(&#123; mode: &quot;open&quot; &#125;);    this.handleRemove = this.handleRemove.bind(this);  &#125;  get data() &#123;    const dataAttribute = this.getAttribute(&quot;data&quot;);    if (dataAttribute) &#123;      return Array.isArray(dataAttribute)        ? dataAttribute        : JSON.parse(dataAttribute);    &#125; else &#123;      return [];    &#125;  &#125;  set data(val) &#123;    this.setAttribute(&quot;data&quot;, JSON.stringify(val));    this.render();  &#125;  handleRemove(e) &#123;    this.remove(e.detail.index);  &#125;  connectedCallback() &#123;    this.render();    this.shadowdom.addEventListener(&quot;sub&quot;, this.handleRemove);  &#125;  disconnectedCallback() &#123;    this.shadowdom.removeEventListener(&quot;sub&quot;, this.handleRemove);  &#125;  //渲染内容  render() &#123;    // 简便起见，每次渲染前先清空shadowdom的内容    let last = null;    while ((last = this.shadowdom.lastChild)) &#123;      this.shadowdom.removeChild(last);    &#125;    this.data.forEach((item, index) =&gt; &#123;      const todoiterm = new (customElements.get(&quot;todo-iterm&quot;))();      todoiterm.innerHTML = `&lt;span slot=&#x27;text&#x27;&gt;$&#123;item&#125;&lt;/span&gt;`;      todoiterm.setAttribute(&quot;data-index&quot;, index);      this.shadowdom.appendChild(todoiterm);    &#125;);  &#125;  addIterm(text) &#123;    this.data = [...this.data, text];  &#125;  remove(deleteIndex) &#123;    this.data = this.data.filter((item, index) =&gt; index != deleteIndex);  &#125;&#125;customElements.define(&quot;todo-list&quot;, TodoList);\n\n// TodoIterm.jsclass TodoIterm extends HTMLElement &#123;  constructor() &#123;    super();    const template = document.getElementById(&quot;list-item&quot;);    const templateContent = template.content;    const shadowdom = this.attachShadow(&#123; mode: &quot;open&quot; &#125;);    shadowdom.appendChild(templateContent.cloneNode(true));    shadowdom.getElementById(&quot;sub&quot;).onclick = e =&gt; &#123;      const event = new CustomEvent(&quot;sub&quot;, &#123;        bubbles: true,        detail: &#123; index: this.dataset.index&#125;,      &#125;);      this.dispatchEvent(event)    &#125;;  &#125;&#125;customElements.define(&quot;todo-iterm&quot;, TodoIterm);\n\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;    &lt;title&gt;web-components&lt;/title&gt;    &lt;script src=&quot;./TodoList.js&quot;&gt;&lt;/script&gt;    &lt;script src=&quot;./TodoIterm.js&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;template id=&quot;list-item&quot;&gt;      &lt;style&gt;        * &#123;          color: red;        &#125;      &lt;/style&gt;      &lt;li&gt;&lt;slot name=&quot;text&quot;&gt;nothing write&lt;/slot&gt;&lt;button id=&quot;sub&quot;&gt;-&lt;/button&gt;&lt;/li&gt;    &lt;/template&gt;    &lt;!-- &lt;todo-list&gt;&lt;/todo-list&gt; --&gt;    &lt;div&gt;        &lt;input id=&#x27;input&#x27;/&gt;        &lt;button id=&#x27;add&#x27;&gt;+&lt;/button&gt;    &lt;/div&gt;    &lt;script&gt;        // 加载web compoennts        const List = customElements.get(&#x27;todo-list&#x27;);        const todoList = new List()        document.body.appendChild(todoList)        document.getElementById(&#x27;add&#x27;).onclick = function()&#123;           const value = document.getElementById(&#x27;input&#x27;).value           todoList.addIterm(value)        &#125;     &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n一些需要注意的地方：1、通过html传递属性值，由于是通过attributes传入，所以都是字符串2、组件之间的通信传递需要通过自定义事件\n","categories":["原生"],"tags":["原生"]},{"title":"前端 js 异常那些事","url":"/%E5%89%8D%E7%AB%AF%20js%20%E5%BC%82%E5%B8%B8%E9%82%A3%E4%BA%9B%E4%BA%8B.html","content":"\n\n\n前言人无完人，所以代码总会出异常的，异常并不可怕，关键是怎么处理\n什么是异常程序发生了意想不到的情况，影响到了程序的正确运行\n从根本上来说，异常就是一个普通的对象，其保存了异常发生的相关信息，比如错误码、错误信息等。以 JS 中的标准内置对象 Error 为例，其标准属性有 message。许多宿主环境额外增加了 filename 和 stack 等属性\n错误只有被 throw，才会产生异常，不被抛出的错误不会产生异常。比如直接new Error()甚至打印 Error 但是不 throw，也是不会产生异常\n异常的分类编译时异常源代码在编译成可执行代码之前产生的异常，无需执行即有异常。编译、语法解析发生错误。编译型语言对于这种很常见的，但是解析型的 js 也是会有编译型异常。通常是非合法的 js 语句、ts 编译报错\nconsole.log(1)let 1 // Uncaught SyntaxError: Unexpected numberfunction test() &#123;    console.log(1)    await 1&#125;\n\n代码本身不会执行就抛异常，不会处理到打印 1 的阶段。这种情况通常不会有实际影响，因为 babel/ts 等工具处理时就会直接报错。除非不经编译直接写代码，例如有时候我们直接写在 html 中写的一些代码\n运行时异常代码被执行之后产生的异常。这些通常是很难提前发现的，因为代码实际运行中会遇到。比较常见的如TypeError: Cannot read properties of undefined这样的读取了undefined的属性。运行时异常对比编译时异常的特点是代码执行到异常代码前都是会正常执行的\n执行到a.b.c前的打印能成功，异常抛出后后面的语句就不能执行了。运行时异常即可是这种引擎层面抛出的也可以是代码手动抛出的\n而上面说的编译时异常，即使异常语句前的正常语句也是不会执行\n异常传播异常抛出就像事件冒泡一样具有传递性。如果一个异常没有被 catch，它会沿着函数调用栈一层层传播直到栈空。\n异常会不断传播直到遇到第一个 catch。 如果都没有捕获，会抛出类似 unCaughtError，表示发生了一个异常，未被捕获的异常通常会被打印在控制台上\nerror 对象Error本身作为函数直接调用和被 new 调用的效果是一样的\nconst a = Error(&#x27;a&#x27;)const b = new Error(&#x27;b&#x27;)\n\njavascript 规范中总共有 8 中错误类型构造函数\n\nError – 错误对象\nSyntaxError –解析过程语法错误（上面提到的编译时异常）\nTypeError – 不属于有效类型（上面举例的运行时异常）\nReferenceError – 无效引用（严格模式下直接访问一个未定义的变量）\nRangeError – 数值超出有效范围\nURIError – 解析 URI 编码出错\nEvalError – 调用 eval 函数错误\nInternalError – Javascript 引擎内部错误的异常抛出， “递归太多”\n\nError 是错误的基类，其他类型都继承 Error 这个类\nconsole.log(Object.getPrototypeOf(SyntaxError) === Error);    // trueconsole.log(Object.getPrototypeOf(TypeError) === Error);   // trueconsole.log(Object.getPrototypeOf(ReferenceError) === Error);   // trueconsole.log(Object.getPrototypeOf(RangeError) === Error);   // trueconsole.log(Object.getPrototypeOf(URIError) === Error);   // trueconsole.log(Object.getPrototypeOf(EvalError) === Error);   // true\n\n默认的 error 对象只有一个 message 信息，很多时候对于错误的细分是很不好使，一般可以通过扩展这个错误对象，抛异常时抛出自定义的错误对象，在异常处理或时实现更精细化的处理\nclass ApiError extends Error &#123;  constructor(message, code) &#123;    super(message);    this.code = code  &#125;&#125;const err = new ApiError(&#x27;xxx&#x27;, 404)err instanceof  ApiError\n\n一种常见的应用就是在 axios 处理的异常中抛出一个扩展的 ApiError 对象，传递错误信息、错误等，在错误处理时对于这种错误进行特殊处理。如自定义上报、catch 住不作为 js 异常上报。不进行这种处理的话平时比较常见的情况就是会造成 slardar 的中 js 错误部分会有很多 axios 抛出的噪音\n除了扩展错误对象，目前有一个处于 stage 4 的 Error Cause 提案 https://github.com/tc39/proposal-error-cause。这个提案也是由阿里推进的国内的首个es提案\n\nChrome 96 版本目前还不可用，firefox 可用\n\n\n通过传递给 Error 构造函数的第二个参数一个 cause 属性为一个 Error 对象，即可看到是哪个错误具体产生当前的错误，对于一些调用链路比较深的可可能存在多个异常抛出情况这个特性还是相当好用的，可以准确追踪。Error Cause 当然用自定义扩展错误也能够实现这个功能\nasync function doJob() &#123;  const rawResource = await fetch(&#x27;//domain/resource-a&#x27;)    .catch(err =&gt; &#123;      throw new Error(&#x27;Download raw resource failed&#x27;, &#123; cause: err &#125;);    &#125;);  const jobResult = doComputationalHeavyJob(rawResource);  await fetch(&#x27;//domain/upload&#x27;, &#123; method: &#x27;POST&#x27;, body: jobResult &#125;)    .catch(err =&gt; &#123;      throw new Error(&#x27;Upload job result failed&#x27;, &#123; cause: err &#125;);    &#125;);&#125;try &#123;  await doJob();&#125; catch (e) &#123;  console.log(e);  console.log(&#x27;Caused by&#x27;, e.cause);&#125;// Error: Upload job result failed// Caused by TypeError: Failed to fetch\n\nError 的相关 api\n\n改变堆栈帧数\n\n默认情况下，V8 引发的几乎所有错误都具有一个 stack 属性，该属性保存最顶层的 10 个堆栈帧，格式为字符串 at xxx\n\nError.stackTraceLimit\n\nError.stackTraceLimit 属性指定堆栈跟踪收集的堆栈帧数。默认值为 10，可以设置为任何有效的 JavaScript 数值。 更改将影响值更改后捕获的任何堆栈跟踪。如果设置为非数字值，或设置为负数，则堆栈跟踪将不会捕获任何帧\n\n\n收集自定义异常\n\nError.captureStackTrace(error, constructorOpt)\n\n这个 API 可以给自定义对象追加 stack 属性，达到模拟 Error 的效果，追加的 stack 表示调用 Error.captureStackTrace() 的代码中的位置的字符串。\nfunction CustomError(message) &#123;  this.message = message;  this.name = CustomError.name;  Error.captureStackTrace(this); // 给对象追加stack属性&#125;try &#123;  throw new CustomError(&#x27;msg&#x27;);&#125; catch (e) &#123;  console.log(e)&#125;\n\n\n需要注意的是stack属性对于不同浏览器的格式是不一致的，通常而言监控 sdk 会统一做处理\n这个方法支持传递一个constructorOpt参数，表示所有 constructorOpt 以上的帧，包括 constructorOpt，都将从生成的堆栈跟踪中省略。具体的差异如下\n\n\n使用这个参数可以用于调用栈过深时隐藏深层次的一些调用细节\n\nsourcemap 还原错误\n\n还原错误也是利用了 error 对象的 stack 属性。可以使用stacktracey和source-map实现根据错误堆栈还原到实际发生错误的代码\n线上代码经过压缩后一般只有 1 行，对于定位原始错误是很困难的。并且默认的e.stack属性是个字符串，可以借助stacktracey进行解析并结合source-map进行反解\nconst sourceMap = require(&#x27;source-map&#x27;);const SourceMapConsumer = sourceMap.SourceMapConsumer;const Stacktracey = require(&#x27;stacktracey&#x27;);const errorStack = &#x27;...&#x27;; // 错误信息const sourceMapFileContent = &#x27;...&#x27;; // sourcemap文件内容const tracey = new Stacktracey(errorStack); // 解析错误信息const sourceMapContent = JSON.parse(sourceMapFileContent);const consumer = await new SourceMapConsumer(sourceMapContent);for (const frame of tracey) &#123; // 这里的frame就是stack中的一行所解析出来的内容    // originalPosition不仅仅是行列信息，还有错误发生的文件 originalPosition.source    const originalPosition = consumer.originalPositionFor(&#123;        line: frame.line,        column: frame.column,    &#125;);    // 拿到错误所对应的源码以及上面的行列号    const sourceContent = consumer.sourceContentFor(originalPosition.source);    console.log(sourceContent);&#125;\n\n自动、手动抛出异常可手动抛出也可自动抛出\n自动抛出：代码执行报错由引擎抛出。这种由于逻辑缺失容错造成的自动抛出错误应该是要尽最大程度杜绝并防范的\nconst a = &#123;&#125;a.b.c = 1\n\n手动抛出：直接调用throw\n那什么时候应该手动抛出异常呢？一个指导原则就是已经预知到程序不能正确进行下去了。\nswitch (type) &#123;    case a:    break;    case b:    break;    default:     throw new Error(&#x27;xxxx&#x27;)&#125;\n\n抛出异常还是返回特定错误信息对于上面提到可预知的异常需要终止流程，也可以使用抛出异常或者返回特定数据来让调用方感知。\n\n抛出异常\n\n好处，调用方无需判断返回值，抛出异常默认就不会走后面的逻辑代码了。常见于 axios 对于 code 非 0 的异常抛出处理并自定义上报。再结合上面提到的扩展 error 对象，可以在监控上报前判断属于特定错误不作为 js 上报，避免网络异常造成的 js 错误增加噪音\ninstance.interceptors.response.use(async (res: AxiosResponse&lt;Result&gt;) =&gt; &#123;    if (res?.data?.statusCode !== 0) &#123;        throw new ApiError(&#x27;xx&#x27;, res?.data?.statusCode)    &#125;    return res&#125;)\n\n\n不抛异常而是返回特定信息\n\n如果上述的代码不抛出异常而是直接返回 res 的话，每一处调用就都要手动判断 code。接口 http 返回 http code 200 而响应体 code 不等于 0 也属于不抛异常而是返回特定信息的方式\nconst res = await api()if (res.code !==0) &#123;    return&#125;\n\n异常处理同步、异步try-catch 作为 JavaScript 中处理异常的一种标准方式，如果 try 块中的任何同步代码发生了错误，就会立即退出代码执行过程，然后执行 catch 块。此时 catch 块会接收到一个包含错误信息的对象。try-catch 使用时也可以搭配 finnally 使用。 finally 一经使用，其代码无论如何都会执行。对于异步调用可封装成 promise 的 catch 方法进行调用或借助 async/await 语法糖使用 try/catch\ntry &#123; fn()&#125; catch(e) &#123;&#125;fn().then(() =&gt;&#123;&#125;, () =&gt; &#123;    // catch&#125;)fn().catch(() =&gt; &#123;&#125;)try &#123; await fn() &#125; catch(e) &#123;&#125;\n\n可能到处 try catch 确实不是一种优雅的方式，可以进行适当的封装\n\n 对于异步 promise 调用可以直接使用await-to-js，利用 Promise 的特性，分别在 promise.then 和 promise.catch 中返回不同的数组，其中 fulfilled 的时候返回数组第一项为 null，第二个是结果。rejected 的时候，返回数组第一项为错误信息，第二项为 undefined。使用的时候，判断第一项是否为空，即可知道是否有错误\n\nimport to from &#x27;await-to-js&#x27;;async function asyncTask() &#123;     let err, user, savedTask;     [err, user] = await to(UserModel.findById(1));     if(!user) throw new CustomerError(&#x27;No user found&#x27;);     [err, savedTask] = await to(TaskModel(&#123;userId: user.id, name: &#x27;Demo Task&#x27;&#125;));     if(err) throw new CustomError(&#x27;Error occurred while saving task&#x27;);    if(user.notificationsEnabled) &#123;       const [err] = await to(NotificationService.sendNotification(user.id, &#x27;Task Created&#x27;));       if (err) console.error(&#x27;Just log the error and continue flow&#x27;);    &#125;&#125;\n\n\n 对于 class 方法调用适当使用装饰器进行 catch\n\nexport function CatchAsync(errorLabel = &#x27;&#x27;) &#123;    return function (target: unknown, key: string, descriptor: PropertyDescriptor) &#123;        errorLabel = errorLabel || key        const originFn = descriptor.value        descriptor.value = async function (...rest: unknown[]) &#123;            try &#123;                return await originFn.call(this, ...rest)            &#125; catch (e) &#123;               // do something                throw e            &#125;        &#125;    &#125;&#125;export function CatchSync(errorLabel = &#x27;&#x27;) &#123;    return function (target: unknown, key: string, descriptor: PropertyDescriptor) &#123;        errorLabel = errorLabel || key        const originFn = descriptor.value        descriptor.value = function (...rest: unknown[]) &#123;            try &#123;                return originFn.call(this, ...rest)            &#125; catch (e) &#123;                // do something                throw e            &#125;        &#125;    &#125;&#125;class A &#123;    @CatchAsync(&#x27;1&#x27;)    async request() &#123;    &#125;&#125;\n\nPromise catch 小细节\n\n以下两种写法的区别\n\nthen(f1,f2) vs then(f1).catch(f2)\n绝大多数情况下是相同的。\n区别在于第一种写法 f2 无法捕获 f1 中的异常。第二种写法 f2 能捕获 f1 中的异常\n全局兜底对于无需手动捕获或者没有捕获的异常最终会抛到全局。通过全局error 和unhandledrejection进行监听并处理。监听全局异常和未捕获的 Promise 异常并进行相关处理\nfunction onReject(e) &#123;    // ...    report(e)&#125;window.addEventListener(&#x27;unhandledrejection&#x27;, onReject, true)window.addEventListener(&#x27;error&#x27;, this.onError, true)\n\nwindow.onerror和window.addEventListener error的区别\n\nwindow.onerror 函数返回 true 可以阻止执行默认事件处理函数（即控制台没有 error 打印出来）\nwindow.addEventListener error若为捕获阶段，则可额外捕获静态资源的加载错误。window.onerror则无法捕获静态资源的加载错误\n\nReact 中的异常白屏异常\nReact 处理阶段的同步代码报错，整个组件树挂了导致卸载掉，页面展示白屏\n\n\n生命周期函数报错\nrender 方法报错\n构造函数报错\n\n上述提到的是同步代码报错，异步代码的报错是不会产生页面白屏，只是会产生一些 console 中的 error。同理，因为事件回调函数的处理不是在 React 处理阶段（初始化或者事件处理setState驱动 react 进行下次渲染的），所以事件处理函数中的报错同样不会触发白屏\nError Boundary既然白屏问题如此严重，必须要有一种方式帮助开发者来感知 React 中的白屏问题。 于是 React16 就有了Error Boundary来用来捕获渲染时错误的概念，在 React 新增了两个生命周期componentDidCatch和static getDerivedStateFromError用于捕获渲染时的错误，也仅能捕获上面提到的白屏异常（如异步错误等也是没有办法被捕获到），也就是说如果我们在Error Boundary中捕获到错误并上报，这个错误通常是非常严重的。Error Boundary只可用于捕获子组件中发生的异常（自身出现渲染错误也是无法捕获的）\n\n无法捕获的异常\n\n\n\n事件处理\n\n\n\n异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）\n\n\n\n服务端渲染\n\n\n\n它自身抛出来的错误（并非它的子组件）\n\n\ncomponentDidCatch\n\n用于出错时去执行的副作用代码，比如错误上报、错误兜底等\n\nstatic getDerivedStateFromError\n\n在出错后触发，改函数返回的值能进行 setState 更新，触发一次重新 render 来渲染错误时的 fallback 组件。如果这次渲染仍然出现渲染错误，页面仍然会白屏，而不是执行类似 render error -&gt; getDerivedStateFromError -&gt; render error 这样的死循环\nclass Demo extends Component &#123;    state = &#123;        error: false    &#125;    static getDerivedStateFromError()&#123;        return &#123;            error: true        &#125;    &#125;    componentDidCatch(error, info)&#123;        this.setState(&#123;            error: true        &#125;)    &#125;    render() &#123;        if (this.state.error) &#123;            return &lt;div&gt;error&lt;/div&gt;        &#125;        // Child中发生渲染错误        return &lt;div&gt;            &lt;Child/&gt;        &lt;/div&gt;    &#125;&#125;\n\n`\n\nstatic getDerivedStateFromError渲染阶段调用的，所以不允许出现副作用\ncomponentDidCatch【commit】阶段被调用，所以允许出现副作用\n\n目前 React 的 Error Boundary 提供的两个生命周期只存在于 class 组件；并没有相应的 hooks 能实现类似的功能\n\nThere are no Hook equivalents to the uncommon getSnapshotBeforeUpdate, getDerivedStateFromError and componentDidCatch lifecycles yet, but we plan to add them soon.\n\n但是有一个比较有趣的是，Preact 提供了相应的 hook useErrorBoundary去实现 Error Boundary。preact 中的useErrorBoundary的功能和getDerivedStateFromError、componentDidCatch是一模一样的\n// error = The error that was caught or `undefined` if nothing errored.// resetError = Call this function to mark an error as resolved. It&#x27;s//   up to your app to decide what that means and if it is possible//   to recover from errors.const [error, resetError] = useErrorBoundary();\n\n用法也是非常简单，子组件触发异常会触发函数组件的 render 并且 error 是对应的错误信息，并且还提供了对应的 resetError 去重置错误。至于为何 Preact 能先于 React 支持功能，原因在于对于 Preact 的实现来说，它的函数组件和 class 组件都是实例化成一样的实例，函数组件的 hook 中直接定义componentDidCatch进行处理，componentDidCatch 捕获到错误后通过setState设置错误对象驱动下一次的 render 来拯救白屏\nexport function useErrorBoundary(cb) &#123;    const state = getHookState(currentIndex++, 10);    const errState = useState();    state._value = cb;    if (!currentComponent.componentDidCatch) &#123;        currentComponent.componentDidCatch = err =&gt; &#123;            if (state._value) state._value(err);            errState[1](err);        &#125;;    &#125;    return [        errState[0],        () =&gt; &#123;            errState[1](undefined);        &#125;    ];&#125;\n\n虽然这是一个 react 的 Error Boundary 只存在于 class 组件，但是对于子组件是函数组件的情况下，相关 hooks 的异常（useEffect、useLayoutEffect）一样是能捕获到的\n实践这么基础常用的 error-boundary 通常来说不需要我们手动去搞。开源社区已经有了成熟的封装解决方案react-error-boundary。它基于 React 提供的 error boundary 能力提供了开箱即用的功能，使用的时候只需要将我们的组件作为ErrorBoundary的子组件传入即可，并且 ErrorBoundary 还提供 FallbackComponent 属性供出错时渲染 fallback 内容、错误恢复等许多更进阶的功能。并且也提供了 HOC 的方式供使用\nError Boundary 包子组件import &#123;ErrorBoundary&#125; from &#x27;react-error-boundary&#x27;function ErrorFallback(&#123;error, resetErrorBoundary&#125;) &#123;  return (    &lt;div role=&quot;alert&quot;&gt;      &lt;p&gt;Something went wrong:&lt;/p&gt;      &lt;pre&gt;&#123;error.message&#125;&lt;/pre&gt;      &lt;button onClick=&#123;resetErrorBoundary&#125;&gt;Try again&lt;/button&gt;    &lt;/div&gt;  )&#125;  const ui = (  &lt;ErrorBoundary    FallbackComponent=&#123;ErrorFallback&#125;  &gt;    &lt;ComponentThatMayError /&gt;  &lt;/ErrorBoundary&gt;)\n\n高阶组件import &#123;withErrorBoundary&#125; from &#x27;react-error-boundary&#x27;const ComponentWithErrorBoundary = withErrorBoundary(ComponentThatMayError, &#123;  FallbackComponent: ErrorBoundaryFallbackComponent,  onError(error, info) &#123;    // Do something with the error    // E.g. log to an error logging client here  &#125;,&#125;)// or@withErrorBoundary(&#123;  FallbackComponent: ErrorBoundaryFallbackComponent,  onError(error, info) &#123;    // Do something with the error    // E.g. log to an error logging client here  &#125;,&#125;)class ComponentThatMayError extends Component &#123;&#125;const ui = &lt;ComponentWithErrorBoundary /&gt;\n\n在需要使用的地方对我们的组件进行一层包装即可。这时候可能会一种需求，手动包一层太麻烦了，为啥 react 不提供一个配置字段每个组件自带 error boundary 呢？\n万能的开源社区也有人通过 babel 插件实现了这个能力babel-plugin-transform-react-error-boundary\n&#123;    test: /.jsx?$/,    exclude: /node_modules/,    use: &#123;        loader: &#x27;babel-loader&#x27;,        options: &#123;            plugins: [                [ &#x27;babel-plugin-transform-react-error-boundary&#x27;, &#123;                    ErrorBoundary: &#x27;common/components/ErrorBoundary/index.js&#x27;                &#125; ]            ]        &#125;    &#125;&#125;\n\n通过配置一个自定义的 Error Boundary 路径，即可实现所有的组件包一个 ErrorBoundary 了，再结合react-error-boundary一顿操作，页面再也不会白屏了。具体实现就是通过 babel 实现以下这样的转换\nclass TestComponent extends React.Component &#123;    render() &#123;        return &lt;div /&gt;;    &#125;&#125;// 转换const ErrorBoundary = require(&#x27;./path/to/my/ErrorBoundary.js&#x27;);class TestComponent extends React.Component &#123;    render() &#123;        return &lt;ErrorBoundary&gt;&#123;this.__r__()&#125;&lt;/ErrorBoundary&gt;;    &#125;    __r__) &#123;        return &lt;div /&gt;;    &#125;&#125;\n\n上面提到 Error boundaries是不支持 ssr 场景的，所以又有人做了一个针对 ssr 的 babel 插件\nbabel-plugin-transform-react-ssr-try-catch。 通过对 render 函数进行 trycatch 实现类似的功能\n&#123;    &quot;plugins&quot;: [        [&quot;react-ssr-try-catch&quot;, &#123;            // global errorHandler            &quot;errorHandler&quot;: &quot;./path/to/my/SSRErrorHandler.js&quot;,            // component error render method            &quot;errorRenderMethod&quot;: &quot;renderErrorState&quot;,        &#125;]    ]&#125;\n\nclass MyCompoenent extends React.PureComponent &#123;  render() &#123;    return &lt;div/&gt;;  &#125;&#125;// 转换const ReactSSRErrorHandler = require(&#x27;./path/to/my/SSRErrorHandler.js&#x27;);class MyCompoenent extends React.PureComponent &#123;  render() &#123;      try &#123;          return this.__originalRenderMethod__();      &#125; catch (e) &#123;          return ReactSSRErrorHandler(e, this.constructor.name, this);      &#125;  &#125;  __originalRenderMethod__() &#123;      return &lt;div /&gt;;  &#125;&#125;\n\n实现更多的功能Error Boundary 除了用于捕获错误，这个特性也可以用来实现 React Suspense 相关的功能\n\n Suspense + Lazy\n\n// 用法const ProfilePage = lazy(() =&gt; import(&#x27;./ProfilePage&#x27;));&lt;Suspense fallback=&#123;&lt;Spinner /&gt;&#125;&gt;  &lt;ProfilePage /&gt;&lt;/Suspense&gt;\n\n// 最简化实现Lazy + Suspensefunction lazy(loader) &#123;    let prom;    let component;    let error;    function Lazy(props) &#123;        if (!prom) &#123;            prom = loader();            prom.then(                exports =&gt; &#123;                    component = exports.default || exports;                &#125;,                e =&gt; &#123;                    error = e;                &#125;            );        &#125;        if (error) &#123;            throw error;        &#125;        // Lazy组件的render中，若组件未加载完成，抛出一个promise异常供Suspense的componentDidCatch捕获        if (!component) &#123;            throw prom;        &#125;        return createElement(component, props);    &#125;    return Lazy;&#125;export class Suspense extends React.Component &#123;    state = &#123;        isLoading: false    &#125;;    componentDidCatch(error) &#123;        if (this._mounted) &#123;            if (typeof error.then === &#x27;function&#x27;) &#123;                this.setState(&#123; isLoading: true &#125;);                error.then(() =&gt; &#123;                    if (this._mounted) &#123;                        this.setState(&#123; isLoading: false &#125;)                    &#125;                &#125;);            &#125;        &#125;    &#125;    componentDidMount() &#123;        this._mounted = true;    &#125;    componentWillUnmount() &#123;        this._mounted = false;    &#125;    render() &#123;        const &#123; children, fallback &#125; = this.props;        const &#123; isLoading &#125; = this.state;        return isLoading ? fallback : children;    &#125;&#125;\n\n\n Suspense + render 中的【同步】数据获取\n\nconst fetchApi = () =&gt; &#123;   // 异步api    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&quot;数据&quot;);        &#125;, 3000);    &#125;);&#125;const useData = () =&gt; &#123;    const [data,setData] = useState()    useEffect(() =&gt; &#123;        fetchApi().then((x) =&gt; setData(x))    &#125;,[])    return data&#125;const ProfilePage = () =&gt; &#123;   const data = useData()    if (!data) &#123;        return &lt;Loading/&gt;    &#125;   return &lt;div&gt;&#123;data&#125;&lt;/div&gt;&#125;\n\nconst fetchApi = () =&gt; &#123;   // 异步api    return new Promise((resolve, reject) =&gt; &#123;        setTimeout(() =&gt; &#123;            resolve(&quot;数据&quot;);        &#125;, 3000);    &#125;);&#125;const getData = createFetcher(fetchApi);const ProfilePage = () =&gt; &#123;   const data = getData()   return &lt;div&gt;&#123;data&#125;&lt;/div&gt;&#125;const Demo = () =&gt; &#123;    return &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;        &lt;ProfilePage /&gt;    &lt;/Suspense&gt;&#125;\n\nvar cached = &#123;&#125;;export const createFetcher = (promiseTask) =&gt; &#123;    let ref = cached;    return () =&gt; &#123;        if (ref !== cached) &#123;            return ref        &#125;        const task = promiseTask();        task.then(res =&gt; &#123;            ref = res        &#125;);        if (ref === cached) &#123;            throw task        &#125;    &#125;&#125;\n\nVue 中的异常vue 提供了 4 个异常处理的 API，分别是 errorHandler，errorCaptured，renderError，warnHandler。\nerrorHandler我们最常用的是全局配置中注册的 errorHandler，例如异常上报场景，可用如下代码：\nVue.config.errorHandler = function (error, vm, info) &#123;    window.Slardar &amp;&amp; window.Slardar(&#x27;Sentry&#x27;, (Sentry) =&gt; &#123;      Sentry.captureMessage(error);    &#125;);&#125;\n\nerrorHandler 可以捕获 render（vue 模板）、生命周期钩子、watch 回调、methods 方法等函数内的同步代码异常，info 参数会接收到报错函数类型（render/mounted/…）；如果这些函数返回 promise ，则 promise 异常也会被捕获；\nerrorCapturederrorCaptured 入参和 errorHandler 一样，它是 vue 组件的钩子函数，作用是捕获来自后代组件（注意不包含本组件）的错误。 vue 中的错误传播规则可以总结为，从子到父传播，依次触发各组件的 errorCaptured 钩子，若某 errorCaptured 返回 false，则停止传播，否则最终会传播到全局的 errorHandler ；\n使用场景：我们可以在组件库等场景使用 errorCaptured，捕获内部异常并上报，从而避免和业务代码报错混淆；\nrenderErrorrenderError 只在开发者环境下工作，当 render 函数报错时，其错误将会作为第二个参数传递到 renderError，renderError 返回的 vnode 将会被渲染。\nnew Vue(&#123;  render (h) &#123;    throw new Error(&#x27;oops&#x27;)  &#125;,  renderError (h, err) &#123;    return h(&#x27;pre&#x27;, &#123; style: &#123; color: &#x27;red&#x27; &#125;&#125;, err.stack)  &#125;&#125;).$mount(&#x27;#app&#x27;)\n\n使用场景：renderError可用于开发环节实时把组件错误渲染到页面；\nwarnHandlerwarnHandler 和 errorHandler一样是全局配置项，但 warnHandler 只在开发者环境下生效，用于捕获 vue 告警。\nVue.config.warnHandler = function (msg, vm, trace) &#123;  // `trace` 是组件的继承关系追踪&#125;\n\n使用场景：一般情况下开发者直接在控制台查看 warn，所以 warnHandler 使用场景非常有限。\n参考React，优雅的捕获异常 - 掘金\n精读《React Error Boundaries》\nReact：Suspense 的实现与探讨\n\n","categories":["react 原生"],"tags":["react 原生"]},{"title":"在ES模块中的使用 __dirname","url":"/%E5%9C%A8ES%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%20__dirname%20.html","content":"\n\n\n前言ECMAScript 模块是 JavaScript 的新标准格式。在 Node.js 中越来越多的库逐渐从从 CommonJS 转移到 ES 模块\n\n注：这里是指“真”ES 模块并不是指代码中 Node.js 中使用 import 写法但是实际被 tsc 转成 commonJS 的形式\n\n但是 Node.js ES 开发中此前有一个棘手的问题是获取当前文件目录、路径。不过这个问题在最近也已经解决\n结论在 ES 模块中，现在可以使用以下方式而不是使用__dirname或__filename\nimport.meta.dirname  // 当前模块的目录名 (__dirname)import.meta.filename //当前模块文件名 (__filename)\n\n获取当前目录通过访问当前模块的目录路径，可以相对于代码所在位置遍历文件系统并在项目中读取或写入文件，或动态导入代码。相关的使用方式随着时间的推移而发生了一些变化，从 CommonJS 的实现到最新的 ES 模块更新\n旧的 CommonJS 方式Node.js 最初使用 CommonJS 模块系统。CommonJS 提供了两个变量，返回当前模块的目录名称和文件名称，分别是__dirname和__filename\n__dirname  // 当前模块所在的目录__filename // 当前模块文件名\n\n旧的 ES 模块方式__dirname和__filename在 ES 模块中不可用。需要使用以下代码来实现获取\nimport * as url from &#x27;url&#x27;;const __dirname = url.fileURLToPath(new URL(&#x27;.&#x27;, import.meta.url));const __filename = url.fileURLToPath(import.meta.url);\n\n\n最新的 ES 模块方式最终在经过许多讨论后，现在有了更好的方法。自从Node.js20.11.0和Deno 1.40.0和Bun 1.0.23之后可以调用import.meta对象的dirname和filename属性来获取了\nimport.meta.dirname // 当前模块所在的目录import.meta.filename// 当前模块文件名\n\n为什么需要一个新的 APIES 模块是 JavaScript 的标准。然而 JavaScript 最初是作为在 Web 浏览器中运行的语言而诞生的。Node.js 流行起来后开始在服务器上运行 JavaScript，但必须使用一些约定来加载模块，Node.js 项目早期做出的一个选择是采用 CommonJS 模块系统及其相关内容\nES 模块是为浏览器和服务器环境设计的。浏览器通常没有文件系统访问权限，因此提供对当前目录或文件名的访问是没有意义。然而对于浏览器处理 URL，可以使用file://scheme以 URL 格式提供文件路径。因此，ES 模块具有对模块的 URL 的引用。即import.meta.url。可以看看在 Node.js 中可以使用 URL 的相关使用\n假设一个名为module.js的 ES 模块包含以下代码：\nconsole.log(import.meta.url);\n\n如果使用 Node.js 的服务器上运行此文件，则会得到以下结果：\n$ node module.jsfile:///path/to/module.js\n\n如果 Web 浏览器中加载 module.js，则会得到以下结果：\nhttps://example.com/module.js\n\n基于不同上下文会有不同的结果\nimport.meta.url是一个描述 URL 的字符串，而不是一个 URL 对象。可以通过将该字符串传递给URL构造函数将其转换为真正的 URL 对象：\nconst fileUrl = new URL(import.meta.url);console.log(url.protocol);// Node.js: &quot;file:&quot;// Browser: &quot;https:&quot;\n\n使用 URL 对象，可以使用 Node.js 的 URL 模块将模块的 URL 转换为文件路径，等价于 __filename\nimport * as url from &quot;url&quot;;const fileUrl = new URL(import.meta.url);const filePath = url.fileURLToPath(fileUrl);console.log(filePath);// /path/to/module.js\n\n也可以操作 URL 来获取目录名，等价于__dirname\nimport * as url from &quot;url&quot;;const directoryUrl = new URL(&quot;.&quot;, import.meta.url);const directoryPath = url.fileURLToPath(directoryUrl);console.log(directoryPath);// /path/to\n\n使用 URL 而不是字符串大多数的代码可能都是需要使用路径字符串来在 Node.js 中执行常见的文件操作。但其实许多在字符串路径上工作的 Node.js API 也可以使用URL对象\n__dirname 最常见的用途是遍历目录以查找要加载的数据文件。例如，如果 module.js 文件与名为 data.json 的文件位于同一目录中，并且想将数据加载到脚本中，则以前会像这样使用 __dirname\nconst &#123; join &#125; = require(&quot;node:path&quot;);const &#123; readFile &#125; = require(&quot;node:fs/promises&quot;);function readData() &#123;  const filePath = join(__dirname, &quot;data.json&quot;);  return readFile(filePath, &#123; encoding: &quot;utf8&quot; &#125;);&#125;&#125;\n\n在 ES 模块中可以直接使用import.meta.dirname\nimport &#123; join &#125; from &quot;node:path&quot;;import &#123; readFile &#125; from &quot;node:fs/promises&quot;;function readData() &#123;  const filePath = join(import.meta.dirname, &quot;data.json&quot;);  return readFile(filePath, &#123; encoding: &quot;utf8&quot; &#125;);&#125;\n\n但是也可以像如下使用 URL 对象：\nimport &#123; readFile &#125; from &quot;node:fs/promises&quot;;function readData() &#123;  const fileUrl = new URL(&quot;data.json&quot;, import.meta.url);  return readFile(fileUrl, &#123; encoding: &quot;utf8&quot; &#125;);&#125;\n\n由于 ES 模块为客户端和服务器编写的 JavaScript 带来了一致性，因此使用 URL 对象而不是路径字符串也可以实现相同的效果。更多关于替代__dirname可以参考\n如何找到 import.meta.dirnameimport.meta.dirname和import.meta.filename可以在最新版本的 Node.js、Deno 和 Bun 中使用\nBun 已经提前实现了import.meta.dir和import.meta.pat，它们是等效的，所以dirname和filename在 bun 其实是dir和path的别名\n由于这个属性仅涉及基础文件系统，因此仅在import.meta.url的 scheme 为file:时可用。也就是说在浏览器环境中不可用；在浏览器中尝试使用import.meta.dirname将仅返回 undefined\n参考__dirname is back in Node.js with ES modules\n\n","categories":["node"],"tags":["node"]},{"title":"如何实现一个惊艳面试官的非递归版本的 js 对象深拷贝方法","url":"/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E6%83%8A%E8%89%B3%E9%9D%A2%E8%AF%95%E5%AE%98%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%89%88%E6%9C%AC%E7%9A%84%20js%20%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%96%B9%E6%B3%95.html","content":"\n\n\n\n众所周知，js 语言本身是不提供对象的深拷贝的功能，无论是直接赋值、Object.assign、展开运算符...都只是浅拷贝，关于 js 的深浅拷贝的一些概念可以参考我比较久以前写过的一篇文章\n\n关于如何实现深拷贝，网上有很多相关的文章和实现都非常完美，本文主要讲述的是用一种非常规的使用非递归方法实现深拷贝\n\n本文的深拷贝只考虑数组、对象、简单值三种数据类型\n\n要实现判断数据类型，先来实现这 3 个判断类型的工具方法。最通用的就是利用Object.prototype.toString的特性\nconst getType = v =&gt; &#123;    switch (Object.prototype.toString.call(v)) &#123;        case &quot;[object Object]&quot;:            return &quot;Object&quot;;        case &quot;[object Array]&quot;:            return &quot;Array&quot;;        default:            // 只考虑数组和对象，其余都是简单值            return false;    &#125;&#125;;\n\n递归实现在讲述非递归实现之前，先看看递归版本的深拷贝实现，很简单，直接上代码\nconst copy = source =&gt; &#123;    const _cp = source =&gt; &#123;        let dest;        const type = getType(source);        if (type === &quot;Array&quot;) &#123;            dest = [];            source.forEach((item, index) =&gt; &#123;                dest[index] = _cp(item);            &#125;);            return dest;        &#125; else if (type === &quot;Object&quot;) &#123;            dest = &#123;&#125;;            for (let [k, v] of Object.entries(source)) &#123;                dest[k] = _cp(v);            &#125;            return dest;        &#125; else &#123;            return source;        &#125;    &#125;;    return _cp(source);&#125;;\n\n当然，这种是处理不了循环引用的。处理循环引用也很简单，用个WeakMap记录遍历过的值，每次拷贝前查出WeakMap中存在这个值，就直接返回。所以加上处理循环引用后的代码如下\nconst copy = (source) =&gt; &#123;    const map = new WeakMap();    const _cp = (source) =&gt; &#123;        let dest;        if (map.get(source)) &#123;            return map.get(source);        &#125;        const type = getType(source);        if (type === &quot;Array&quot;) &#123;            // 数组            dest = [];            map.set(source, dest);            source.forEach((item, index) =&gt; &#123;                dest[index] = _cp(item);            &#125;);            return dest;        &#125; else if (type === &quot;Object&quot;) &#123;            // obj            dest = &#123;&#125;;            map.set(source, dest);            for (let [k, v] of Object.entries(source)) &#123;                dest[k] = _cp(v);            &#125;            return dest;        &#125; else &#123;            return source;        &#125;    &#125;;    return _cp(source);&#125;;\n\n非递归实现其实几乎所有的函数递归，都可以使用非递归的方法实现。如果大家有使用 javascript 刷 leetcode 的经历，很多时候如果我们的代码使用递归去解决问题，没有进行尾调用优化（很多时候有的题目确实写不出尾调用优化的写法，也可能我太菜）的时候，是很容易出现 js 调用栈过深出错的情形，这个时候切回成非递归写法就可以，而且很简单\n我们简单先了解下 j s 递归的本质。j s 全局是有一个函数调用栈，当我们调用一个函数 a 时，这个函数 a 入栈，函数 a 内再次调用 a 时，一个新的函数 a 再次入栈。执行完毕依次弹出栈。多个函数的话也是类似的流程。用非递归解法的本质就是使用队列或者栈的数据结构来模拟 js 调用栈的执行过程\n伪代码如下，百分之 99 的递归都可以用如下的思想实现非递归\n\n声明一个stack变量模拟调用栈\n  const stack = [];\n\n\n初始参数入栈\n  stack.push(&#123; param1, param2 &#125;);\n\n\n栈非空，就一直取栈元素执行\n  while (stack.length) &#123;    const item = stack.pop();    //.......&#125;\n如果需要继续下一次递归，将下一次递归调用的参数重新入栈\n  while(stack.length) &#123;\tconst item = stack.pop()  //继续下一次递归  //  每次递归的执行流程  .....  if (condition) &#123;    stack.push(&#123;&#123;param1:nextParam1,param2:nextParam2&#125;&#125;)  &#125; else &#123;    ....  &#125;&#125;\n当前递归终止条件，不入栈即可\n  while(stack.length) &#123;\tconst item = stack.pop()  //继续下一次递归  //  每次递归的执行流程  .....  if (condition) &#123;  //...  &#125; else &#123;    //  递归终止条件。不入栈了  &#125;&#125;\n\n看完这里可能会有疑问，如果每次的递归调用，本次的结果需要是下一次递归的返回值怎么办呢。例如我们上面递归实现的深拷贝\ndest[index] = _cp(item);\n\n其实很好理解，递归的时候，当我们的下一级递归返回的时候，我们还能赋值说明在递归场景下，下一级返回后，我们当前级的执行变量还都在我们直接执行就可以，但是非递归情形下当前迭代执行完，是没有上一级的变量的了。这里就需要在每次迭代下一次的时候多传递一个指向当前迭代中需要获取下级结果的变量。（其实就是在递归场景中，下一级递归返回值的设置是在上一级中；非递归场景中，下一级的返回值，是在下一级中调用处理，很类似我们平时传递了一个回调函数的形式）\nwhile(stack.length) &#123;\tconst item = stack.pop()  //继续下一次递归  //  每次递归的执行流程  .....  // 上一级传递的dest  //  dest[xx] = xxx  if (condition) &#123;    // 注意dest    stack.push(&#123;&#123;param1:nextParam1,param2:nextParam2,dest: &#123;&#125;&#125;&#125;)  &#125; else &#123;    ....  &#125;&#125;\n\n理解到这里，相信大家都知道将类似递归深拷贝转化成非递归实现的大致思路了，其实就是将一个对象，一级一级往下拆分key、value的形式进行处理。下面是详细分析\n\n首先，深拷贝是接收一个value然后返回一个拷贝值，所以需要一开始建立一个拷贝值的引用。在迭代的过程中，我们每一级都是对这个引用的子部分进行处理\n  const copy = source =&gt; &#123;    // 简单值直接返回    if (!getType(source)) &#123;        return source;    &#125;    // 建立这个最终返回的深拷贝值的本体    let dest = Array.isArray(source) ? [] : &#123;&#125;;    //.....&#125;;\n进行上面提到的模拟调用栈的过程。在递归版本中，我们知道递归函数的入参其实就是这次访问的子节点的值，返回值是当前子节点的拷贝值。前面分析过，迭代调用我们需要传递上一级的创建的引用值进来设置。所以我们迭代调用，每次也有两个值，一个是当前访问节点的原值（和递归调用一样）、用于存储拷贝的引用值（在上一级迭代中创建的）\n  // 调用栈初始状态const queue = [&#123; source, dest &#125;];while (queue.length) &#123;    // source 当前访问的节点    // dest 用于存储拷贝的引用值    const &#123; dest, source &#125; = queue.shift();    // 判断访问节点类型    const type = getType(source);    //&#125;\n每次的迭代处理流程  这里是需要分情况讨论\n\n访问节点是数组\n  if (type === &quot;Array&quot;) &#123;    // ....    source.forEach((x, index) =&gt; &#123;        const xType = getType(x);    &#125;);&#125;\n\n\n\n- 数组项是对象 (1)\n\n  if (xType === &quot;Object&quot;) &#123;   // 生成一个对象引用，给下一次迭代的时候用            dest[index] = &#123;&#125;;   // 入栈，需要下一次迭代            queue.push(&#123;                source: x,                dest: dest[index]            &#125;);            return;        &#125;\n\n\n\n- 数组项是数组(2)\n\n  if (xType === &quot;Array&quot;) &#123;  // 生成一个数组引用，给下一次迭代的时候用    dest[index] = [];  // 入栈，需要下一次迭代    queue.push(&#123;        source: x,        dest: dest[index]    &#125;);    return;&#125;\n\n\n\n- 数组项是简单值。直接设置这个值到dest上\n\n  if (!getType(x)) &#123;      dest[index] = x;     return;              &#125;\n\n\n访问节点是对象。类似于数组处理\n\n  对象键是对象\n  对象键是数组\n  对象键是简单值\n\n\n\n再加上循环引用处理也非常简单，每次迭代的最后将当前source添加到WeakMap中。在每次进行处理对象类型的stack.push的时候判断push的source是否在WeakMap中就可以了，若在WeakMap中说明是循环引用，直接设置值，不进行push\nwhile (stack.lenght) &#123;    //....     if (xType === &quot;Object&quot;) &#123;                    if (map.get(x)) &#123;                        dest[index] = map.get(x);                        return;                    &#125;                    dest[index] = &#123;&#125;;                    queue.push(&#123;                        source: x,                        dest: dest[index],                    &#125;);                    map.set(x, dest[index]);                    return;                &#125;    //....&#125;\n\n最终我们的非递归版本的深拷贝就完成了。虽然花了一些力气，实现这个拷贝，代码也比递归版本复杂很多，性能可能也更差，但是如果能重头看到尾，并且自己实现一遍，相信会大大加深自己对深拷贝的理解和函数递归思想的的理解。下一次面试官让你写深拷贝的时候，你写一个非递归版本的，一定会大大惊艳面试官！\n完整代码如下\nconst copy2 = (source) =&gt; &#123;    if (!getType(source)) &#123;        // 简单值        return source;    &#125;    let dest = Array.isArray(source) ? [] : &#123;&#125;;    const queue = [&#123; source, dest &#125;];    const map = new WeakMap();    while (queue.length) &#123;        const &#123; dest, source &#125; = queue.shift();        const type = getType(source);        if (type === &quot;Array&quot;) &#123;            // 数组            source.forEach((x, index) =&gt; &#123;                const xType = getType(x);                if (!getType(x)) &#123;                    dest[index] = x;                    return;                &#125;                if (xType === &quot;Array&quot;) &#123;                    dest[index] = [];                    queue.push(&#123;                        source: x,                        dest: dest[index],                    &#125;);                    return;                &#125;                if (xType === &quot;Object&quot;) &#123;                    if (map.get(x)) &#123;                        dest[index] = map.get(x);                        return;                    &#125;                    dest[index] = &#123;&#125;;                    queue.push(&#123;                        source: x,                        dest: dest[index],                    &#125;);                    map.set(x, dest[index]);                    return;                &#125;            &#125;);        &#125; else &#123;            // 对象            for (let [k, v] of Object.entries(source)) &#123;                const vType = getType(v);                if (!vType) &#123;                    dest[k] = v;                    continue;                &#125;                if (vType === &quot;Array&quot;) &#123;                    dest[k] = [];                    queue.push(&#123;                        source: v,                        dest: dest[k],                    &#125;);                &#125;                if (vType === &quot;Object&quot;) &#123;                    if (map.get(v)) &#123;                        dest[k] = map.get(v);                        continue;                    &#125;                    dest[k] = &#123;&#125;;                    queue.push(&#123;                        source: v,                        dest: dest[k],                    &#125;);                &#125;                map.set(v, dest[k]);            &#125;        &#125;    &#125;    return dest;&#125;;\n\n码字不易，如果觉得不错，求给个 star 或者赞吧！\n","categories":["原生"],"tags":["原生"]},{"title":"如何将Node.js库转换到Deno","url":"/%E5%A6%82%E4%BD%95%E5%B0%86Node.js%E5%BA%93%E8%BD%AC%E6%8D%A2%E5%88%B0Deno.html","content":"\n\n由于Node和Deno的一些差异，一个库要想同时支持Node和Deno是需要一些改造的\n\n本文翻译自EdgeDb博客：https://www.edgedb.com/blog/how-we-converted-our-node-js-library-to-deno-using-deno如果需要将Deno项目直接迁移为Node项目可参考笔者另一篇文章deno 初体验，实战记录一个node项目迁移到deno需要做什么\n\n\nDeno是一个新的JavaScript运行时，无需编译即原生支持TypeScript。它是由Node.js作者Ryan Dahl创建的，为了解决Node的一些基本设计、安全漏洞问题并集成了当前的一些开发实践如ES Module和TypeScript\n在EdgeDb中，我们建立和维护了一个官方的npm上的Node.js客户端。然而，Deno使用了一套完全不同的实践来处理依赖，即直接从公共包库(如deno.land/x)import路径。我们将寻找一种简单的方法来Deno化我们的代码库。也就是用最简单的重构从现有的Node.js实现中生成一个Deno兼容的模块。这解决维护和同步两个几乎相同的代码库的重复工作带来的问题\n我们采用了一种“运行时适配器”模式。这是一种通用的解决方法对其他希望支持Deno库的作者也会有用\nNode.js vs DenoNode.js和Deno有一些重要的区别\n\nTypeScript支持：Deno可以直接执行TypeScript而Node.js只能运行JavaScript代码\n\n模块解析：默认情况下，Node.js使用CommonJS导入模块并使用require/module.exports语法。它也有一个复杂的解析算法，会从node_modules加载像react这样的普通模块名，并在无额外扩展名导入时尝试添加.js或.json。如果导入路径是一个目录，则导入index.js文件\n\n\nDeno模块解析逻辑简化了很多。它使用了ECMAScript模块语法进行导入和导出。该语法也被TypeScript使用。所有导入必须是有显式文件扩展名的相对路径或者是一个URL\n这意味着不存在像npm或yarn那样有node_module或包管理器。外部模块可以通过URL直接从公开代码库导入，比如deno.land/x或GitHub\n\n标准库：Node.js有一些内置的标准模块如fs、crypto、http。这些包名由Node.js保留。相比之下Deno标准库是通过https://deno.land/std/URL导入的。Node和Deno标准库的功能也不同，Deno放弃了一些旧的或过时的Node.js api，引入了一个新的标准库(受Go的启发)，并统一支持现代JavaScript特性如Promise(而许多Node.js api仍然使用老的回调风格)\n\n内置全局变量：Deno所有的核心api都在全局变量Deno中，其它全局变量则只有标准的web api。和Node.js不同的是，Deno没有Buffer或process这些全局变量\n\n\n所以需要如何做才能让我们的Node.js库尽可能容易地在Deno中运行呢？下面将一步一步进行改造\nTypeScript和模块语法幸运的是，我们无需考虑将CommonJS的require/module.exports语法转换到到ESMimport/export。我们使用用TypeScript编写edgedb-js，它已经使用了ESM语法。在编译过程中，tsc将我们的文件转换成普通的=CommonJS语法的JavaScript文件。Node.js可以直接运行编译后的文件\n本文下面将讨论如何将TypeScript源文件修改为Deno可以直接使用的格式\n依赖edgedb-js没有任何第三方依赖，所以这里不必担心任何三方库的Deno兼容性问题。但仍需要将所有从Node.js标准库中导入(例如path、fs等)替换为等价的Deno文件\n\n注意：如果你的包确实依赖于外部包，可在deno.land/x中查看是否有Deno版本\n\n由于Deno标准库提供了Node.js兼容模块，这个改造比较简单。Deno的标准库上提供了一个包装器并尽可能和Node的api保持一致\n- import * as crypto from &quot;crypto&quot;;+ import * as crypto from &quot;https://deno.land/std@0.114.0/node/crypto.ts&quot;;\n\n为了简化问题，将所有Node.js api导入移到一个名为adapter.node.ts的文件中，并只重新导出我们需要的功能\n// adapter.node.tsimport * as path from &quot;path&quot;;import * as util from &quot;util&quot;;import * as crypto from &quot;crypto&quot;;export &#123;path, net, crypto&#125;;\n\n然后在一个名为adapter.deno.ts的文件中为Deno实现相同的适配器\n// adapter.deno.tsimport * as crypto from &quot;https://deno.land/std@0.114.0/node/crypto.ts&quot;;import path from &quot;https://deno.land/std@0.114.0/node/path.ts&quot;;import util from &quot;https://deno.land/std@0.114.0/node/util.ts&quot;;export &#123;path, util, crypto&#125;;\n\n当需要使用Node.js的特定功能时，直接从adapter.node.ts导入这些功能。通过这种方式，可以通过简单地将所有adapter.node.ts导入重写为adapter.deno.ts即可使edgedb-js兼容Deno。只要确保这些文件重新导出相同的功能就能符合预期\n但实际上应该如何重写这些导入呢。这里我们需要开发一个简单的codemod脚本。下面将使用Deno来开发这个脚本\n开发Deno-ifier在开发之前，列举下需要做的事情：\n\n将Node.js风格的导入重写为更显式的Deno风格。包括添加.ts扩展名和目录导入添加/index.ts\n\n将adapter.node.ts的导入替换成从adapter.deno.ts的导入\n\n注入Node.js全局变量（如process和Buffer）到Deno的代码中。虽然可以简单地从适配器导出这些变量，但我们必须重构Node.js文件以显式地导入它们。为了简化处理，将检测代码中使用了Node.js全局变量的时候注入一个导入\n\n将src目录重命名为_src，表示它只被edgedb-js内部使用不应该被外部直接导入使用\n\n将主入口文件src/index.ts移动到项目根目录并重命名为mod.ts。这是Deno中的习惯用法（这里index.node.ts的命名并不表明它是只能给Node.js使用而是用来区别于index.browser.ts，index.browser.ts导出的是edgedb-js中浏览器兼容的部分代码）\n\n\n获取所有文件列表第一步先获取出源文件。Deno原生fs模块提供了walk函数可以实现：\nimport &#123;walk&#125; from &quot;https://deno.land/std@0.114.0/fs/mod.ts&quot;;const sourceDir = &quot;./src&quot;;for await (const entry of walk(sourceDir, &#123;includeDirs: false&#125;)) &#123;  // 遍历源文件&#125;\n\n注意：这里使用的是Deno原生的std/fs模块而不是Node兼容版本的std/node/fs\n\n声明一个重写规则集合并初始化一个Map对象表示源文件路径到需要重写的目标文件的路径\nconst sourceDir = &quot;./src&quot;;const destDir = &quot;./edgedb-deno&quot;;const pathRewriteRules = [  &#123;match: /^src\\/index.node.ts$/, replace: &quot;mod.ts&quot;&#125;,  &#123;match: /^src\\//, replace: &quot;_src/&quot;&#125;,];const sourceFilePathMap = new Map&lt;string, string&gt;();for await (const entry of walk(sourceDir, &#123;includeDirs: false&#125;)) &#123;  const sourcePath = entry.path;  sourceFilePathMap.set(sourcePath, resolveDestPath(sourcePath));&#125;function resolveDestPath(sourcePath: string) &#123;  let destPath = sourcePath;  // 使用重写规则  for (const rule of pathRewriteRules) &#123;    destPath = destPath.replace(rule.match, rule.replace);  &#125;  return join(destDir, destPath);&#125;\n\n这非常简单，下面开始开发修改源代码部分\n重写import和export要重写导入路径需要知道它们在文件中的位置。我们将使用TypeScript的Compiler API来将源文件解析为抽象语法树并找到导入语句\n为了实现这个功能我们需要用到typescript NPM包的compile API。Deno的兼容模块提供了一个直接从CommonJS模块导入的方式。需要在执行Deno代码的时候使用--unstable标识，对于构建阶段这不是什么问题\nimport &#123;createRequire&#125; from &quot;https://deno.land/std@0.114.0/node/module.ts&quot;;const require = createRequire(import.meta.url);const ts = require(&quot;typescript&quot;);\n\n下面遍历文件并依次解析\nimport &#123;walk, ensureDir&#125; from &quot;https://deno.land/std@0.114.0/fs/mod.ts&quot;;import &#123;createRequire&#125; from &quot;https://deno.land/std@0.114.0/node/module.ts&quot;;const require = createRequire(import.meta.url);const ts = require(&quot;typescript&quot;);for (const [sourcePath, destPath] of sourceFilePathMap) &#123;  compileFileForDeno(sourcePath, destPath);&#125;async function compileFileForDeno(sourcePath: string, destPath: string) &#123;  const file = await Deno.readTextFile(sourcePath);  await ensureDir(dirname(destPath));  // 如果文件以&#x27;.deno.ts&#x27;结尾则直接复制无需修改  if (destPath.endsWith(&quot;.deno.ts&quot;)) return Deno.writeTextFile(destPath, file);  // 如果文件以`.node.ts`结尾则跳过  if (destPath.endsWith(&quot;.node.ts&quot;)) return;  // 使用typescript Compiler API解析源文件  const parsedSource = ts.createSourceFile(    basename(sourcePath),    file,    ts.ScriptTarget.Latest,    false,    ts.ScriptKind.TS  );&#125;\n\n对于每个AST，我们通过遍历顶层节点找出import和export语句。这里无需深层查找，因为import/export只会出现在顶级作用域（也无需处理动态import()，因为edgedb-js中也没有使用）\n从这些节点中，获取源文件中export/import路径的开始和结束偏移量。然后可以通过切片取代路径内容并插入修改后的路径来重写导入\nconst parsedSource = ts.createSourceFile(/*...*/);const rewrittenFile: string[] = [];let cursor = 0;parsedSource.forEachChild((node: any) =&gt; &#123;  if (    (node.kind === ts.SyntaxKind.ImportDeclaration ||      node.kind === ts.SyntaxKind.ExportDeclaration) &amp;&amp;    node.moduleSpecifier  ) &#123;    const pos = node.moduleSpecifier.pos + 2;    const end = node.moduleSpecifier.end - 1;    const importPath = file.slice(pos, end);    rewrittenFile.push(file.slice(cursor, pos));    cursor = end;    // 使用Deno版本的导入替换导入适配文件    let resolvedImportPath = resolveImportPath(importPath, sourcePath);    if (resolvedImportPath.endsWith(&quot;/adapter.node.ts&quot;)) &#123;      resolvedImportPath = resolvedImportPath.replace(        &quot;/adapter.node.ts&quot;,        &quot;/adapter.deno.ts&quot;      );    &#125;    rewrittenFile.push(resolvedImportPath);  &#125;&#125;);rewrittenFile.push(file.slice(cursor));\n这里的关键部分是resolveImportPath函数。它通过试错查找的方式实现将Node.js风格的引入转化为Deno风格的导入。首先检查路径是否对应于实际文件；如果失败了会尝试添加.ts；如果再失败则尝试添加/index.ts；如果再失败则抛出一个错误。\n注入Node.js全局变量最后一步是处理Node.js全局变量。首先在创建一个global.deno.ts文件。这个文件应该导出包中使用的所有Node.js全局变量的Deno兼容版本\n// global.deno.tsexport &#123;Buffer&#125; from &quot;https://deno.land/std@0.114.0/node/buffer.ts&quot;;export &#123;process&#125; from &quot;https://deno.land/std@0.114.0/node/process.ts&quot;;\n\n通过编译后的AST可以拿到源文件中所有全局变量的集合。将使用它在任何引用这些全局变量的文件中注入import语句\nconst sourceDir = &quot;./src&quot;;const destDir = &quot;./edgedb-deno&quot;;const pathRewriteRules = [  &#123;match: /^src\\/index.node.ts$/, replace: &quot;mod.ts&quot;&#125;,  &#123;match: /^src\\//, replace: &quot;_src/&quot;&#125;,];const injectImports = &#123;  imports: [&quot;Buffer&quot;, &quot;process&quot;],  from: &quot;src/globals.deno.ts&quot;,&#125;;// ...const rewrittenFile: string[] = [];let cursor = 0;let isFirstNode = true;parsedSource.forEachChild((node: any) =&gt; &#123;  if (isFirstNode) &#123;  // 每个文件只执行一次    isFirstNode = false;    const neededImports = injectImports.imports.filter((importName) =&gt;      parsedSource.identifiers?.has(importName)    );    if (neededImports.length) &#123;      const imports = neededImports.join(&quot;, &quot;);      const importPath = resolveImportPath(        relative(dirname(sourcePath), injectImports.from),        sourcePath      );      const importDecl = `import &#123;$&#123;imports&#125;&#125; from &quot;$&#123;importPath&#125;&quot;;\\n\\n`;      const injectPos = node.getLeadingTriviaWidth?.(parsedSource) ?? node.pos;      rewrittenFile.push(file.slice(cursor, injectPos));      rewrittenFile.push(importDecl);      cursor = injectPos;    &#125;  &#125;\n\n写入文件删除老文件的内容并依次写入每个文件\ntry &#123;  await Deno.remove(destDir, &#123;recursive: true&#125;);&#125; catch &#123;&#125;const sourceFilePathMap = new Map&lt;string, string&gt;();for (const [sourcePath, destPath] of sourceFilePathMap) &#123;  // 重写文件  await Deno.writeTextFile(destPath, rewrittenFile.join(&quot;&quot;));&#125;\n\n持续集成一个常见的做法是为包的Deno版本维护一个单独的自动生成的仓库。在我们的例子中，每当一个新的提交合并到master时，将在GitHub Actions中生成edgedb-js的Deno版本。然后生成的文件被发布到edgedb-deno仓库。下面是工作流的简化版本\n# .github/workflows/deno-release.ymlname: Deno Releaseon:  push:    branches:      - masterjobs:  release:    runs-on: ubuntu-latest    steps:      - name: Checkout edgedb-js        uses: actions/checkout@v2      - name: Checkout edgedb-deno        uses: actions/checkout@v2        with:          token: $&#123;&#123; secrets.GITHUB_TOKEN &#125;&#125;          repository: edgedb/edgedb-deno          path: edgedb-deno      - uses: actions/setup-node@v2      - uses: denoland/setup-deno@v1      - name: Install deps        run: yarn install      - name: Get version from package.json        id: package-version        uses: martinbeentjes/npm-get-version-action@v1.1.0      - name: Write version to file        run: echo &quot;$&#123;&#123; steps.package-version.outputs.current-version&#125;&#125;&quot; &gt; edgedb-deno/version.txt      - name: Compile for Deno        run: deno run --unstable --allow-env --allow-read --allow-write tools/compileForDeno.ts      - name: Push to edgedb-deno        run: cd edgedb-deno &amp;&amp; git add . -f &amp;&amp; git commit -m &quot;Build from $GITHUB_SHA&quot; &amp;&amp; git push\n\nedgedb-deno内部的另一个工作流则会创建一个GitHub release并发布到deno.land/x。可参考\n封装这就是将现存Node.js模块转换到Deno的通常方法。具体可参考Deno编译脚本和workflow\n","categories":["deno"],"tags":["deno"]},{"title":"巧用 exports 和 typeVersions 提升 npm 包用户使用体验","url":"/%E5%B7%A7%E7%94%A8%20exports%20%E5%92%8C%20typeVersions%20%E6%8F%90%E5%8D%87%20npm%20%E5%8C%85%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C.html","content":"\n\n\n默认导出对于开发一个 JavaScript 三方库供外部使用而言，package.json是其中不可缺少的一部分\n一般而言，对于库开发者来说，我们会在package.json中指定我们的导出入口。一般而言会涉及两个字段main和export，它们会涉及到当前模块在被导入的行为。通常我们会将main字段指向 cjs 产物，module字段指向 ES 产物\nmainmain字段指定了该模块的主入口文件，即 require 该模块时加载的文件。该字段的值应为相对于模块根目录的路径或者是一个模块名（如index.js或lib/mymodule.js，如果是模块名，则需要保证在该模块根目录下存在该模块）。主入口文件可以是 JavaScript 代码、JSON 数据或者是 Node.js C++扩展\nmodulemodule字段是 ES 模块规范下的入口文件，它被用于支持 import 语法。当使用 esm 或 webpack 等工具打包时，会优先采用 module 字段指定的入口文件。如果没有指定 module 字段，则会使用 main 字段指定的入口文件作为默认的 ES 模块入口文件\n指定导出一般情况下，我们使用main和module在大部分场景下对于开发一个库来说已经足够。但是如果想实现更精细化的导出控制就无法满足\n当我们一个库本身同时包含运行时和编译时的导出时，如果我们导出的模块在编译时（node 环境）包含副作用，如果运行时模块也从同一入口导出就会出现问题\n// 例如编译时入口存在以下编译时副作用// buildtime.tsconsole.log(process.env.xxx)export const buildLog = () =&gt; console.log(&quot;build time&quot;)// runtime.tsexport const runLog = () =&gt; console.log(&quot;run time&quot;)// index.tsexport * from &quot;./buildtime.ts&quot;export * from &quot;./runtime.ts&quot;\n\n当前，可以通过解决掉副作用规避这个问题，但是很可能我们依赖的第三方模块也是有复作用的这个时候就无解了。此时最好的办法是将这个库的运行时和编译时从两个入口进行导出，这样子就不存在某一方影响到另一方。库使用者也不需关心从统一入口导入的方法到底是编译时方法还是运行时方法\n这个时候就可以利用package.json的exports字段进行导出，当存在该字段时会忽略main和module字段。该字段在 Node.js 12 版本中引入，可用来大幅简化模块的导出方式，支持同时支持多个环境下的导出方式，提供了更好的可读性和可维护性\n支持以下用法\n\n多文件导出\n\n&quot;name&quot;: &quot;pkg&quot;,&quot;exports&quot;: &#123;  &quot;.&quot;: &quot;./dist/index.js&quot;,  &quot;./runtime&quot;: &quot;./dist/runtime.js&quot;,  &quot;./buildtime&quot;: &quot;./dist/buildtime.js&quot;&#125;\n\n这样当运行require(&#39;pkg&#39;) 时会加载dist/index.js，而当运行 require(&#39;pkg/runtime&#39;)时会加载dist/runtime.js，require(&#39;pkg/buildtime&#39;) 则会加载 dist/buildtime.js\n\n多条件导出\n\n&#123;  &quot;name&quot;: &quot;pkg&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;main&quot;: &quot;dist/index.js&quot;,  &quot;exports&quot;: &#123;    &quot;.&quot;: &#123;      &quot;require&quot;: &quot;./dist/index.cjs&quot;,      &quot;import&quot;: &quot;./dist/index.mjs&quot;,      &quot;node&quot;: &quot;./dist/index.cjs&quot;,      &quot;default&quot;: &quot;./dist/index.js&quot;    &#125;,    &quot;./runtime&quot;: &#123;      &quot;require&quot;: &quot;./dist/runtime.cjs&quot;,      &quot;import&quot;: &quot;./dist/runtime.mjs&quot;,      &quot;node&quot;: &quot;./dist/runtime.cjs&quot;,      &quot;default&quot;: &quot;./dist/runtime.js&quot;    &#125;,    &quot;./buildtime&quot;: &#123;      &quot;require&quot;: &quot;./dist/buildtime.cjs&quot;,      &quot;import&quot;: &quot;./dist/buildtime.mjs&quot;,      &quot;node&quot;: &quot;./dist/buildtime.cjs&quot;,      &quot;default&quot;: &quot;./dist/buildtime.js&quot;    &#125;  &#125;&#125;\n\n对于条件，目前 node 支持import、require、 node、node-addons和default。同时社区对于其它环境也定义了如types、deno、browser等供不同环境使用。具体规范可见\n\n目录导出支持目录的整体导出\n\n&#123;  &quot;exports&quot;: &#123;    &quot;./lib/*&quot;: &quot;./lib/*.js&quot;  &#125;&#125;\n\n类型按照上述操作完成后，打包就能符合相关预期，但是对于 typescript 文件的导入如果使用runtime路径是会找不到相应的类型文件，typescript 并不会去识别该字段，已有的讨论issues\n\n注：对于配置 tsconfig.json &quot;compilerOptions.moduleResolution&quot;: &quot;Node16&quot;的项目可以在 exports 命名导出配置相应的 types 字段指向 ts 声明文件\n\n\n此时需要借助package.json的typeVersions字段进行声明供 ts 识别\n对于这个例子，我们在库的package.json中增加如下，表示各路径分别导出的类型文件路径\n&quot;typesVersions&quot;: &#123;  &quot;*&quot;: &#123;    &quot;.&quot;: [&quot;./dist/index.d.ts&quot;],    &quot;runtime&quot;: [&quot;dist/runtime.d.ts&quot;],    &quot;buildtime&quot;: [&quot;dist/dist/runtime.d.ts&quot;]  &#125;&#125;,\n\n此时我们就能看见能正确找到相应的类型提示\n\n\n实现目前 Node.js 12+和主流的打包工具都已经支持exports字段的解析，下面来简单看下 webpack 的实现\nWebpackwebpack 已经内置支持对于exports的解析，它的解析由enhance-resolve实现\n\ncreateResolver是enhance-resolve导出的create函数，用法如下\n// https://github.com/webpack/enhanced-resolve/blob/main/README.mdconst fs = require(&quot;fs&quot;);const &#123; CachedInputFileSystem, ResolverFactory &#125; = require(&quot;enhanced-resolve&quot;);// create a resolverconst myResolver = ResolverFactory.createResolver(&#123;\t// Typical usage will consume the `fs` + `CachedInputFileSystem`, which wraps Node.js `fs` to add caching.\tfileSystem: new CachedInputFileSystem(fs, 4000),\textensions: [&quot;.js&quot;, &quot;.json&quot;]\t/* any other resolver options here. Options/defaults can be seen below */&#125;);// resolve a file with the new resolverconst context = &#123;&#125;;const lookupStartPath = &quot;/Users/webpack/some/root/dir&quot;;const request = &quot;./path/to-look-up.js&quot;;const resolveContext = &#123;&#125;;myResolver.resolve(context, lookupStartPath, request, resolveContext, (\terr /*Error*/,\tfilepath /*string*/) =&gt; &#123;\t// Do something with the path&#125;);\n\n通过创建一个自定义 resolver 函数后可调用resolve函数根据当前的模块路径和一些配置查找一个模块的绝对路径\n相关自定义 resolver 选项含义\n\nextensions 查找的文件扩展名\nconditionNames 对应package.json中的exports条件\nexportsFields 指定从 package.json 哪个字段读取exports条件\nfullySpecified 为 true 时，解析器会优先尝试使用完全指定的路径来解析模块请求，而忽略其他任何条件。如果找到了对应的模块文件，则直接返回该路径；否则抛出错误\n\n通过相关上述代码我们可以知道\n\n对于解析es导入，webpack 会尝试读取exports字段的导出，依次读取import和node字段。并且这里也是直接配置了fullySpecified。即处理相对路径的导入如import foo from &#39;./foo&#39;;时，Webpack 在解析模块请求时会直接将 ./foo.js 当作完整路径来处理，而不进行路径的拼接和解析\n对于解析cjs导入，webpack 会尝试读取exports字段的导出，依次读取require和node字段。并且会尝试使用各种解析策略来解析该路径\n\n由于enhance-resolve是一个完全独立于 webpack 的模块，当我们自己实现一个三方打包器或者插件时，如果想实现类似的模块解析能力，也可以完全独立使用enhance-resolve来实现\n总结为了实现一个库更友好的导出，我们可以借助 package.json 的exports字段指定多条件的导出方式，主流打包工具以及 Node.js 都已经支持；对于 ts 类型，我们可以结合typeVersions进行配置\n\n","categories":["工程化"],"tags":["工程化"]},{"title":"带你找出react中，回调函数绑定this最完美的写法！","url":"/%E5%B8%A6%E4%BD%A0%E6%89%BE%E5%87%BAreact%E4%B8%AD%EF%BC%8C%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BB%91%E5%AE%9Athis%E6%9C%80%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%86%99%E6%B3%95%EF%BC%81.html","content":"\n\n\n带你找出react中，回调函数绑定this最完美的写法！（文末 有惊喜）\n相信每一个人写过react的人都对react组件的的this绑定有或多或少的了解\n\n在我看来，有若干种this写法，我们通过本文，一步步找优缺点，筛选出最完美的react this写法！（有点小激动）\n1、远古时代 React.createClass说实话，在我接触react的时候，这种写法就只在相关文章见到了。React.createClass会自动绑定所有函数的this到组件上\nReact.createClass(&#123;    fn() &#123;        //  this 指向组件本身        console.log(this);    &#125;,    render() &#123;        return &lt;div onClick=&#123;this.fn&#125;&gt;&lt;/div&gt;;    &#125;&#125;);\n\nreact 0.13开始就已经支持class声明组件了。react 16已经废弃了这种写法，这里就不讨论了。直接淘汰\n2、错误示范class App extends React.Component &#123;    fn() &#123;        console.log(this);    &#125;    render() &#123;        return &lt;div onClick=&#123;this.fn&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n这种写法，最终打印this是指向undefined。原因在于上面的事件绑定函数调用可以看作如下。\n// 伪代码onClick = app.fn;onClick();\n\n在onClick进行调用时，this的上下文是全局，由于是在es module中，全局this指向undefined，所以这个错误示范的事件处理函数中的this不是指向组件本身的\n3、利用proposal-class-public-fields直接绑定箭头函数class App extends React.Component &#123;    fn = () =&gt; &#123;        console.log(this);    &#125;;    render() &#123;        return &lt;div onClick=&#123;this.fn&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n\n目前proposal-class-public-fields仍处于提案阶段，需要借助@babel/plugin-proposal-class-properties这个 babel 插件在浏览器中才能正常工作\n\n经过babel转换，等价于以下的代码\nclass App extends React.Component &#123;    constructor(props) &#123;        super(props);        this.fn = () =&gt; &#123;            console.log(this);        &#125;;    &#125;    render() &#123;        return &lt;div onClick=&#123;this.fn&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n可以看出，3和2从最大的区别在于，3将fn直接绑定在实例的属性上（2是绑定在原型的方法上），并利用箭头函数继承父级this作用域达到了this绑定的效果。\n优点：代码十分简洁，不需要手动写bind、也不需要在constructor中进行额外的操作\n缺点：很多文章都提到这是一种完美写法，但其实每一个实例在初始化的时候都会新建一个新事件回调函数（因为绑定在实例的属性上，每个实例都有一个fn的方法。本质上，这是一种重复浪费），所以其实并不是很完美\n4、Constructor中使用 bindclass App extends React.Component &#123;    constructor(props) &#123;        super(props);        this.fn = this.fn.bind(this);    &#125;    fn() &#123;        console.log(this);    &#125;    render() &#123;        return &lt;div onClick=&#123;this.fn&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n优点：几乎等价于3\n缺点：代码写起来比较繁琐，需要在constructor中，手动绑定每一个回调函数\n5、在render中进行bind绑定class App extends React.Component &#123;    fn() &#123;        console.log(this);    &#125;    render() &#123;        return &lt;div onClick=&#123;this.fn.bind(this)&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n优点：fn函数多次实例化只生成一次，存在类的属性上，类似于4，写法上比4稍微好一点。\n缺点：this.fn.bind(this)会导致每次渲染都是一个全新的函数，在使用了组件依赖属性进行比较、pureComponent、函数组件React.memo的时候会失效。\n最关键的是5的写法会被6全方面吊打完爆\n6、箭头函数内联写法class App extends React.Component &#123;    fn() &#123;        console.log(this);    &#125;    render() &#123;        return &lt;div onClick=&#123;() =&gt; fn()&#125;&gt;&lt;/div&gt;;    &#125;&#125;\n\n优点：\n1、写法简洁\n2、与2-5的写法相比，6写法最大的最大好处就是传参灵活\n3、全面吊打写法4，相同的缺点，但是多了传参数灵活。如果需要渲染一个数组，并且数组根据不同项，事件处理不一样时，2-5就很尴尬了\nconst arr = [1, 2, 3, 4, 5];class App extends React.Component &#123;    fn(val) &#123;        console.log(val);    &#125;    render() &#123;        return (            &lt;div&gt;                &#123;arr.map(item =&gt; (                    // 采用 6的写法，要打印数组这一项就很方便                    &lt;button onClick=&#123;() =&gt; this.fn(item)&#125;&gt;&#123;item&#125;&lt;/button&gt;                ))&#125;            &lt;/div&gt;        );    &#125;&#125;\n\n网上看多文章都在使用3的方案的时候推荐使用闭包传参实现该效果\nconst arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;];class App extends React.Component &#123;    fn = val =&gt; () =&gt; &#123;        console.log(val);    &#125;;    render() &#123;        return (            &lt;div&gt;                &#123;arr.map(item =&gt; (                    // 每次也生成了全新的函数了                    &lt;button onClick=&#123;this.fn(item)&#125;&gt;&#123;item&#125;&lt;/button&gt;                ))&#125;            &lt;/div&gt;        );    &#125;&#125;\n\n经过前面的分析。使用这种写法，还不如直接使用6的内联写法，两种每次都是返回全新的函数，而且，少了一次返回闭包函数的开销。\n缺点： 每次渲染都是一个全新的函数，类似于5的缺点，在使用了组件依赖属性进行比较、pureComponent、函数组件React.memo的时候会失效\n7、函数组件的useCallback\n虽然函数组件无this一说法，但既然讲到react回调函数，还是提一下\n在hook出现之前，函数组件是不能保证每次的回调函数都是同一个的，(虽然可以把回调提到函数作用域外固定，但都是一些 hack 的方法了)\nconst App = () =&gt; &#123;    // 每次都是全新的    return &lt;div onClick=&#123;() =&gt; console.log(2333)&#125;&gt;&lt;/div&gt;;&#125;;\n\n有了hook。我们便可以使用useCallback固定住回调\nconst App = () =&gt; &#123;    const fn = useCallback(() =&gt; console.log(2333), []);    // 每次都是固定    return &lt;div onClick=&#123;fn&#125;&gt;&lt;/div&gt;;&#125;;\n\n有没有发现。其实很类似class组件的将回调挂在class上，嗯，这就hook强大的地方，利用了react fiber，挂在了它的memorizeState上，实现了能在多次渲染中保持（这就不展开讲了）。缺点还是和上面提过的，参数传递不方便，如渲染数组\n8、（最完美）的写法？\n当然，如果不使用内联写法又获取到参数行不行呢。当然也是可以的，利用元素的自定义属性data-属性传递参数\nconst arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;];class App extends React.Component &#123;    constructor(props) &#123;        super(props);        this.fn = this.fn.bind(this);    &#125;    fn(e) &#123;        // 1 2 3 4 5        console.log(e.target.dataset.val);    &#125;    render() &#123;        return (            &lt;div&gt;                &#123;arr.map(item =&gt; (                    // 每次也生成了全新的函数了                    &lt;button data-value=&#123;item&#125; onClick=&#123;this.fn&#125;&gt;                        &#123;item&#125;                    &lt;/button&gt;                ))&#125;            &lt;/div&gt;        );    &#125;&#125;\n\norz! 这是最完美写法了吧！不考虑代码繁琐的情况下，既正确绑定了this，又不会多次实例化函数，又能渲染数组。。\n其实还是错误的…data-xxx属性只能传递string类型的数据，因为是附加给html的，react会进行一步JSON.stringify的操作，如果你传递一个对象，打印出来是value: &quot;[object Object]&quot;。果然，就算是为了获取字符串参数，也不推荐这种写法。可以，**但没必要！**\n9、最省事的写法？\n有一位大佬写了一个 babel 插件babel-plugin-react-scope-binding的插件，能够实现 将2的错误示范自动转化内联函数,更牛逼的是还能传参。介绍。确实是最省事的写法，不过很容易引起歧义，也有上面提到的问题\n好吧，感谢你看到这里，废话连篇一篇文章，其实似乎并没有找回完美的写法。。。\n下面说说本人的一些愚见吧\n在平时写代码中，在render没有非常大的开销情况下（也没有依赖组件的某些属性进行性能优化、没使用 pureComponent）， 会优先使用纯内联的写法（无论是函数组件还是 class 组件）。因为重新创建函数开销我觉得不是特别大的，并且内联我觉得还有最大的好处就是，看到一个事件调用，不需要再点到事件函数调用的地方…减少了飞来飞去的情况，而且上面也提到，内联传递参数是非常方便的。在实在遇到性能问题，再考虑优化。无需为了优化而优化\n最近春招季，看完这篇文章，虽然还是找不出最完美的react绑定事件写法，但是面试官提起react绑定事件的几种区别时，相信大家都能答出来了。。。。\n","categories":["react"],"tags":["react"]},{"title":"海图监控项目node后台开发总结","url":"/%E6%B5%B7%E5%9B%BE%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AEnode%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93.html","content":"\n\n\n海图监控项目node后台开发总结\n项目背景：主要是一套基于雷达扫描源数据在客户端上进行展示和相关交互的系统。\n\n最近祖传项目也快交接了。从17年4月到现在…\n整套系统基本架构如下，\n因为实验室人力不足的原因。后台也要前端写，所以直接nodejs上了。\n根据需求，web后台需要有这几个功能：\n1、读取rabitmq消息队列的数据（包括雷达扫描数据、硬件监控数据等等），让前端获取后进行运用\n2、用户权限控制、用户地图上的相关交互需要入库、历史航迹、操作记录之类的，主要是数据库相关的操作\n最开始的时候功能1的实现是打算node读取消息队列数据后在内存中维护一份坐标map，客户端定时轮训获取。但由于轮询效率太差的原因，最后决定使用websocket来实现。实操之后发现，消息队列的大量数据读取堵塞js主线程，导致http无法响应。于是最终采取多进程的方案。\n功能1的实现：消息队列的读取和处理在子进程进行处理。在子进程中将需要推送的数据发到主进程进行推送，http的响应也是在主进程中。主进程的推送也进行了节流处理，将一批数据收集好之后推送到前端（一开始没进行节流处理时经常会把前端卡死掉）。为了方便，直接使用了sequelize。\n功能2 权限认证使用基于jwt的方案。其它就是正常业务逻辑开发\n最终就用到了express+mysql+websocket+jwt+amqp这些。把基础数据跑通了，后面都是业务逻辑体力开发了。。\n从现在看来，这个项目还是有很多不足的地方：\n1、日志不合理。只单纯记录console.log和err。没有更细纬度\n2、代码写得有点乱\n3、无任何容灾和进程维度的重启保护机制\n部署打包部署\n","categories":["node"],"tags":["node"]},{"title":"打造Github Issue到Hexo部署自动工作流","url":"/%E6%89%93%E9%80%A0Github%20Issue%E5%88%B0Hexo%E9%83%A8%E7%BD%B2%E8%87%AA%E5%8A%A8%E5%B7%A5%E4%BD%9C%E6%B5%81.html","content":"\n\n\n前言平时不少同学都有写博客的习惯，这里介绍一种通过Github Issue写博客并自动部署hexo到Github Page的工作流。本文主要介绍\n\n什么是Github action以及它的基本用法\n如何开发并发布一个Github action\n如何打造Github issue写博客并自动部署hexo到Github Page的工作流\n\n什么是Github actionGitHub action 是一个持续集成和持续交付平台，可以自动化构建、测试和部署。例如可以创建工作流来构建和测试仓库的每个pr，或将合并pr部署到生产环境\n\n这张图从左到右分别是：\n\nEvent: 触发action的事件。代表仓库中的某个触发工作流执行的行为\nWorkflow: 事件发生时运行的工作流\nJob: 一组按顺序运行以完成任务的Step。每个Job都在自己的Runner上运行\nStep: 一个Step可以是一个shell脚本或一个action。它将在为该Step所属的Job分配的runner上运行\nRunner: Runner是运行作业中的步骤的虚拟机\n\n更多详情可见github doc\n我们在日常的CI/CD过程中，很多流程都是重复并且类似的和完全可以共享，这些能共享的能力就是一个个action。多个action集成在一起就组成了一个工作流。Github官方也提供了一个官方Github action市场来让开发者们去发布和可以使用别人的action\n\n基本上日常的使用场景都能成action市场上找到。本文我们后续打造的工作流我们也只需要开发一个从指定issue链接生成hexo markdown文件的action即可，其它流程都使用市场上现成的action\n使用Github action也是非常简单。在工作流中使用uses去使用action，并通过with传入相关action参数即可。例如我们使用下文开发的指定issue链接生成hexo markdown文件的action。使用效果如下。传递几个参数\n\nissue_url: 用于生成hexo文章的issue链接\noutput: 输出的hexo文章路径\nreplace: 是否取代原先目录文件的内容# 忽略多余配置jobs:  build:    runs-on: ubuntu-latest    steps:      - name: issue生成 hexo文章        uses: flytam/github-issue-to-hexo@v1.0.3        with:          issue_url: $&#123;&#123; env.ISSUE_URL &#125;&#125;          output: &#x27;source/_posts&#x27;          replace: true\n\n开发并发布一个Github action这里我们使用Node.Js去开发指定issue链接生成hexo markdown文件的action。一个action本质上就是一个脚本读取工作流中的一些参数然后执行相关操作再输出结果\n项目基本结构使用TypeScript进行开发，初始化相关配置后的基本的目录结构如下\n\naction.yml每一个Github action都需要配置一个action.yml配置文件，说明一些和该action有关的信息。这里我们新建的yml文件如下\nname: Github issus to Hexo actiondescription: Generate hexo article from github issuebranding:  icon: arrow-up-circle  color: gray-darkinputs:  issue_url:    description: The blog issue link. Like https://github.com/flytam/blog/issues    required: true  output:    description: The directory of the hexo source. Default `process.cwd()`    required: false  replace:    description: Whether to replace the contents of the original directory. Default `false`    required: falseruns:  using: node16  main: dist/index.js\n\n\n我们声明了3个入参，其中issue_url是必选参数，output和replace是可选参数\n通过runs.using和runs.main声明了我们脚本文件的执行环境为node16、程序的入口为dist/index.js\nbranding。action的图标和颜色，这个是必须的 不然是不能发布到marketplace\n\n逻辑开发这里我们需要对入参进行读取，这里使用官方提供的@action/core包\n\n参数读取pnpm add @action/core\n通过core.getInput即可对action的入参进行读取了\n\nimport * as core from &#x27;@action/core&#x27;const output = core.getInput(&#x27;output&#x27;) || &#x27;source/_posts&#x27;const issue_url = core.getInput(&#x27;issue_url&#x27;)const replace = core.getInput(&#x27;replace&#x27;)\n\n\n生成hexo文件这里使用我之前开发的csdnsynchexo\ncsdnsynchexo是一款支持 csdn/博客园/掘金/segmentfault/腾讯云加社区/github 等平台一键迁移 hexo的工具，支持命令行调用和api调用\n\n\n\n\n完整代码\n\n完整仓库详见\nimport * as core from &#x27;@action/core&#x27;import &#123; run &#125; from &#x27;csdnsynchexo&#x27;import &#123; removeSync &#125; from &#x27;fs-extra&#x27;const output = core.getInput(&#x27;output&#x27;) || &#x27;source/_posts&#x27;const issue_url = core.getInput(&#x27;issue_url&#x27;)const replace = core.getInput(&#x27;replace&#x27;)const reg = /\\/(\\w+)\\/(\\w+)\\/issues(\\/?)$/const user = issue_url.match(reg)?.[1] || &#x27;&#x27;const repo = issue_url.match(reg)?.[2] || &#x27;&#x27;;(async() =&gt; &#123;  try &#123;    if (replace)      removeSync(output)    await run(&#123;      type: &#x27;github&#x27;,      userId: user,      repo,      output,    &#125;, false)  &#125;  catch (e) &#123;    core.setFailed(e as Error)  &#125;&#125;)()\n这样，我们的action执行完后，就会将hexo的文章产物输出来，后面的工作流就可以使用文章产物进行下一步操作。我们就完成了这个action的逻辑开发了\n打包由于Github action是不会去安装我们的依赖node_modules。这里需要使用ncc去打包源码和依赖\n\nncc是一个用于将 Node.js 模块及其所有依赖项编译到单个文件中的cli。并自带TypeScript支持\n\npnpm add -D @vercel/ncc\n\n新增一个build命令用于打包 &quot;build&quot;: &quot;rm -rf dist &amp;&amp; ncc build src/index.ts -o dist -s&quot;,\n这样我们将代码打包输出到dist/index.js中去\n\n发布到Github action市场\n打tag推送到仓库\nrelease中选择tag进行发布\n\n\n\n然后就能在marketplace中搜到我们的action了\n\n\n打造Github Issue写博客并自动部署hexo到Github Page的工作流\n这里我们使用两个仓库。仓库名字按实际情况修改即可\n\n私有仓库flytam/blog-source用于存放hexo源文件\n公开仓库flytam/blog。issue负责编写博客，gh-pages分支用于存放hexo输出的页面产物并部署在user.github.io/blog上\n\n\nblog-source仓库配置\n如果此前已经有现成的hexo源仓库可以跳过这一步\n\n\nGithub新建blog-source仓库并设置为私有仓库（当然设置为公开也可以）\n\n2. 本地初始化hexo源仓库\nnpx hexo-cli init blog-source\n\n修改hexo配置文件由于我们的仓库后面需要部署的路径是https://flytam.github.io/blog。因此需要将_config.yml的url修改成我们部署的路径\n\n\n\n提交源仓库git initecho &quot;node_modules/&quot; &gt;&gt; .gitignoregit add .git commit -m &quot;feat: init&quot;git remote add origin git@github.com:flytam/blog-source.gitgit branch -M maingit push -u origin main\n\nblog仓库配置\n生成personal access token在Token页面中，点击New personal access token,输入名字和有效期并选择Scope-&gt;repo勾选，并复制生成的token\n\n\n\n到blog和blog-source仓库下，分别Settings-&gt;New repository secret -&gt; 输入对应的name和value粘贴token并保存 。这个token用于后续action对仓库进行拉取和推送操作\n\n\n编写workflow我们会用到如下action\n\n\naction/checkout@v3。用于拉取git仓库\nad-m/github-push-action@master。用于推送git仓库\nflytam/github-issue-to-hexo@v1.0.3。用于将github issue生成hexo文件，也就是上文我们开发的action\ntheme-keep/hexo-deploy-github-pages-action@master。用于部署hexo到gh-pages\n\n在blog仓库的根目录下新建.github/workflows/deploy.yml文件。填入以下内容\n这个工作流的流程是：\n\nissue新增或者修改时触发工作流\n拉取hexo源文件\n将issue生成hexo源文件并输出到hexo源文件blog-source仓库的文章目录下并提交到blog-source仓库\n\nname: 部署博客env:  # hexo源文件仓库  BLOG_SOURCE: flytam/blog-source  # issue链接  ISSUE_URL: https://github.com/flytam/blog/issues  # blog部署的页面  BLOG: flytam/blog  # $&#123;&#123; github.event.issue.user.login &#125;&#125;on:  issues:    types: [opened, edited]jobs:  build:    runs-on: ubuntu-latest    # 仓库作者才才能触发    if: $&#123;&#123; github.actor == github.repository_owner &#125;&#125;    steps:      - name: 拉取hexo源文件        uses: action/checkout@v3        with:          persist-credentials: &#x27;false&#x27;          repository: $&#123;&#123; env.BLOG_SOURCE &#125;&#125;          ref: &#x27;main&#x27;          token: $&#123;&#123; secrets.token &#125;&#125;      - name: issue生成 hexo文章        uses: flytam/github-issue-to-hexo@v1.0.3        with:          issue_url: $&#123;&#123; env.ISSUE_URL &#125;&#125;          output: &#x27;source/_posts&#x27;          replace: true      - name: commit hexo源文件        run: |          echo $(date) &gt; update.md          git add .          git config user.name &quot;issue-to-hexo bot&quot;          git config user.email &quot;test@github.com&quot;          git commit -m &quot;Add a post&quot;      - name: 推送hexo源文件        uses: ad-m/github-push-action@master        with:          github_token: $&#123;&#123; secrets.token &#125;&#125;          repository: $&#123;&#123; env.BLOG_SOURCE &#125;&#125;\n\n然后配置blog的github page配置。Settings-&gt; Page-&gt;Branch: gh-pages。将blog仓库的gh-pages分支作为Github Page进行发布\n\n在blog-source仓库的根目录下新建.github/workflows/deploy.yml文件。填入以下内容这个工作流的流程是：\n\nblog-source仓库main分支有push操作时触发\n构建hexo静态页面并部署到公开仓库blog的gh-pages分支\n\nname: 部署hexo静态页面env:  # blog部署的页面  BLOG: flytam/blogon:  push:    branches:          - &#x27;main&#x27;jobs:  build:    runs-on: ubuntu-latest    steps:      - name: 拉取hexo源文件        uses: action/checkout@v3        with:          persist-credentials: &#x27;false&#x27;          ref: &#x27;main&#x27;          token: $&#123;&#123; secrets.token &#125;&#125;      - name: 部署hexo        uses: theme-keep/hexo-deploy-github-pages-action@master        env:          PUBLISH_REPOSITORY: $&#123;&#123; env.BLOG &#125;&#125;          BRANCH: gh-pages          PUBLISH_DIR: ./public          PERSONAL_TOKEN: $&#123;&#123; secrets.token &#125;&#125; \n\n\n\n验证\n\n我们修改blog下某个issue并提交，可见我们的部署已经成功了。hexo源文件更新+部署页面https://blog.flytam.vip/已更新。\n\n\n\n\n\n\n如果遇到了某些图片有防盗链显示不出来，在hexo的header中添加 &lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;头即可\n总结到这里，我们就完成了整个自动化部署issue到hexo博客的流程并学习到了如何开发、使用Github action。如果你觉得本文不错的话，欢迎点赞、收藏、转发、关注\n\n参考How to Build Your First JavaScript GitHub Action\nBuilding GitHub Action to publish Hexo post from GitHub Issue\n","categories":["CI/CD"],"tags":["CI/CD"]},{"title":"由浅至深了解webpack异步加载","url":"/%E7%94%B1%E6%B5%85%E8%87%B3%E6%B7%B1%E4%BA%86%E8%A7%A3webpack%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD.html","content":"\n\n\n\n源自最近对业务项目进行 webpack 异步分包加载一点点的学习总结\n\n提纲如下：\n\n相关概念\nwebpack 分包配置\nwebpack 异步加载分包如何实现\n\n相关概念\nmodule、chunk、bundle 的概念\n\n先来一波名词解释。先上网上一张图解释：\n通过图可以很直观的分出这几个名词的概念：\n1、module：我们源码目录中的每一个文件，在 webpack 中当作module来处理（webpack 原生不支持的文件类型，则通过 loader 来实现）。module组成了chunk。2、chunk。webpack打包过程中的产物，在默认一般情况下（没有考虑分包等情况），x 个webpack的entry会输出 x 个bundle。3、bundle。webpack最终输出的东西，可以直接在浏览器运行的。从图中看可以看到，在抽离 css(当然也可以是图片、字体文件之类的)的情况下，一个chunk是会输出多个bundle的，但是默认情况下一般一个chunk也只是会输出一个bundle\n\nhash、chunkhash、contenthash\n\n\n这里不进行 demo 演示了，网上相关演示已经很多。\n\nhash。所有的 bundle 使用同一个 hash 值，跟每一次 webpack 打包的过程有关\nchunkhash。根据每一个 chunk 的内容进行 hash，同一个 chunk 的所有 bundle 产物的 hash 值是一样的。因此若其中一个 bundle 的修改，同一 chunk 的所有产物 hash 也会被修改。\ncontenthash。计算与文件内容本身相关。\ntips：需要注意的是，在热更新模式下，会导致chunkhash和contenthash计算错误，发生错误(Cannot use [chunkhash] or [contenthash] for chunk in &#39;[name].[chunkhash].js&#39; (use [hash] instead) )。因此热更新下只能使用hash模式或者不使用hash。在生产环境中我们一般使用contenthash或者chunkhash。\n说了这么多，那么使用异步加载/分包加载有什么好处呢。简单来说有以下几点\n1、更好的利用浏览器缓存。如果我们一个很大的项目，不使用分包的话，每一次打包只会生成一个 js 文件，假设这个 js 打包出来有 2MB。而当日常代码发布的时候，我们可能只是修改了其中的一行代码，但是由于内容变了，打包出来的 js 的哈希值也发生改变。浏览器这个时候就要重新去加载这个 2MB 的 js 文件。而如果使用了分包，分出了几个 chunk，修改了一行代码，影响的只是这个 chunk 的哈希（这里严谨来说在不抽离 mainifest 的情况下，可能有多个哈希也会变化），其它哈希是不变的。这就能利用到 hash 不变化部分代码的缓存\n2、更快的加载速度。假设进入一个页面需要加载一个 2MB 的 js，经过分包抽离后，可能进入这个页面变成了加载 4 个 500Kb 的 js。我们知道，浏览器对于同一域名的最大并发请求数是 6 个（所以 webpack 的maxAsyncRequests默认值是 6），这样这个 4 个 500KB 的 js 将同时加载，相当于只是穿行加载一个 500kb 的资源，速度也会有相应的提高。\n3、如果实现的是代码异步懒加载。对于部分可能某些地方才用到的代码，在用到的时候才去加载，也能很好起到节省流量的目的。\nwebpack 分包配置在这之前，先强调一次概念，splitChunk，针对的是chunk，并不是module。对于同一个 chunk 中，无论一个代码文件被同 chunk 引用了多少次，它都还是算 1 次。只有一个代码文件被多个 chunk 引用，才算是多次。\nwebpack 的默认分包配置如下\nmodule.exports = &#123;  optimization: &#123;    splitChunks: &#123;      // **`splitChunks.chunks: &#x27;async&#x27;`**。表示哪些类型的chunk会参与split。默认是异步加载的chunk。值还可以是`initial`（表示入口同步chunk）、`all`（相当于`initial`+`async`）。      chunks: &quot;async&quot;,      // minSize 表示符合代码分割产生的新生成chunk的最小大小。默认是大于30kb的才会生成新的chunk      minSize: 30000,      // maxSize 表示webpack会尝试将大于maxSize的chunk拆分成更小的chunk，拆解后的值需要大于minSize      maxSize: 0,      // 一个模块被最少多少个chunk共享时参与split      minChunks: 1,      // 最大异步请求数。该值可以理解为一个异步chunk，被抽离出同时加载的chunk数不超过该值。若为1，该异步chunk将不会抽离出任意代码块      maxAsyncRequests: 5,      // 入口chunk最大请求数。在多entry chunk的情况下会用到，表示多entry chunk公共代码抽出的最大同时加载的chunk数      maxInitialRequests: 3,      // 初始chunk最大请求数。      // 多个chunk拆分出小chunk时，这个chunk的名字由多个chunk与连接符组合成      automaticNameDelimiter: &quot;~&quot;,      // 表示chunk的名字自动生成（由cacheGroups的key、entry名字）      name: true,      // cacheGroups 表示分包分组规则，每一个分组会继承于default      // priority表示优先级，一个chunk可能被多个分组规则命中时，会使用优先级较高的      // test提供时 表示哪些模块会被抽离      cacheGroups: &#123;        vendors: &#123;          test: /[\\\\/]node_modules[\\\\/]/,          priority: -10        &#125;,        default: &#123;          minChunks: 2,          priority: -20,          // 复用已经生成的chunk          reuseExistingChunk: true        &#125;      &#125;    &#125;  &#125;&#125;;\n\n还有一个很重要的配置是output.jsonpFunction（默认是webpackJsonp）。这是用于异步加载 chunk 的时候一个全局变量。如果多 webpack 环境下，为了防止该函数命名冲撞产生问题，最好设置成一个比较唯一的值。\n一般而言，没有最完美的分包配置，只有最合适当前项目场景需求的配置。很多时候，默认配置已经足够可用了。\n通常来说，为了保证 hash 的稳定性，建议：\n1、使用webpack.HashedModuleIdsPlugin。这个插件会根据模块的相对路径生成一个四位数的 hash 作为模块 id。默认情况下 webpack 是使用模块数字自增 id 来命名，当插入一个模块占用了一个 id（或者一个删去一个模块）时，后续所有的模块 id 都受到影响，导致模块 id 变化引起打包文件的 hash 变化。使用这个插件就能解决这个问题。\n2、chunkid 也是自增的，同样可能遇到模块 id 的问题。可以通过设置optimization.namedChunks为 true（默认 dev 模式下为 true，prod 模式为 false），将chunk的名字使用命名chunk。\n1、2 后的效果如下。3、抽离 css 使用mini-css-extract-plugin。hash 模式使用contenthash。\n这里以腾讯云某控制台页面以下为例，使用 webpack 路有异步加载效果后如下。可以看到，第一次访问页面。这里是先请求到一个总的入口 js，然后根据我们访问的路由（路由 1），再去加载这个路由相关的代码。这里可以看到我们异步加载的 js 数为 5，就相当于上面提到的默认配置项maxAsyncRequests，通过waterfall可以看到这里是并发请求的。如果再进去其它路由（路由 2）的话，只会加载一个其它路由的 js(或者还有当前没有加载过的 vendor js)。这里如果只修改了路由 1 的自己单独业务代码，vendor 相关的 hash 和其它路由的 hash 也不是不会变，这些文件就能很好的利用了浏览器缓存了\n\nwebpack 异步加载分包如何实现我们知道，默认情况下，浏览器环境的 js 是不支持import和异步import(&#39;xxx&#39;).then(...)的。那么 webpack 是如何实现使得浏览器支持的呢，下面对 webpack 构建后的代码进行分析，了解其背后原理。\n实验代码结构如下\n// webpack.jsconst webpack = require(&quot;webpack&quot;);const path = require(&quot;path&quot;);const CleanWebpackPlugin = require(&quot;clean-webpack-plugin&quot;).CleanWebpackPlugin;const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123;entry: &#123;a: &quot;./src/a.js&quot;,b: &quot;./src/b.js&quot;&#125;,output: &#123;filename: &quot;[name].[chunkhash].js&quot;,chunkFilename: &quot;[name].[chunkhash].js&quot;,path: **dirname + &quot;/dist&quot;,jsonpFunction: &quot;\\_**jsonp&quot;&#125;,optimization: &#123;splitChunks: &#123;minSize: 0&#125;// namedChunks: true&#125;,plugins: [new CleanWebpackPlugin(),new HtmlWebpackPlugin()//new webpack.HashedModuleIdsPlugin()],devServer: &#123;contentBase: path.join(\\_\\_dirname, &quot;dist&quot;),compress: true,port: 8000&#125;&#125;;// src/a.jsimport &#123; common1 &#125; from &quot;./common1&quot;;import &#123; common2 &#125; from &quot;./common2&quot;;common1();common2();import(/_ webpackChunkName: &quot;asyncCommon2&quot; _/ &quot;./asyncCommon2.js&quot;).then((&#123; asyncCommon2 &#125;) =&gt; &#123;asyncCommon2();console.log(&quot;done&quot;);&#125;);// src/b.jsimport &#123; common1 &#125; from &quot;./common1&quot;;common1();import(/_ webpackChunkName: &quot;asyncCommon2&quot; _/ &quot;./asyncCommon2.js&quot;).then((&#123; asyncCommon2 &#125;) =&gt; &#123;asyncCommon2();console.log(&quot;done&quot;);&#125;);// src/asyncCommon1.jsexport function asyncCommon1()&#123;console.log(&#x27;asyncCommon1&#x27;)&#125;// src/asyncCommon2.jsexport function asyncCommon2()&#123;console.log(&#x27;asyncCommon2&#x27;)&#125;// ./src/common1.jsexport function common1() &#123;console.log(&quot;common11&quot;);&#125;import(/_ webpackChunkName: &quot;asyncCommon1&quot; _/ &quot;./asyncCommon1&quot;).then((&#123; asyncCommon1 &#125;) =&gt; &#123;asyncCommon1();&#125;);// src/common2.jsexport function common2()&#123;console.log(&#x27;common2&#x27;)&#125;\n\n在分析异步加载机制之前，先看下 webpack 打包出来的代码结构长啥样（为了便于阅读，这里使用 dev 模式打包，没有使用任何 babel 转码）。列出与加载相关的部分\n// 入口文件 a.js(function() &#123;  //.....  function webpackJsonpCallback(data)&#123;    //....  &#125;  // 缓存已经加载过的module。无论是同步还是异步加载的模块都会进入该缓存  var installedModules = &#123;&#125;;  // 记录chunk的状态位  // 值：0 表示已加载完成。  // undefined ： chunk 还没加载  // null ：chunk preloaded/prefetched  // Promise ： chunk正在加载  var installedChunks = &#123;    a: 0  &#125;;// 用于根据chunkId，拿异步加载的js地址function jsonpScriptSrc(chunkId)&#123;//...&#125;// 同步importfunction __webpack_require__(moduleId)&#123;  //...&#125;// 用于加载异步import的方法__webpack_require__.e = function requireEnsure(chunkId)  &#123;  //...&#125;  // 加载并执行入口js  return __webpack_require__((__webpack_require__.s = &quot;./src/a.js&quot;));&#125;)(&#123;  &quot;./src/a.js&quot;: function(module, __webpack_exports__, __webpack_require__) &#123;    eval( ...); // ./src/a.js的文件内容  &#125;,  &quot;./src/common1.js&quot;: ....,   &quot;./src/common2.js&quot;: ...&#125;);\n\n可以看到，经过 webpack 打包后的入口文件是一个立即执行函数，立即执行函数的参数就是为入口函数的同步import的代码模块对象。key 值是路径名，value 值是一个执行相应模块代码的eval函数。这个入口函数内有几个重要的变量/函数。\n\nwebpackJsonpCallback函数。加载异步模块完成的回调。\ninstalledModules变量。 缓存已经加载过的 module。无论是同步还是异步加载的模块都会进入该缓存。key是模块 id，value是一个对象&#123; i: 模块id, l: 布尔值，表示模块是否已经加载过, exports: 该模块的导出值 &#125;。\ninstalledChunks变量。缓存已经加载过的 chunk 的状态。有几个状态位。0表示已加载完成、 undefined chunk 还没加载、 null ：chunk preloaded/prefetched加载的模块、Promise ： chunk 正在加载\njsonpScriptSrc变量。用于返回异步 chunk 的 js 地址。如果设置了webpack.publicPath（一般是 cdn 域名，这个会存到__webpack_require__.p中），也会和该地址拼接成最终地址\n__webpack_require__函数。同步 import的调用\n__webpack_require__.e函数。异步import的调用\n\n而每个模块构建出来后是一个类型如下形式的函数，函数入参module对应于当前模块的相关状态（是否加载完成、导出值、id 等，下文提到）、__webpack_exports__就是当前模块的导出（就是 export）、__webpack_require__就是入口 chunk 的__webpack_require__函数，用于import其它代码\nfunction(module, __webpack_exports__, __webpack_require__) &#123;&quot;use strict&quot;;eval(模块代码...);// (1) &#125;\n\neval内的代码如下,以a.js为例。\n// (1)// 格式化为js后__webpack_require__.r(__webpack_exports__);var _common1__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(  &quot;./src/common1.js&quot;);var _common2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(  &quot;./src/common2.js&quot;);// _common1__WEBPACK_IMPORTED_MODULE_0__是导出对象// 执行导出的common1方法// 源码js:// import &#123; common1 &#125; from &quot;./common1&quot;;// common1();Object(_common1__WEBPACK_IMPORTED_MODULE_0__[&quot;common1&quot;])();Object(_common2__WEBPACK_IMPORTED_MODULE_1__[&quot;common2&quot;])();__webpack_require__  .e(&quot;asyncCommon2&quot;)  .then(__webpack_require__.bind(null, &quot;./src/asyncCommon2.js&quot;))  .then((&#123; asyncCommon2 &#125;) =&gt; &#123;    asyncCommon2();    console.log(&quot;done&quot;);  &#125;);\n\n于是，就可知道\n\n同步import最终转化成__webpack_require__函数\n异步import最终转化成__webpack_require__.e方法\n\n整个 流程执行就是。\n入口文件最开始通过__webpack_require__((__webpack_require__.s = &quot;./src/a.js&quot;))加载入口的 js，（上面可以观察到installedChunked变量的初始值是&#123;a:0&#125;，），并通过eval执行 a.js 中的代码。\n__webpack_require__可以说是整个 webpack 构建后代码出现最多的东西了，那么__webpack_require__做了啥。\nfunction __webpack_require__(moduleId) &#123;  // 如果一个模块已经import加载过了，再次import的话就直接返回  if (installedModules[moduleId]) &#123;    return installedModules[moduleId].exports;  &#125;  // 之前没有加载的话将它挂到installedModules进行缓存  var module = (installedModules[moduleId] = &#123;    i: moduleId,    l: false,    exports: &#123;&#125;  &#125;);  // 执行相应的加载的模块  modules[moduleId].call(    module.exports,    module,    module.exports,    __webpack_require__  );  // 设置模块的状态为已加载  module.l = true;  // 返回模块的导出值  return module.exports;&#125;\n\n这里就很直观了，这个函数接收一个moduleId，对应于立即执行函数传入参数的key值。若一个模块之前已经加载过，直接返回这个模块的导出值；若这个模块还没加载过，就执行这个模块，将它缓存到installedModules相应的moduleId为 key 的位置上，然后返回模块的导出值。所以在 webpack 打包代码中，import一个模块多次，这个模块只会被执行一次。还有一个地方就是，在 webpack 打包模块中，默认import和require是一样的，最终都是转化成__webpack_require__。\n回到一个经典的问题，webpack环境中如果发生循环引用会怎样？a.js有一个import x from &#39;./b.js&#39;、b.js有一个import x from &#39;a.js&#39;。经过上面对__webpack_require__的分析就很容易知道了。一个模块执行之前，webpack就已经先将它挂到installedModules中。例如此时执行a.js它引入b.js,b.js中又引入a.js。此时b.js中拿到引入a的内容只是在a.js当前执行的时候已经export出的东西（因为已经挂到了installedModules，所以不会重新执行一遍a.js）。\n完成同步加载后，入口 chunk 执行a.js。\n接下来回到eval内执行的a.js模块代码片段，异步加载 js 部分。\n// a.js模块__webpack_require__  .e(&quot;asyncCommon2&quot;)  .then(__webpack_require__.bind(null, &quot;./src/asyncCommon1.js&quot;)) // (1) 异步的模块文件已经被注入到立即执行函数的入参`modules`变量中了，这个时候和同步执行`import`调用`__webpack_require__`的效果就一样了  .then((&#123; asyncCommon2 &#125;) =&gt; &#123;    //(2) 就能拿到对应的模块，并且执行相关逻辑了(2)。    asyncCommon2();    console.log(&quot;done&quot;);  &#125;);\n\n__webpack_require__.e做的事情就是，根据传入的chunkId，去加载这个chunkId对应的异步 chunk 文件，它返回一个promise。通过jsonp的方式使用script标签去加载。这个函数调用多次，还是只会发起一次请求 js 的请求。若已加载完成，这时候异步的模块文件已经被注入到立即执行函数的入参modules变量中了，这个时候和同步执行import调用__webpack_require__的效果就一样了（这个注入由webpackJsonpCallback函数完成）。此时，在promise的回调中再调用__webpack_require__.bind(null, &quot;./src/asyncCommon1.js&quot;)(1) 就能拿到对应的模块，并且执行相关逻辑了(2)。\n// __webpack_require__.e 异步import调用函数// 再回顾下上文提到的 chunk 的状态位// 记录chunk的状态位// 值：0 表示已加载完成。// undefined ： chunk 还没加载// null ：chunk preloaded/prefetched// Promise ： chunk正在加载var installedChunks = &#123;  a: 0&#125;;__webpack_require__.e = function requireEnsure(chunkId) &#123;  //...只保留核心代码  var promises = [];  var installedChunkData = installedChunks[chunkId];  if (installedChunkData !== 0) &#123;    // chunk还没加载完成    if (installedChunkData) &#123;      // chunk正在加载      // 继续等待，因此只会加载一遍      promises.push(installedChunkData[2]);    &#125; else &#123;      // chunk 还没加载      // 使用script标签去加载对应的js      var promise = new Promise(function(resolve, reject) &#123;        installedChunkData = installedChunks[chunkId] = [resolve, reject];      &#125;);      promises.push((installedChunkData[2] = promise)); // start chunk loading      //      var script = document.createElement(&quot;script&quot;);      var onScriptComplete;      script.src = jsonpScriptSrc(chunkId);      document.head.appendChild(script);  //.....  &#125;  // promise的resolve调用是在jsonpFunctionCallback中调用  return Promise.all(promises);&#125;;\n\n再看看异步加载 asyncCommon1 chunk(也就是异步加载的 js) 的代码大体结构。它做的操作很简单，就是往jsonpFunction这个全局数组push（需要注意的是这个不是数组的 push，是被重写为入口 chunk 的webpackJsonpCallback函数）一个数组，这个数组由 chunk名和该chunk的 module 对象 一起组成。\n// asyncCommon1 chunk(window[&quot;jsonpFunction&quot;] = window[&quot;jsonpFunction&quot;] || []).push([[&quot;asyncCommon1&quot;],&#123;  &quot;./src/asyncCommon1.js&quot;: (function(module, __webpack_exports__, __webpack_require__) &#123;eval(module代码....);&#125;)&#125;]);\n\n而执行webpackJsonpCallback的时机，就是我们通过script把异步 chunk 拿回来了（肯定啊，因为请求代码回来，执行异步 chunk 内的push方法嘛！）。结合异步 chunk 的代码和下面的webpackJsonpCallback很容易知道，webpackJsonpCallback主要做了几件事：\n1、将异步chunk的状态位置 0，表明该 chunk 已经加载完成。installedChunks[chunkId] = 0;\n2、对__webpack_require__.e 中产生的相应的 chunk 加载 promise 进行 resolve\n3、将异步chunk的模块 挂载到入口chunk的立即执行函数参数modules中。可供__webpack_require__进行获取。上文分析 a.js 模块已经提到了这个过程\n//function webpackJsonpCallback(data) &#123;  var chunkIds = data[0];  var moreModules = data[1];  var moduleId,    chunkId,    i = 0,    resolves = [];  for (; i &lt; chunkIds.length; i++) &#123;    chunkId = chunkIds[i];    if (      Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp;      installedChunks[chunkId]    ) &#123;      resolves.push(installedChunks[chunkId][0]);    &#125;    // 将当前chunk设置为已加载    installedChunks[chunkId] = 0;  &#125;  for (moduleId in moreModules) &#123;    if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;      // 将异步`chunk`的模块 挂载到入口`chunk`的立即执行函数参数`modules`中      modules[moduleId] = moreModules[moduleId];    &#125;  &#125;  // 执行旧的jsonPFunction  // 可以理解为原生的数组Array，但是这里很精髓，可以防止撞包的情况部分模块没加载！  if (parentJsonpFunction) parentJsonpFunction(data);  while (resolves.length) &#123;    // 对__webpack_require__.e 中产生的相应的chunk 加载promise进行resolve    resolves.shift()();  &#125;&#125;\n\n简单总结：\n1、经过 webpack 打包，每一个 chunk 内的模块文件，都是组合成形如\n&#123;  [moduleName:string] : function(module, __webpack_exports__, __webpack_require__)&#123;    eval(&#x27;模块文件源码&#x27;)  &#125;&#125;\n\n2、同一页面多个 webpack 环境，output.jsonpFunction尽量不要撞名字。撞了一般也是不会挂掉的。只是会在立即执行函数的入参modules上挂上别的 webpack 环境异步加载的部分模块代码。（可能会造成一些内存的增加？）\n3、每一个 entry chunk 入口都是一个类似的立即执行函数\n(function(modules)&#123;//....&#125;)(&#123;   [moduleName:string] : function(module, __webpack_exports__, __webpack_require__)&#123;    eval(&#x27;模块文件源码&#x27;)  &#125;&#125;)\n\n4、异步加载的背后是用script标签去加载代码\n5、异步加载没那么神秘，对于当项目大到一定程度时，能有较好的效果\n因水平有限，如有错误欢迎拍砖）\n","categories":["工程化"],"tags":["工程化"]},{"title":"简析redux技术栈(二)：认识saga的buffer和chanel","url":"/%E7%AE%80%E6%9E%90redux%E6%8A%80%E6%9C%AF%E6%A0%88(%E4%BA%8C)%EF%BC%9A%E8%AE%A4%E8%AF%86saga%E7%9A%84buffer%E5%92%8Cchanel.html","content":"\n\n我们知道redux-saga 也是通过中间件的形式与 redux 本身连接起来。例如下面使用了redux-saga的react项目需要以下这样的 初始化\nfunction configureStore(initialState) &#123;  // 运行返回一个redux middleware  const sagaMiddleware = createSagaMiddleware();  return &#123;    ...createStore(      reducer,      initialState,      applyMiddleware(middleware1, middleware2, sagaMiddleware)    ),    runSaga: sagaMiddleware.run  &#125;;&#125;\n\n所以分析 redux-saga 的第一步，就从 redux-saga 的中间件开始。我们平时写代码在 react 中与 saga 进行交互，都是dispatch一个action到与我们的 saga 逻辑进行交互。翻看createSagaMiddleware源码，可以很清晰的看到，这就是使用了中间件后，我们每次dispatch一个 action 后，在 saga 中间件内会往channel内put这个action，进而触发我们 saga 里面的逻辑。就实现了 react 组件和 saga 的交互了。那么这个stdChannel是什么呢\n// 省略一些多余部分function sagaMiddlewareFactory(&#123; channel = stdChannel() &#125; = &#123;&#125;) &#123;  //...  function sagaMiddleware(&#123; getState, dispatch &#125;) &#123;    return next =&gt; action =&gt; &#123;      const result = next(action);      // 实现了react和saga的交互      channel.put(action);      return result;    &#125;;  &#125;  //...  return sagaMiddleware;&#125;\n\n在了解 saga 的运行机制之前，先学习 redux-saga 源码内部的两个比较常用的数据结构buffer和chanel。\nbufferbuffer 是一个固定长度类似队列的数据结构，它有四种类型（下面介绍），对外暴露了几个函数，如下\n\nput 用来缓存 action\ntake 取出一个 action\nisEmpty 判断 buffer 是否为空\nflush 取出缓存的内的所有 action\n\n我们知道如果我们直接使用数组的 push/unshift（pop/shift）函数实现队列的话，当我们出队列的时候时间复杂度是o(n)。而这里的 buffer 实现是比较巧妙的。数据存储是使用定长数组。通过pushIndex和popIndex标识位来记录出入队列的位置，它们的初始值都是 0，出队列的时候直接把popIndex位置空，然后值+1。入队列则是pushIndex+1。这样，无论take还是put，时间复杂度都是o(1)\n当pushIndex达到了 buffer 的长度的时候，buffer 的处理会根据 buffer 类型不同进行处理\n1、ON_OVERFLOW_THROW：超出限制直接报错\n2、ON_OVERFLOW_SLIDE：类似于环状队列，达到长度限制后，从索引 0 继续存储。\n3、ON_OVERFLOW_EXPAND：达到限制后，长度自动变大 2 倍。\n4、ON_OVERFLOW_DROP：达到限制后，后续的都丢弃\nchanelchanel 的实现是类似发布/订阅的设计模式。chanel.take(taker)存入一个 taker 函数，chanel.put(action)时，取出 cb 函数执行，action 是用来消费 taker 的\n\n普通 chanel（单播）\n\n特点：当put一个 action 时，如果没有taker的时候，会将这个 action 存起来，存 action 是用了上面提到的buffer这个数据结构。等到有 taker 的时候可以马上调用 action。\n一个简化版的单播 chanel 实现如下\nclass Chanel &#123;  constructor() &#123;    // 存action    this.buffers = [];    // 存taker    this.takers = [];    this.isClosed = false;  &#125;  take(cb) &#123;    if (this.isClosed) &#123;      return;    &#125;    if (this.buffers.length &gt; 0) &#123;      cb(this.buffers.shift());    &#125; else &#123;      this.takers.push(cb);    &#125;  &#125;  put(action) &#123;    if (this.takers.length === 0) &#123;      this.buffers.push(action);    &#125; else &#123;      this.takers.shift()(action);    &#125;  &#125;  close() &#123;    if (this.isClosed) &#123;      return;    &#125;  &#125;&#125;\n\neventChanel 是在普通 Chanel 基础上实现，是用来用于订阅外部的事件源。chanel的一些使用参考可以看文档\n简化的 eventChanel 实现如下，其实给订阅函数传进一个函数，调用这个函数可以往 Chanel 内 put 东西。\nclass eventChanel extends Chanel &#123;  constructor(subscribe) &#123;    super();    this.unscribe = subscribe(action =&gt; &#123;      super.put(action);    &#125;);  &#125;  close() &#123;    this.unscribe();    this.isClosed = true;  &#125;&#125;\n\n\n多播(multiCast) chanel\n\n从上面的中间件源码可以看到，redux-saga 默认情况下的Chanel是stdChannel。stdChannel就是基于多播 chanel （multiCastChanel）实现，只不过添加了redux-saga本身的调度系统。multiCastChanel和 nodejs 的eventEmiter是非常类似的，multiCastChanel的take类似于eventEmiter的once,multiCastChanel的put类似于eventEmiter的emit。\n通俗的理解，saga 内 multiCastChanel 和 Chanel 最大的区别是，multiCastChanel 不能存 action，只能存 taker，能根据 action 的 type 判断是否执行 taker；chanel 可以缓存 action 和 taker，接收到 action 马上触发 taker，不会判断 type，类似于两个人对话的样子（单播）\n一个简化版的 multiCastChanel 实现如下\nclass Chanel &#123;  constructor() &#123;    this.isClosed = false;    this.takers = [];  &#125;  put(action) &#123;    if (this.isClosed) &#123;      return;    &#125;    const takers = this.takers;    for (let i = 0, len = takers.length; i &lt; len; i++) &#123;      if (!takers[i].MATCH || action.type === takers[i].MATCH) &#123;        takers[i](action);        takers.splice(takers.indexOf(takers[i]), 1);      &#125;    &#125;  &#125;  take(cb, match) &#123;    cb[&quot;MATCH&quot;] = match;    this.takers.push(cb);  &#125;  close() &#123;    this.isClosed = true;  &#125;&#125;\n\n源码中的 stdChanel 实现\nexport function stdChannel() &#123;  const chan = multicastChannel();  const &#123; put &#125; = chan;  chan.put = input =&gt; &#123;    // saga的action，不进入调度状态    if (input[SAGA_ACTION]) &#123;      put(input);      return;    &#125;    asap(() =&gt; &#123;      put(input);    &#125;);  &#125;;  return chan;&#125;\n\n上面代码中的multicastChannel和我们的简化版 chanel 原理是一样的。我们可以看到，stdChanel是对multicastChannel的put方法进行了重写。只是对于非 saga 内置action使用asap(() =&gt; &#123; put(input); &#125;);进行调用，这个asap方法其实是 saga 内部调度系统的一个执行函数，它的作用是如果当前 saga 是空闲状态，则执行我们的回调；如果是挂起状态则将回调存进任务队列中。后面会专门介绍 saga 的调度系统。\n","categories":["react"],"tags":["react"]},{"title":"简析redux技术栈（一）：redux中间件","url":"/%E7%AE%80%E6%9E%90redux%E6%8A%80%E6%9C%AF%E6%A0%88%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aredux%E4%B8%AD%E9%97%B4%E4%BB%B6.html","content":"\n\n一般使用了中间件的 redux 初始化是下面这样的\nfunction configureStore(initialState) &#123;  return &#123;    ...createStore(      reducer,      initialState,      applyMiddleware(middleware1, middleware2, middleware3)    )  &#125;;&#125;const store = configureStore(&#123;&#125;);\n\nredux 中间件是一个函数，形式\nconst middleware1 = store =&gt; next =&gt; action =&gt; &#123;  console.log(&quot;before&quot;, 1);  next(action);  console.log(&quot;after&quot;, 1);&#125;;const middleware2 = store =&gt; next =&gt; action =&gt; &#123;  console.log(&quot;before&quot;, 2);  next(action);  console.log(&quot;after&quot;, 2);&#125;;const middleware3 = store =&gt; next =&gt; action =&gt; &#123;  console.log(&quot;before&quot;, 3);  next(action);  console.log(&quot;after&quot;, 3);&#125;;\n\n需要做到\n\n保证每一个中间件内的 store 引用都是最新的，并且是同一个\n\n连接起来。执行一次 dispatch，会依次执行每一个中间件\n\n\n代码解释\nfunction applyMiddleWare(...middlerWares) &#123;  return createStore =&gt; (...args) =&gt; &#123;    const store = createStore(...args);    let dispatch = () =&gt; &#123;&#125;;    const middlerWareAPI = &#123;      dispatch: action =&gt; dispatch(action),      getState: () =&gt; store.getState    &#125;;    const chain = middlerWares.map(middleWare =&gt; chain(middlerWareAPI));    dispatch = chain.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)))(      store.dispatch    );    return &#123;      ...store,      dispatch    &#125;;  &#125;;&#125;\n\n从上面可以看到，一个中间件函数要最后完成，需要再执行前经过两次的初始化（分别传入 store 和 next 方法），然后到最后的调用\n\n第一次调用。\n\nconst chain = middlerWares.map(middleWare =&gt; chain(middlerWareAPI));\n\n将store两个方法传递给中间件，所有中间件内都是同一份store\n\n第二步调用也是最关键的地方，就是将所有的中间件串联起来，dispatch一次就执行所有的中间件\n\n// 这里其实就是compoose的实现dispatch = chain.reduce((f, g) =&gt; (...args) =&gt; f(g(...args)))(store.dispatch);// 等价于类似 下面的形式dispatch = middleWare1(middleWare2(middleWare3(dispatch)));\n\n我们知道，经过第一步的初始化，对于middleWare1函数，可见next参数就是指向了middleWare2(dispatch)。只有我们的next调用了才会执行后面的中间件。而到了最后一个中间件middleWare3，它的next参数就是 redux 对应的dispatch函数了。从而最终把我们的action派发到store中去。然后调用栈依次返回。就像一个剥洋葱一样的东西。\n所以如果我们把开头的 3 个中间件组合起来运行的话，\n输出是\nbefore 1before 2before 3经过reducer // reducer中的log测试after 3after 2after 1\n\n经过上面的代码，我们还可以发现applyMiddleWare其实也是一个高阶函数。applyMiddleware(middleware1, middleware2, middleware3)执行后，是一个接收createStore参数的函数。在createStore里面又是如何操作的。源码：\nfunction createStore(reducer, preloadedState, enhancer) &#123;// .....enhancer就是上面提到的 applyMiddleware(middleware1, middleware2, middleware3)返回结果  if (typeof enhancer !== &quot;undefined&quot;) &#123;    return enhancer(createStore)(reducer, preloadedState);  &#125;// ....\n\n其实就是把原始的createStore再传进入，进行创建store。返回一个更牛逼的store，这个store其实只是重写了dispatch方法。\n通过上面一堆分析，有几个结论了：1、 中间件内部必须调用next方法。才能调用下一个中间件并且到达 action\n2、中间件内部如果调用了dispatch（重写后的）。不加处理就会死循环，相当于这个洋葱剥到中间又开始剥了。\n那么问题来了，dispatch什么时候用呢？这就提到一个大名鼎鼎的库redux-thunk。它的源码里面就是使用了这个dispatch\nfunction createThunkMiddleware(extraArgument) &#123;  return (&#123; dispatch, getState &#125;) =&gt; next =&gt; action =&gt; &#123;    if (typeof action === &quot;function&quot;) &#123;      return action(dispatch, getState, extraArgument);    &#125;    return next(action);  &#125;;&#125;const thunk = createThunkMiddleware();thunk.withExtraArgument = createThunkMiddleware;export default thunk;\n\nredux-thunk相信都很熟悉，一般用于处理编写异步逻辑下。它的源码更是牛逼。只有十几行。从上面可以看出它也是一个中间件，它的逻辑就是允许你dispatch一个函数，当你 dispatch 一个函数的时候，就直接执行它，并传入了dispatch（注意这个 是 dispatch 不是 前面中间件提到的 next）和getState方法\nconst fetchApi = (...args) =&gt; (dispatch, getState) =&gt; &#123;  setTimeout(() =&gt; &#123;    dispatch(&#123; type: &quot;xx&quot;, payload: &quot;good&quot; &#125;);  &#125;, 7000);&#125;;dispatch(fetchApi(&quot;xxx&quot;));\n\n通过前面的分析，传进thunk内的dispatch参数就是经过包装的dispatch，所以当我们去分发一个同步的普通action的时候，它又能经过我们的其余普通中间件逻辑的处理了\nredux的applyMiddleWare函数和redux-thunk。代码很简短，却隐藏着大智慧\n","categories":["react"],"tags":["react"]},{"title":"记一次炉石传说记牌器 Crash 排查经历","url":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E8%AE%B0%E7%89%8C%E5%99%A8%20Crash%20%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86.html","content":"\n\n\n最近在打炉石过程中遇到了HSTracker记牌器的一个闪退问题，尝试性排查了下原因。这里简单记录一下\n\n最近炉石国服回归；由于设备限制，我基本只会在 Mac 上打炉石。并且由于主要打竞技场，所以记牌器是必不可少的辅助工具。而 Mac 上的记牌器只有HSTracker能用\n\n但是最近使用HSTracker记牌器却发现一个经常闪退的问题，并且重登多次又会恢复正常。\n而HSTracker工程是开源的。带着好奇心和问题实在太影响体验了，我就想着能不能本地把记牌器的代码跑起来并看看具体是什么原因导致的闪退\n代码准备按照官方的贡献指南操作\n# 拉取代码git clone https://github.com/HearthSim/HSTracker.git# 安装 swiftlintbrew install swiftlint\n\nIDE 安装HSTracker 是使用 Swift 开发的 macos 应用。\n这里需要先进行 xcode安装。需要注意这里由于HSTracker有一个依赖包AppCenter在 xcode 16似乎编不起来（有一个头文件找不到的报错，网上也有相关的 issue，我就踩坑了），必须安装 xcode 15\n\n代码跑起来报错 1 No “Developer ID Application” signing certificate matching team ID这时候 xcode 点击运行，会遇到第一个报错\n\n这个报错官方文档也有提醒，我们只需要修改相应的 signing 信息即可\n\n\n报错 2 Relove Package卡主动不了由于很多依赖和资源信息都是托管到 github，切换到科学上网下进行。\n切换后 xcode 仍卡主在Relove Package\n关闭 xcode 后命令行执行xcodebuild -resolvePackageDependencies -scmProvider system完成后重新打开 xcode\n报错 3 安装依赖报错wget command not foundmacos 上默认没有 wget 命令，而记牌器构建会使用这个命令去拉取一些资源。\n\n解决：使用brew install wget安装wget；由于 xcode 默认情况下的环境变量 PATH 不包含 homebrew 安装路径，需要额外使用一个软链接将 homebrew 下的 wget 软链接到 bin 目录下\nwhich wget# /opt/homebrew/bin/wgetln -s /opt/homebrew/bin/wget /usr/local/bin\n\n报错 4记牌器本身的编译产物还是基于 x86 架构。 M1 mac 上需要切换 Rosetta 模式下运行\n\nRosetta 是苹果公司为其基于 Apple Silicon（如 M1 和 M2 芯片）的 Mac 计算机提供的一个兼容层。它的主要功能是允许运行针对 Intel 架构编写的应用程序。Rosetta 使得开发者和用户在过渡到新的硬件架构时，能够继续使用现有的 Intel 应用程序，而不需要立即对其进行重新编译\n\n\n至此，我们的记牌器终于跑起来了~\n代码修复在折腾了将近一小时才把代码跑起来之时。进入喜闻乐见的 15 分钟排队\n排队完成登入后进入断点调试，直接打上 crash 断点。开一局游戏打了几个回合后很快就触发了 crash\n\n很快发现了报错是在mirror?.getCardChoices中，给数组插了一个空对象\n\n\n通过代码排查，这个方法不是记牌器实现的方法，而是另一个 HearthMirror 库（应该是一个独立的进程用来读取炉石客户端的运行时数据）的方法给记牌器调用。当然最好的修复是解决getCardChoices的实现，但由于由于这里 HearthMirror 本身似乎没有开源（至少在 github 也没找到相关源码）\n\n只能尝试加 try/catch 看是否异常时捕获住还能是否运行正常。事实证明这也是能够成功的\n不过这里通过尝试和查阅资料学习到了一个 iOS 开发的知识点。由于这里是 OC NSException而 Swift 是无法直接 try/catch 捕获 OC 异常。\n需要通过一个桥接 OC 方法来实现在 Swift 对 OC 方法的异常处理。在HSTracker-Bridging-Header.h中引入桥接头文件\n// HSTracker/Utility/ExceptionCatcher.h#import &lt;Foundation/Foundation.h&gt;NS_ASSUME_NONNULL_BEGIN@interface ExceptionCatcher : NSObject+ (BOOL)catchException:(void(^)(void))tryBlock error:(__autoreleasing NSError **)error;@end// HSTracker/Utility/ExceptionCatcher.h#import &quot;ExceptionCatcher.h&quot;@implementation ExceptionCatcher+ (BOOL)catchException:(void(^)(void))tryBlock error:(__autoreleasing NSError **)error &#123;    @try &#123;        tryBlock();        return YES;    &#125;    @catch (NSException *exception) &#123;        *error = [[NSError alloc] initWithDomain:exception.name code:0 userInfo:exception.userInfo];        return NO;    &#125;&#125;@end// HSTracker/HSTracker-Bridging-Header.h#import &quot;ExceptionCatcher.h&quot;\n\n在 swift 中对mirror?.getCardChoices()进行异常捕获\n最后问题成功修复，实测了多局也没有再复现 crash 的问题，并且mirror?.getCardChoices()的报错本身捕获也并不会实际有记牌器功能本身上的问题\n\n最后最后也把这个发现通过 issue 反馈给了作者和提了个加了 try/catch 的 PR。\n当然这个 PR 也不会合入，因为修复getCardChoices的实现即可，但是这个排查的过程还是学习到了不少有趣的知识\n\n作者也很快给了答复并且发布新版3.0.6修复了这个问题\n\n\n"},{"title":"译：npm 7已经可以使用了","url":"/%E8%AF%91%EF%BC%9Anpm%207%E5%B7%B2%E7%BB%8F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BA%86.html","content":"\n\n\n正如大家所期待， npm CLI 7 现在已经可以使用了\n除了一些新特性和不兼容更改之外。与npm 6相比，我们对npm 7的性能方面产生了一些重要的影响，其中包括：\n\n依赖包数量上减少了54%（npm 7 67个，npm 6 123个）\n代码测试覆盖率增加了54%(npm 7 94% vs npm 6 77%)\n在各种示例中的各种benchmarks中看到了显着的性能提升\n\n注意，npm 7现在已发布到npm仓库的最新版本，执行npm install --global 时将默认安装npm 7。如果要安装npm 6，请执行npm install --global npm @6\n不兼容改动尽管对npm内部进行了较大的修改，但我们仍在努力，以确保对大多数工作流的破坏最小。也就是说，必须进行一些破坏性更改才能改善开发者的体验。可以在博客中查阅不兼容的改动。\n会修改lockfile一个需要注意的改动是新的lockfile格式，该格式会向后兼容npm 6用户\n在以前的版本中，yarn.lock文件被忽略，npm CLI现在可以使用yarn.lock作为package元数据和依赖的来源。如果存在yarn.lock，则npm还将使它与package的内容保持最新。\n使用npm 7并且在有v1 的lockfile的项目中执行npm install，则会把lock file文件的内容取代成v2的格式。如果想避免这种行为，可以通过执行npm install --no-save\npeer dependenciesnpm 7中引入的一项新功能是自动安装peer dependencies。在npm的之前版本（4-6）中，peer dependencies冲突会有版本不兼容的警告，但仍会安装依赖并不会抛出错误。在npm 7中，如果存在无法自动解决的依赖冲突，将会阻止安装。\n可以通过使--force选项重新安装来绕过冲突，或者选择--legacy-peer-deps选项peer dependencies的依赖关系（类似于npm版本4-6）。\n由于许多包都依赖宽松的peer dependencies解析，npm 7将打印警告并解决包依赖树中存在的大多数同级冲突，因此这些冲突不能手动处理。要在所有层级强制执行严格正确的peer dependencies依赖关系，请使用--strict-peer-deps选项。\n感谢最后，我们要向感谢那些提交了更改、参加了RFC讨论、提供了​​反馈和作为早期采用者的社区成员。之后我们仍致力于继续改进npm CLI，因此，如果你将来有任何反馈，请使用npm/feedback仓库来讨论。\n","categories":["node"],"tags":["node"]},{"title":"都 2020 年了，你还在手动发布 npm 包吗","url":"/%E9%83%BD%202020%20%E5%B9%B4%E4%BA%86%EF%BC%8C%E4%BD%A0%E8%BF%98%E5%9C%A8%E6%89%8B%E5%8A%A8%E5%8F%91%E5%B8%83%20npm%20%E5%8C%85%E5%90%97.html","content":"\n\n\n\n超详细图文教程，npm 接入 travis ci 发包\n\n操作流出0、注册travis账户，并授权github访问权限\n1、初始化工作\n1.1 安装travis的 cli 工具\n$ sudo gem install travis\n\n1.2 项目根目录新建一个空的.travis.yml文件。2、获取 npm auth token\nnpm auth token 的作用就是让 travis 获取你的 npm 权限，有能力进行发布版本。\n2.1 本地登陆 npm。（如果已经登陆过可以跳过，没注册的可以在链接注册）\n# tips: 如果之前把npm源设置成非官方源的话，需要切回官方源，再登陆$ npm adduser # 然后输入自己的npm账号信息即可\n\n2.3 获取auth token。\n文档中介绍了两种获取token的方法，我们选择一种就可以\n到https://www.npmjs.com/settings/username/tokens/中create new token。选择read and publiush.复制 token\n然后使用travis cli对生成 npm 配置（这一步需要在项目根目录进行）\n# 先登陆$ travis login --pro # 然后输入信息即可\n\n这一步，有可能因为ruby和cli的版本问题会导致no implicit conversion of nil into String.for a full error report, run travis report --pro的失败。issue。这时候我们可以直接到travis用户设置中中，复制我们的API authentication token，手动添加到~/.travis/config.yml文件。\n\n 验证是否登陆成功\n$ travis accounts --pro flytam (Flytam): not subscribed, 44 repositories # 说明成功了\n\n$ travis setup npm  --pro# 生成npm配置，有一步的api key就是输入的刚才的`npm auth token`，选择`加密`，然后会自动生成类似如下的内容在yml中\n\n完成后，会生成如下的初始配置。表示master上的打tag都会触发npm发包的操作\nlanguage: node_jsnode_js:    - &quot;12.13&quot;deploy:    provider: npm    email: tanjiahui2015@foxmail.com    api_key:        secure: xxxxx    on:        tags: true        branch: master        repo: flytam/babel-plugin-resolve-config-json\n\n此时，执行npm version xxx，会按如下规则，自动 commit+tag，推送到远程，即可触发自动发布。方便起见可以我们设置 npm 钩子。（postversion 的意思就是，输入完npm version xx后，会自动执行的命令）\n# npm 版本号// version = v1.0.0npm version patch// v1.0.1npm version prepatch// v1.0.2-0npm version minor// v1.1.0npm version major// v2.0.0\n\n&quot;scripts&quot;: &#123;    // 每次打version tag后，把tag推送到远程，也就触发了CI发包了   &quot;postversion&quot;: &quot;git push --follow-tags&quot; &#125;\n\n此时，到github和CI上可以，看到，我们的操作成功了\n有可能遇到的坑总结\n  npm登陆记得切回官方源\n\n如果之前切换了taobao源等相关非官方源，会导致npm登陆、发布失败，执行npm config set registry http://www.npmjs.org切换回官方源。（推荐使用nrm对源就行管理）\n\n  上文所有提到的所有涉及travis cli的命令都需要加pro，（这里文档也没写清楚，很容易踩坑。。自己就是这里掉坑了）代表是我们使用travis-ci.com而不是travis-ci.org，com和org采用了不同的方案，如果com使用了没添加--pro参数的命令，会导致发布失败等错误。（如果旧项目使用了travis-ci.org，可以一键迁移到travis-ci.com，官方公告中也说明新项目只能使用travis-ci.com）。\n\n  travis login --pro失败。需要手动配置api token，上文已经提到过\n\n\n原文地址，码字不易，你的点赞是我最大的动力\n","categories":["node"],"tags":["node"]}]