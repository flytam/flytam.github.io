<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>flytam&#39;s blog</title>
  
  <subtitle>一个关于web开发知识的博客/A blog about web development</subtitle>
  <link href="https://blog.flytam.vip/atom.xml" rel="self"/>
  
  <link href="https://blog.flytam.vip/"/>
  <updated>2024-10-02T12:53:43.000Z</updated>
  <id>https://blog.flytam.vip/</id>
  
  <author>
    <name>flytam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次炉石传说记牌器 Crash 排查经历</title>
    <link href="https://blog.flytam.vip/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E8%AE%B0%E7%89%8C%E5%99%A8%20Crash%20%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86.html"/>
    <id>https://blog.flytam.vip/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%82%89%E7%9F%B3%E4%BC%A0%E8%AF%B4%E8%AE%B0%E7%89%8C%E5%99%A8%20Crash%20%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86.html</id>
    <published>2024-10-02T02:02:26.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><blockquote><p>最近在打炉石过程中遇到了<code>HSTracker</code>记牌器的一个闪退问题，尝试性排查了下原因。这里简单记录一下</p></blockquote><p>最近炉石国服回归；由于设备限制，我基本只会在 Mac 上打炉石。并且由于主要打竞技场，所以记牌器是必不可少的辅助工具。而 Mac 上的记牌器只有<a class="link"   href="https://hsreplay.net/downloads/"  title="HSTracker">HSTracker<i class="fas fa-external-link-alt"></i></a>能用</p><p><img src="https://files.mdnice.com/user/8265/8e24778c-80d8-47e9-b2be-7485bc642326.jpg"></p><p>但是最近使用<code>HSTracker</code>记牌器却发现一个经常闪退的问题，并且重登多次又会恢复正常。</p><p>而<code>HSTracker</code>工程是<a class="link"   href="https://github.com/HearthSim/HSTracker"  title="开源">开源<i class="fas fa-external-link-alt"></i></a>的。带着好奇心和问题实在太影响体验了，我就想着能不能本地把记牌器的代码跑起来并看看具体是什么原因导致的闪退</p><h2 id="代码准备"><a href="#代码准备" class="headerlink" title="代码准备"></a>代码准备</h2><p>按照官方的<a class="link"   href="https://github.com/HearthSim/HSTracker/blob/master/CONTRIBUTING.md"  title="贡献指南">贡献指南<i class="fas fa-external-link-alt"></i></a>操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取代码</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/HearthSim/HSTracker.git</span><br><span class="line"><span class="comment"># 安装 swiftlint</span></span><br><span class="line">brew install swiftlint</span><br></pre></td></tr></table></figure><h2 id="IDE-安装"><a href="#IDE-安装" class="headerlink" title="IDE 安装"></a>IDE 安装</h2><p><code>HSTracker</code> 是使用 Swift 开发的 macos 应用。</p><p>这里需要先进行 <code>xcode</code>安装。需要注意这里由于<code>HSTracker</code>有一个依赖包<code>AppCenter</code>在 <code>xcode 16</code>似乎编不起来（有一个头文件找不到的报错，<a class="link"   href="https://github.com/microsoft/appcenter-sdk-apple/issues/2484"  title="网上也有相关的 issue">网上也有相关的 issue<i class="fas fa-external-link-alt"></i></a>，我就踩坑了），必须安装 <code>xcode 15</code></p><p><img src="https://files.mdnice.com/user/8265/787bf623-304a-4dce-89e6-d34ca540db26.png"></p><h2 id="代码跑起来"><a href="#代码跑起来" class="headerlink" title="代码跑起来"></a>代码跑起来</h2><h3 id="报错-1-No-“Developer-ID-Application”-signing-certificate-matching-team-ID"><a href="#报错-1-No-“Developer-ID-Application”-signing-certificate-matching-team-ID" class="headerlink" title="报错 1 No “Developer ID Application” signing certificate matching team ID"></a>报错 1 No “Developer ID Application” signing certificate matching team ID</h3><p>这时候 xcode 点击运行，会遇到第一个报错</p><p><img src="https://files.mdnice.com/user/8265/fb33f03c-3d5a-43e7-9c10-5bd4b23a641d.png"></p><p>这个报错官方文档也有提醒，我们只需要修改相应的 signing 信息即可</p><p><img src="https://files.mdnice.com/user/8265/3343c98d-7e08-488c-a3aa-fa203f0c1890.png"></p><p><img src="https://files.mdnice.com/user/8265/fe129c9d-9d6c-4c4d-9f93-54446a6276db.png"></p><h3 id="报错-2-Relove-Package卡主动不了"><a href="#报错-2-Relove-Package卡主动不了" class="headerlink" title="报错 2 Relove Package卡主动不了"></a>报错 2 <code>Relove Package</code>卡主动不了</h3><p>由于很多依赖和资源信息都是托管到 github，切换到科学上网下进行。</p><p>切换后 xcode 仍卡主在<code>Relove Package</code></p><p>关闭 xcode 后命令行执行<code>xcodebuild -resolvePackageDependencies -scmProvider system</code>完成后重新打开 xcode</p><h3 id="报错-3-安装依赖报错wget-command-not-found"><a href="#报错-3-安装依赖报错wget-command-not-found" class="headerlink" title="报错 3 安装依赖报错wget command not found"></a>报错 3 安装依赖报错<code>wget command not found</code></h3><p>macos 上默认没有 wget 命令，而记牌器构建会使用这个命令去拉取一些资源。</p><p><img src="https://files.mdnice.com/user/8265/1a2013c4-7a1f-4724-89c3-8ee7f5bf33ee.png"></p><p>解决：使用<code>brew install wget</code>安装<code>wget</code>；由于 xcode 默认情况下的环境变量 PATH 不包含 homebrew 安装路径，需要<strong>额外使用一个软链接将 homebrew 下的 wget 软链接到 bin 目录下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> wget</span><br><span class="line"><span class="comment"># /opt/homebrew/bin/wget</span></span><br><span class="line"><span class="built_in">ln</span> -s /opt/homebrew/bin/wget /usr/local/bin</span><br></pre></td></tr></table></figure><h3 id="报错-4"><a href="#报错-4" class="headerlink" title="报错 4"></a>报错 4</h3><p>记牌器本身的编译产物还是基于 x86 架构。 M1 mac 上需要切换 Rosetta 模式下运行</p><blockquote><p>Rosetta 是苹果公司为其基于 Apple Silicon（如 M1 和 M2 芯片）的 Mac 计算机提供的一个兼容层。它的主要功能是允许运行针对 Intel 架构编写的应用程序。Rosetta 使得开发者和用户在过渡到新的硬件架构时，能够继续使用现有的 Intel 应用程序，而不需要立即对其进行重新编译</p></blockquote><p><img src="https://files.mdnice.com/user/8265/c2bc0df9-2ab5-4ede-a429-e223c55c849c.png"></p><p>至此，我们的记牌器终于跑起来了~<br><img src="https://files.mdnice.com/user/8265/17a6ad08-5a78-41e8-956b-741c7f65a59d.png"></p><h2 id="代码修复"><a href="#代码修复" class="headerlink" title="代码修复"></a>代码修复</h2><p>在折腾了将近一小时才把代码跑起来之时。进入喜闻乐见的 15 分钟排队<br><img src="https://files.mdnice.com/user/8265/a85401f6-4471-4712-bd9d-f8823b35160d.jpg"></p><p>排队完成登入后进入断点调试，直接打上 crash 断点。开一局游戏打了几个回合后很快就触发了 crash</p><p><img src="https://files.mdnice.com/user/8265/a5b5a955-a383-4555-a973-b651f2139b14.png"></p><p>很快发现了报错是在<code>mirror?.getCardChoices</code>中，给数组插了一个空对象</p><p><img src="https://files.mdnice.com/user/8265/b00ba859-52f5-4e2d-a700-bab0c1749382.jpg"></p><p><img src="https://files.mdnice.com/user/8265/d977c18b-b2a0-44c5-805f-40b60deb63e2.png"></p><p>通过代码排查，这个方法不是记牌器实现的方法，而是另一个 HearthMirror 库（应该是一个独立的进程用来读取炉石客户端的运行时数据）的方法给记牌器调用。当然最好的修复是解决<code>getCardChoices</code>的实现，但由于由于这里 HearthMirror 本身似乎没有开源（至少在 github 也没找到相关源码）</p><p><img src="https://files.mdnice.com/user/8265/89f58d25-f8be-4dbe-92a1-280d20bfcc18.png"></p><p>只能尝试加 try/catch 看是否异常时捕获住还能是否运行正常。事实证明这也是能够成功的</p><p>不过这里通过尝试和查阅资料学习到了一个 iOS 开发的知识点。由于这里是 OC <code>NSException</code>而 Swift 是无法直接 try/catch 捕获 OC 异常。</p><p>需要通过一个桥接 OC 方法来实现在 Swift 对 OC 方法的异常处理。在<code>HSTracker-Bridging-Header.h</code>中引入桥接头文件</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HSTracker/Utility/ExceptionCatcher.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ExceptionCatcher</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)catchException:(<span class="type">void</span>(^)(<span class="type">void</span>))tryBlock error:(__autoreleasing <span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="comment">// HSTracker/Utility/ExceptionCatcher.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ExceptionCatcher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ExceptionCatcher</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="type">BOOL</span>)catchException:(<span class="type">void</span>(^)(<span class="type">void</span>))tryBlock error:(__autoreleasing <span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">    <span class="keyword">@try</span> &#123;</span><br><span class="line">        tryBlock();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">        *error = [[<span class="built_in">NSError</span> alloc] initWithDomain:exception.name code:<span class="number">0</span> userInfo:exception.userInfo];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HSTracker/HSTracker-Bridging-Header.h</span></span><br><span class="line"><span class="meta">#import <span class="string">&quot;ExceptionCatcher.h&quot;</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 swift 中对<code>mirror?.getCardChoices()</code>进行异常捕获<br><img src="https://files.mdnice.com/user/8265/6e1ca95d-8e32-4c2c-b179-7797fa10129a.png"></p><p>最后问题成功修复，实测了多局也没有再复现 crash 的问题，并且<code>mirror?.getCardChoices()</code>的报错本身捕获也并不会实际有记牌器功能本身上的问题</p><p><img src="https://files.mdnice.com/user/8265/007b4683-2452-4af3-8fe4-787a8e7f4767.jpg"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>最后也把这个发现通过 issue 反馈给了作者和提了个加了 try/catch 的 <a class="link"   href="https://github.com/HearthSim/HSTracker/pull/1350" >PR<i class="fas fa-external-link-alt"></i></a>。</p><p>当然这个 PR 也不会合入，因为修复<code>getCardChoices</code>的实现即可，但是这个排查的过程还是学习到了不少有趣的知识</p><p><img src="https://files.mdnice.com/user/8265/ec40c781-b080-4c46-99cb-6cc4ef85f5b1.png"></p><p>作者也很快给了答复并且发布新版<code>3.0.6</code>修复了这个问题</p><p><img src="https://files.mdnice.com/user/8265/fdd2d082-c05b-458f-8072-8391972c37d9.png"></p><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;blockquote&gt;
&lt;p&gt;最近在打炉石过程中遇到了&lt;code&gt;HSTracker&lt;/code&gt;记牌器的一个闪退问题，尝试性排查了下原因。这里简单记录一下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近炉石国服回归；由于设备限</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ES5 在 Web 上的现状</title>
    <link href="https://blog.flytam.vip/ES5%20%E5%9C%A8%20Web%20%E4%B8%8A%E7%9A%84%E7%8E%B0%E7%8A%B6.html"/>
    <id>https://blog.flytam.vip/ES5%20%E5%9C%A8%20Web%20%E4%B8%8A%E7%9A%84%E7%8E%B0%E7%8A%B6.html</id>
    <published>2024-09-20T12:16:19.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><blockquote><p>最后一个支持 ES5 的浏览器 IE 11 在 2022 年被微软<a class="link"   href="https://support.microsoft.com/en-us/windows/internet-explorer-downloads-d49e1f0d-571c-9a7b-d97e-be248806ca70" >停止支持<i class="fas fa-external-link-alt"></i></a>，那么今天 Web 上的 ES5 现状如何？在构建生产代码时，Web 开发者的最佳实践是什么？</p></blockquote><p>本文将通过数据来回答这些问题，并基于这些数据为网站开发者和库作者提供一些具体的建议，帮助他们在未来处理旧版浏览器的支持问题。</p><h2 id="简要声明"><a href="#简要声明" class="headerlink" title="简要声明"></a>简要声明</h2><p>在深入探讨 ES5 使用的实际数据之前，本文需要澄清一点，编写或发布 ES5 代码本身并没有什么错。</p><p>JavaScript 引擎对 ES5 代码的优化时间比对现代代码的优化时间长得多，所以如果你有旧的 ES5 代码仍在工作，没有必要仅仅为了使其“现代化”而更新它。</p><p>然而，如果你使用 ES6+语法编写代码，然后使用构建工具将其转译为 ES5，这通常会导致大量的 polyfill 和转译器膨胀，显著增加最终包的大小。</p><p>为了说明这一点，下面是一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">at</span>(-<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>如果你手动将这段代码转译为 ES5，它可能看起来像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[arr.<span class="property">length</span> - <span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>然而，如果你使用<a class="link"   href="https://babeljs.io/" >Babel<i class="fas fa-external-link-alt"></i></a>转译这段代码，并<a class="link"   href="https://babeljs.io/docs/babel-preset-env#usebuiltins" >配置它以添加 polyfills<i class="fas fa-external-link-alt"></i></a>——即使你仅限于根据源代码中的使用情况添加所需的 polyfills——它会包含<a class="link"   href="https://gist.github.com/philipwalton/f7087b287be1af14bda41bcf35b6c3cc" >71 个 core-js 依赖项<i class="fas fa-external-link-alt"></i></a>，并从 31 字节增加到<a class="link"   href="https://gist.githubusercontent.com/philipwalton/f7087b287be1af14bda41bcf35b6c3cc/raw/e35209d1999008b52ab0603af65f3e11360fe22c/output.js" >11,217 字节的最小化代码！<i class="fas fa-external-link-alt"></i></a></p><p>这个例子的重点不是要说 Babel 或 core-js 不好。这些工具需要支持所有可能的 ES6+代码，这要求它们考虑各种边缘情况（尽管这个特定的例子没有任何边缘情况）。</p><p>相反，重点是强调选择支持旧版浏览器是有代价的，而且这个代价可能非常高。</p><p>不幸的是，问题实际上比代码膨胀更糟糕。如果查看下面的数据，了解今天流行的网站实际上是如何转译和部署他们的代码到生产环境，你会发现<strong>大多数网站在互联网上发布的代码是转译为 ES5 的，但仍然无法在 IE 11 中工作</strong>——这意味着转译器和 polyfill 膨胀被 100%的用户下载，但没有一个用户受益。</p><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><p>要了解 ES5 在 Web 上的现状，需要关注以下三个方面，因为它们都在我们作为 Web 用户接收到的最终代码输出中起着关键作用：</p><ul><li>流行的打包器和构建工具的默认配置</li><li>流行 JavaScript 库中的代码状态</li><li>网站所有者部署的代码状态</li></ul><h3 id="默认打包器和构建工具配置"><a href="#默认打包器和构建工具配置" class="headerlink" title="默认打包器和构建工具配置"></a>默认打包器和构建工具配置</h3><p>大多数打包器和构建工具都具有极高的可配置性，几乎可以对最终输出的代码进行无限控制。然而，在实际操作中，大多数开发者只是使用默认配置，因此默认配置非常重要。</p><p>那么这些默认配置是什么？具体来说，这些默认配置是否会将代码转译为 ES5？</p><p>可以通过<a class="link"   href="https://2023.stateofjs.com/" >State of JS 调查<i class="fas fa-external-link-alt"></i></a>（2023 年）看到最受欢迎的构建工具，按使用量大致排序如下：</p><table><thead><tr><th>工具</th><th>默认转译为 ES5？</th><th>备注</th></tr></thead><tbody><tr><td><a class="link"   href="https://browsersl.ist/" >Browserslist<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>本身不是构建工具，但被许多构建工具内部使用，是配置浏览器支持目标的最流行开源工具。<a class="link"   href="https://browsersl.ist/#q=defaults" >defaults<i class="fas fa-external-link-alt"></i></a>设置不再包括任何 ES5 浏览器。最后一个是 IE 11，它在 4.21 版本中被<a class="link"   href="https://github.com/browserslist/browserslist/pull/701" >标记为已废弃<i class="fas fa-external-link-alt"></i></a>。</td></tr><tr><td><a class="link"   href="https://babeljs.io/" >Babel<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>Babel 的文档推荐设置<a class="link"   href="https://babeljs.io/docs/options#targets" >targets<i class="fas fa-external-link-alt"></i></a>选项（使用 Browserslist），但如果未指定，它将<a class="link"   href="https://babeljs.io/docs/options#no-targets" >转译所有代码为 ES5<i class="fas fa-external-link-alt"></i></a>。</td></tr><tr><td><a class="link"   href="https://webpack.js.org/" >webpack<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>默认情况下，webpack 不会转译任何代码。大多数 webpack 用户包括<a class="link"   href="https://webpack.js.org/loaders/babel-loader/" >babel-loader<i class="fas fa-external-link-alt"></i></a>，而 webpack 的<a class="link"   href="https://webpack.js.org/loaders/babel-loader/#usage" >使用示例<i class="fas fa-external-link-alt"></i></a>建议设置<code>targets: &quot;defaults&quot;</code>。</td></tr><tr><td><a class="link"   href="https://www.typescriptlang.org/tsconfig/#target" >TypeScript (tsc)<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>TypeScript 的默认<a class="link"   href="https://www.typescriptlang.org/tsconfig/#target" >target<i class="fas fa-external-link-alt"></i></a>选项是 ES5。</td></tr><tr><td><a class="link"   href="https://nextjs.org/" >Next.js<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>Next.js<a class="link"   href="https://nextjs.org/docs/pages/building-your-application/configuring/babel" >使用 Babel 进行转译<i class="fas fa-external-link-alt"></i></a>，默认设置一个 Browserslist 配置，目标是<a class="link"   href="https://nextjs.org/docs/architecture/supported-browsers" >“现代浏览器”<i class="fas fa-external-link-alt"></i></a>（即支持 ES 模块的浏览器）。</td></tr><tr><td><a class="link"   href="https://esbuild.github.io/" >esbuild<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>esbuild<a class="link"   href="https://esbuild.github.io/api/#target:~:text=The%20default%20target%20is%20esnext%20which%20means%20that%20by%20default%2C%20esbuild%20will%20assume%20all%20of%20the%20latest%20JavaScript%20and%20CSS%20features%20are%20supported." >默认不进行转译<i class="fas fa-external-link-alt"></i></a>。你可以设置自定义目标以启用转译，但 ES5 不支持作为转译目标。</td></tr><tr><td><a class="link"   href="https://vitejs.dev/" >Vite<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>Vite 使用 esbuild，默认设置自定义目标为<a class="link"   href="https://vitejs.dev/guide/build.html#browser-compatibility" >“现代浏览器”<i class="fas fa-external-link-alt"></i></a>（即支持 ES 模块的浏览器）。如果需要支持旧版浏览器，Vite 允许用户安装一个<a class="link"   href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy" >插件<i class="fas fa-external-link-alt"></i></a>。</td></tr><tr><td><a class="link"   href="https://rollupjs.org/" >Rollup<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>Rollup 默认不进行转译。许多 Rollup 用户安装<a class="link"   href="https://www.npmjs.com/package/@rollup/plugin-babel" >@rollup/plugin-babel<i class="fas fa-external-link-alt"></i></a>，在这种情况下使用 Babel 的默认配置。</td></tr><tr><td><a class="link"   href="https://parceljs.org/" >Parcel<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>Parcel<a class="link"   href="https://parceljs.org/features/production/#differential-bundling" >自动应用差异化服务<i class="fas fa-external-link-alt"></i></a>，并具有可自定义的目标。</td></tr><tr><td><a class="link"   href="https://github.com/google/closure-compiler" >Closure Compiler<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td><a class="link"   href="https://github.com/google/closure-compiler/wiki/Flags-and-Options#basic-usage" >默认<i class="fas fa-external-link-alt"></i></a>设置为<code>ECMASCRIPT_NEXT</code>，即最新的一组稳定的 ES 特性。</td></tr></tbody></table><p>如上表所示，绝大多数打包器和构建工具默认不再转译为 ES5。值得注意的是，较新的工具根本不支持 ES5，这表明趋势正在向这个方向发展。</p><p>尽管如此，Babel 仍然是最流行的 JavaScript 转译工具，因此在 Web 上转译为 ES5 仍然相当普遍（详见<a class="link"   href="https://philipwalton.com/articles/the-state-of-es5-on-the-web/?tab=t.0#heading=h.5ozt10xh7puo" >野外的 ES5 使用情况<i class="fas fa-external-link-alt"></i></a>）。</p><h3 id="流行的-JavaScript-库"><a href="#流行的-JavaScript-库" class="headerlink" title="流行的 JavaScript 库"></a>流行的 JavaScript 库</h3><p>除了查看流行的构建工具外，还查看了一些<a class="link"   href="https://2023.stateofjs.com/en-US/other-tools/#libraries" >当今最流行的库<i class="fas fa-external-link-alt"></i></a>（同样基于<a class="link"   href="https://2023.stateofjs.com/" >State of JS 调查<i class="fas fa-external-link-alt"></i></a>，按受欢迎程度大致排序）：</p><p>为了测试这些库中的每一个，我创建了一个仅导入该特定库的打包入口点，使用库文档中的一个代码示例。然后，我使用 Rollup 和 Webpack 打包代码，测试输出并查看是否包含任何 ES6+语法（特别是任何<a class="link"   href="https://caniuse.com/?search=es6#:~:text=Notable%20partial%20support%20in%20IE11%20includes%20(at%20least%20some)%20support%20for%20const%2C%20let%2C%20block%2Dlevel%20function%20declaration%2C%20typed%20arrays%2C%20Map%2C%20Set%20and%20WeakMap." >IE 11 不支持的 ES6+语法<i class="fas fa-external-link-alt"></i></a>）。</p><p>结果：</p><table><thead><tr><th>库</th><th>包含 ES6+语法？</th><th>备注</th></tr></thead><tbody><tr><td><a class="link"   href="https://lodash.com/" >Lodash<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>仅 ES5</td></tr><tr><td><a class="link"   href="https://react.dev/" >React<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>仅 ES5</td></tr><tr><td><a class="link"   href="https://date-fns.org/" >date-fns<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>箭头函数</td></tr><tr><td><a class="link"   href="https://threejs.org/" >three.js<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>async/await，箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://d3js.org/" >d3<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://www.framer.com/motion/" >Framer-motion<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://gsap.com/" >greensock<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>仅 ES5</td></tr><tr><td><a class="link"   href="https://day.js.org/" >dayjs<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>仅 ES5</td></tr><tr><td><a class="link"   href="https://github.com/colinhacks/zod" >Zod<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>async/await，箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://rxjs.dev/" >RxJS<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>箭头函数</td></tr><tr><td><a class="link"   href="https://immerjs.github.io/immer/" >immer<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://moment.github.io/luxon" >luxon<i class="fas fa-external-link-alt"></i></a></td><td>是</td><td>async/await，箭头函数，展开运算符，解构赋值</td></tr><tr><td><a class="link"   href="https://tanstack.com/query/" >react-query<i class="fas fa-external-link-alt"></i></a></td><td>否</td><td>仅 ES5（打包了 Babel 助手）</td></tr></tbody></table><p>如上所示，许多流行的 JavaScript 库现在发布的是 ES6+语法。</p><p>这很值得注意，因为正如我之前提到的，大多数使用 Babel 转译源文件的开发者在打包时，明确配置他们的打包器不转译<code>node_modules</code>目录中的任何内容——这是库作者历史上觉得需要继续转译为 ES5 的主要原因。</p><p>截至 2024 年 9 月：</p><ul><li>Webpack 的<code>babel-loader</code>文档<a class="link"   href="https://webpack.js.org/loaders/babel-loader/" >推荐的配置<i class="fas fa-external-link-alt"></i></a>排除了<code>node_modules</code>。</li><li>Rollup 的<code>plugin-babel</code>文档<a class="link"   href="https://www.npmjs.com/package/@rollup/plugin-babel#external-dependencies" >建议<i class="fas fa-external-link-alt"></i></a>排除<code>node_modules</code>，并且建议<a class="link"   href="https://www.npmjs.com/package/@rollup/plugin-babel#external-dependencies:~:text=We%20encourage%20library%20authors%20not%20to%20distribute%20code%20that%20uses%20untranspiled%20ES6%20features" >库作者不要发布 ES6 代码<i class="fas fa-external-link-alt"></i></a>。</li></ul><p>而 TypeScript（<code>tsc</code>），作为仅次于 Babel 的第二大转译工具，只会转译项目自己的代码文件。它不会转译<code>node_modules</code>中的项目依赖项。</p><p>这就为任何希望支持 ES5 并使用 Babel 或<code>tsc</code>转译代码的网站带来了问题。除非他们对构建管道的各个部分如何相互作用有深刻的理解，并且知道如何正确配置每一个部分，否则他们可能会在不知不觉中将 ES6+代码与 ES5 代码一起打包。</p><p>那么，这是否<em>真的</em>对实际网站造成了问题，还是大多数网站正确配置了他们的工具？下一节将通过<a class="link"   href="https://httparchive.org/" >HTTP Archive<i class="fas fa-external-link-alt"></i></a>的数据来回答这个问题。</p><p><strong>注意：</strong> 上表中的一些库发布了 ES5 和 ES6+版本，通常 ES5 版本设置在<code>package.main</code>字段，而 ES6+版本设置在<code>package.module</code>或<code>package.exports</code>字段。在这些情况下，我只查看了使用默认配置时打包器拉取的脚本版本（因为这是大多数人使用的），而今天的打包器默认使用<code>package.module</code>或<code>package.exports</code>而不是<code>package.main</code>（参见：<a class="link"   href="https://webpack.js.org/guides/package-exports/" >[1]<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://www.npmjs.com/package/@rollup/plugin-node-resolve" >[2]<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://esbuild.github.io/api/#conditions" >[3]<i class="fas fa-external-link-alt"></i></a>）。</p><h3 id="野外的-ES5-使用情况"><a href="#野外的-ES5-使用情况" class="headerlink" title="野外的 ES5 使用情况"></a>野外的 ES5 使用情况</h3><p>开发者用来将 ES6+代码转译为 ES5 的三大主要工具是：</p><ul><li>Babel</li><li>TypeScript（tsc）</li><li>Closure Compiler（即 Google 内部的 JSCompiler）</li></ul><p>这三种工具都包括某种形式的 polyfills 和所谓的 ES5“助手”函数，以避免在最终输出中重复。最常用的 ES5 助手函数库是：<a class="link"   href="https://babel.dev/docs/babel-helpers" >babel-helpers<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/zloirock/core-js" >core-js<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/facebook/regenerator" >regenerator-runtime<i class="fas fa-external-link-alt"></i></a>，<a class="link"   href="https://github.com/Microsoft/tslib" >tslib<i class="fas fa-external-link-alt"></i></a>，和<a class="link"   href="https://github.com/google/closure-compiler/tree/master/src/com/google/javascript/jscomp/js/es6" >$jscomp<i class="fas fa-external-link-alt"></i></a>。</p><p>这些助手库中的许多函数都足够独特，可以通过查询 HTTP Archive 来检测（即使在最小化代码中）哪些网站在使用它们。搜索这些助手函数的存在——而不是标准的 ES5 语法（如<code>var</code>或非箭头<code>function</code>）——有助于区分手写的旧 ES5 代码（通常相当优化）和由转译器生成的新 ES5 代码（通常相当臃肿）。</p><p>我在 HTTP Archive 上进行了<a class="link"   href="https://docs.google.com/spreadsheets/d/1WAJEf00fHP9ShJCjfSxJr3t7qQoILjgmGgeQsT5wdzQ/edit?gid=968981083#gid=968981083" >搜索<i class="fas fa-external-link-alt"></i></a>，看看流行网站（基于<a class="link"   href="https://developer.chrome.com/docs/crux/methodology/metrics#popularity-metric" >CrUX 受欢迎度排名<i class="fas fa-external-link-alt"></i></a>的前 10,000 个网站）在他们部署到生产环境的脚本包中包含这些助手的情况有多普遍。我还想看看网站提供未转译的 ES6+语法的情况有多普遍。</p><p>以下是我发现的结果（<a class="link"   href="https://docs.google.com/spreadsheets/d/1WAJEf00fHP9ShJCjfSxJr3t7qQoILjgmGgeQsT5wdzQ/edit?usp=sharing" >完整结果<i class="fas fa-external-link-alt"></i></a>）：</p><ul><li><strong>89%</strong> 的网站提供至少一个包含未转译 ES6+语法的 JavaScript 文件。</li><li><strong>79%</strong> 的网站提供至少一个包含 ES5 助手代码的 JavaScript 文件。</li><li><strong>68%</strong> 的网站提供至少一个同时包含 ES5 助手代码和未转译 ES6+语法的 JavaScript 文件。</li></ul><p>重申一下本文的观点——如果浏览器不支持 ES6+语法（如 IE 11），那么它在尝试加载包含 ES6+语法的脚本文件时会出错。而如果浏览器<em>确实</em>支持 ES6+语法，那么它不需要任何 ES5 助手代码或任何旧版 polyfills。绝对没有理由同时包含两者。</p><p>为了确认这个查询结果的准确性，手动测试了列表中的 20 个随机网站，确认它们确实在某些脚本包中同时包含 ES5 助手代码和 ES6+语法。还手动在 IE 11 中访问了这些网站，确认这些脚本包确实无法加载。</p><p>请记住，这些不仅仅是互联网上的随机网站。这些是全球最受欢迎的 10,000 个网站</p><h3 id="这意味着什么？"><a href="#这意味着什么？" class="headerlink" title="这意味着什么？"></a>这意味着什么？</h3><p>对于一个网站来说，提供包含 ES5 助手和未转译 ES6+语法的代码，实际上只有两种可能的解释：</p><ol><li>该网站不需要支持 ES5 浏览器，但他们的一些依赖项转译为 ES5，因此 ES5 代码出现在他们的输出中。</li><li>该网站<em>打算</em>支持 ES5 浏览器，但他们没有意识到一些依赖项发布了未转译的 ES6+语法，并且他们没有配置打包器来转译<code>node_modules</code>中的代码。</li></ol><p>无论是哪种解释，全球许多最受欢迎的网站都在提供大量不必要的代码，这强烈表明我们当前工具推荐的默认配置并不起作用。</p><p>如果从这些数据中能找到一丝安慰，那就是显而易见的是，放弃对 IE 的支持不会对大多数企业产生明显影响。如果所有这些大公司显然没有受到这些 IE 体验破坏的影响，那么你的公司也可能不会。</p><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="对于库作者"><a href="#对于库作者" class="headerlink" title="对于库作者"></a>对于库作者</h3><p>库作者应将代码转译为 ES5 的最初理由是大多数网站需要转译为 ES5。然而，鉴于目前前 10,000 个网站中有 89%发布了一些未转译的 ES6+语法，这一理由已不再有效。</p><p>根据本文提供的数据，JavaScript 库作者不再需要将代码转译为 ES5。</p><p>实际上，库作者对导入它们的网站的浏览器支持需求没有信息，因此不应该为其所有用户做出这个决定。同时，库作者也不应该假设所有用户都能够通过复杂的构建过程运行它们的库，因此发布的代码应使用完全标准的 JavaScript，并在当前广泛使用的浏览器中工作。</p><p>那么库作者应该选择什么目标？在我看来，库作者的最佳解决方案是使用<a class="link"   href="https://web.dev/baseline" >Baseline<i class="fas fa-external-link-alt"></i></a>——具体来说，只包括<a class="link"   href="https://web.dev/baseline#:~:text=Widely%20available%3A%2030%20months%20has%20passed%20since%20the%20newly%20interoperable%20date.%20The%20feature%20can%20be%20used%20by%20most%20sites%20without%20worrying%20about%20support." >Baseline Widely Available<i class="fas fa-external-link-alt"></i></a>特性在任何发布的代码中。</p><p>如果你不熟悉 Baseline，这是 W3C 内的<a class="link"   href="https://www.w3.org/community/webdx/" >WebDX 社区组<i class="fas fa-external-link-alt"></i></a>的一项努力，旨在帮助开发者轻松识别所有主要浏览器和浏览器渲染引擎在桌面和移动设备上稳定且广泛支持的特性。如果某个特性在所有四个主要浏览器的稳定版本中至少存在 30 个月，则被认为是<em>Baseline Widely Available</em>。</p><p>针对<em>Baseline Widely Available</em>的主要好处是它是一个动态目标，这意味着它不会像针对 ES5 那样被困在过去（这也是 Next.js、Vite 和 Parcel 使用的<code>esmodule</code>目标目前正在发生的情况）。</p><p>库作者可以通过以下<a class="link"   href="https://browsersl.ist/" >Browserslist<i class="fas fa-external-link-alt"></i></a>查询配置他们的构建系统，以现在针对<em>Baseline Widely Available</em>特性（适用于任何支持 Browserslist 的工具）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">targets</span>: [</span><br><span class="line">  <span class="string">&quot;chrome &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;edge &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;safari &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;firefox &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;and_chr &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;and_ff &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ios &gt;0 and last 2.5 years&quot;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 有一个开放的<a class="link"   href="https://github.com/browserslist/browserslist/issues/771" >功能请求<i class="fas fa-external-link-alt"></i></a>，希望将 Baseline 支持添加到 Browserslist，这将使上述查询简化为“baseline widely available”。</p><p>如果某个网站需要支持比<em>Baseline Widely Available</em>覆盖的更多浏览器，这完全没问题。该网站可以始终配置其构建系统以进一步转译任何导入的库。关键是这个决定最好由网站开发者做出，而不是库作者。</p><h3 id="对于网站开发者"><a href="#对于网站开发者" class="headerlink" title="对于网站开发者"></a>对于网站开发者</h3><p>许多网站开发在同一个脚本包中同时提供未转译的 ES6+语法和 ES5 助手代码，这清楚地表明排除<code>node_modules</code>目录不进行转译的做法并不是一个好做法。</p><p>然而，如今构建工具已经变得显著更快。此外，网站可以配置他们的构建，只在生产环境中处理<code>node_modules</code>中的代码。在开发中，代码应该在开发者使用的任何浏览器上运行良好，特别是如果库作者遵循我上面给出的建议并针对<em>Baseline Widely Available</em>。</p><h2 id="主要观点"><a href="#主要观点" class="headerlink" title="主要观点"></a>主要观点</h2><ul><li><strong>ES5 不再是构建工具或 JavaScript 库应该默认针对的目标。</strong> 如果工具仍然希望提供 ES5 支持，这应该是有特定支持需求的单个网站可以选择的。</li><li><strong>构建工具和库不应该使用固定的浏览器支持策略。</strong> 这些策略很快就会过时，这导致了本文数据中突出的问题。浏览器支持决策应该由网站本身做出，而不是它使用的工具。一个好的浏览器支持策略是<a class="link"   href="https://web.dev/baseline" >Baseline Widely Available<i class="fas fa-external-link-alt"></i></a>。</li><li><strong>导入第三方库的网站开发者应该将这些库作为其构建的一部分进行处理。</strong> 不能假设所有库作者都有与你相同的浏览器支持需求。正如本文数据所示，在许多情况下，网站开发者可能比他们导入的库有更广泛的浏览器支持需求（因此需要进一步转译它们）。</li><li><strong>跨浏览器支持不应该完全依赖于你的构建工具来处理。</strong> 如果需要支持特定的一组浏览器，那么你需要测试你的网站以确保它在这些浏览器中正常工作。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://philipwalton.com/articles/the-state-of-es5-on-the-web/" >The State of ES5 on the Web<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后一个</summary>
      
    
    
    
    <category term="原生" scheme="https://blog.flytam.vip/categories/%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="原生" scheme="https://blog.flytam.vip/tags/%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>setImmediate() vs setTimeout() 在 JavaScript 中的区别</title>
    <link href="https://blog.flytam.vip/setImmediate()%20vs%20setTimeout()%20%E5%9C%A8%20JavaScript%20%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB.html"/>
    <id>https://blog.flytam.vip/setImmediate()%20vs%20setTimeout()%20%E5%9C%A8%20JavaScript%20%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB.html</id>
    <published>2024-09-16T13:56:58.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><p>在 JavaScript 中，<code>setImmediate()</code> 和 <code>setTimeout()</code> 都用于调度任务，但它们的工作方式不同。</p><h2 id="JavaScript-的异步特性"><a href="#JavaScript-的异步特性" class="headerlink" title="JavaScript 的异步特性"></a>JavaScript 的异步特性</h2><p>JavaScript 以其非阻塞、异步行为而闻名，尤其是在 Node.js 环境中。如果你曾经参与过涉及定时器或回调的项目，你可能遇到过 <code>setTimeout()</code>，甚至 <code>setImmediate()</code>。乍一看，这两个函数似乎做的是同一件事——调度任务以便稍后运行。但如果你曾经一起运行它们，你可能会注意到一些有趣的行为。</p><p>尽管它们的目的相似，但 <code>setImmediate()</code> 和 <code>setTimeout()</code> 在底层的操作方式不同。如果你想知道为什么 <code>setImmediate()</code> 回调似乎一个接一个地运行，而 <code>setTimeout()</code> 回调则是间隔开的，本指南将为你解析其中的原因。</p><p>这不仅仅是 JavaScript 的一个怪癖；它与 Node.js 如何管理异步任务密切相关。理解这两个函数之间的差异将帮助你更好地控制代码的时间和执行顺序，这对于大型应用程序尤其重要，因为即使是时间上的微小失误也可能导致难以发现的错误。</p><p>我们将深入探讨事件循环，它如何处理这些定时器，以及为什么在一起使用它们时事情并不总是按预期发生。到最后，你将更清楚地了解何时使用 <code>setTimeout()</code> 或 <code>setImmediate()</code>，以满足你所需的时间行为。</p><h2 id="行为差异"><a href="#行为差异" class="headerlink" title="行为差异"></a>行为差异</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate 1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout 1&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout 2&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate 2&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当你运行这段代码时，你可能期望 <code>setTimeout</code> 回调按定义的顺序执行，然后是 <code>setImmediate</code> 回调。但你在控制台中看到的是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span> <span class="number">1</span></span><br><span class="line">setImmediate <span class="number">1</span></span><br><span class="line">setImmediate <span class="number">2</span></span><br><span class="line"><span class="built_in">setTimeout</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><p>如果这让你感到困惑，不要担心。让我们解开其中的原因。</p><h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>要理解这一点，我们需要快速了解 Node.js 如何管理异步操作。Node.js 的异步特性核心是事件循环。</p><p>在 Node.js 中，事件循环处理不同的阶段，每个阶段负责执行某些类型的回调。它帮助管理非阻塞任务，确保函数可以异步执行。在这些阶段中，有不同的队列。对于本次讨论，有两个队列是重要的：</p><ul><li><strong>宏任务队列</strong>：这是 <code>setTimeout</code> 和 <code>setImmediate</code> 等任务所在的地方。</li><li><strong>微任务队列</strong>：这是 promises (<code>Promise.then()</code>) 和 <code>process.nextTick()</code> 回调所在的地方。</li></ul><h3 id="事件循环的工作原理"><a href="#事件循环的工作原理" class="headerlink" title="事件循环的工作原理"></a>事件循环的工作原理</h3><p>要理解 <code>setTimeout()</code> 和 <code>setImmediate()</code> 的工作原理，我们需要看看 Node.js 中的事件循环。事件循环允许 Node.js 处理异步代码。它在不同的阶段处理不同类型的操作，每个阶段负责特定的任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure><ol><li><strong>定时器阶段</strong>：这是处理 <code>setTimeout()</code> 回调的地方。即使是 0 毫秒的延迟，它们也要等到下一次循环迭代才能执行。</li><li><strong>待处理回调阶段</strong>：处理已完成的 I/O 事件，但我们的示例中没有，所以跳过这个阶段。</li><li><strong>检查阶段</strong>：<code>setImmediate()</code> 回调在这里运行。它们在 I/O 任务之后立即执行，但在 <code>setTimeout()</code> 回调之前。</li><li><strong>轮询阶段</strong>：处理新的传入 I/O 操作，如文件读取或网络请求。如果没有 I/O，事件循环会跳过这个阶段。</li><li><strong>下一次循环迭代</strong>：在检查阶段之后，事件循环回到处理下一个定时器阶段，在那里 <code>setTimeout()</code> 回调最终运行。</li></ol><h3 id="setTimeout-的-0-延迟"><a href="#setTimeout-的-0-延迟" class="headerlink" title="setTimeout() 的 0 延迟"></a><code>setTimeout()</code> 的 0 延迟</h3><p>当你使用 <code>setTimeout()</code> 并设置延迟为 0 时，你实际上是在告诉 Node.js 在当前操作完成后尽快运行回调。然而，重要的是要记住，“尽快”仍然取决于事件循环的阶段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout 1 with 0 delay&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate 1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout 2 with 0 delay&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout 1 with 0 delay</span><br><span class="line">setImmediate 1</span><br><span class="line">setTimeout 2 with 0 delay</span><br></pre></td></tr></table></figure><p>即使延迟为 0，<code>setTimeout()</code> 回调仍然需要等待定时器阶段的下一次循环，因此不会立即运行。相反，它被放置在宏任务队列中，以便在下一个可用机会执行。</p><h3 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a><code>setImmediate()</code></h3><p>另一方面，<code>setImmediate()</code> 设计用于在 I/O 事件完成后执行回调，在同一事件循环迭代中。这意味着 <code>setImmediate()</code> 回调在额外的定时器（如 <code>setTimeout()</code>）执行之前被处理，特别是在没有 I/O 的情况下。</p><p>在我们的示例中，由于没有 I/O 发生，两个 <code>setImmediate()</code> 回调会一个接一个地执行，然后才轮到第二个 <code>setTimeout()</code> 回调。</p><h3 id="为什么-setImmediate-回调会一起运行？"><a href="#为什么-setImmediate-回调会一起运行？" class="headerlink" title="为什么 setImmediate 回调会一起运行？"></a>为什么 <code>setImmediate</code> 回调会一起运行？</h3><ol><li><strong>相同的事件循环周期</strong>：两个 <code>setImmediate</code> 调用在事件循环的同一个周期（或循环）中被放置到宏任务队列中。Node.js 按顺序处理这些任务。</li><li>**优先于 <code>setTimeout()</code>**：即使 <code>setTimeout()</code> 设定了 0 延迟，这也不保证立即执行。<code>setImmediate()</code> 回调在当前周期中优先于 <code>setTimeout()</code> 任务。</li></ol><h3 id="现实世界的类比"><a href="#现实世界的类比" class="headerlink" title="现实世界的类比"></a>现实世界的类比</h3><p>想象一下在餐馆点餐和饮料。</p><ol><li>你点了一道菜（代表 <code>setTimeout(0)</code>）。</li><li>厨师将其添加到订单队列中，一旦准备好就会送达。</li><li>同时，你要了一杯水（<code>setImmediate()</code>），由于它快速且容易准备，服务员会在你的食物完成之前立即送达。</li></ol><p>在这个类比中，水（快速任务）首先被处理，即使两个订单几乎同时下达。菜（稍微复杂一些）稍后送达。</p><h3 id="这种情况总是发生吗？"><a href="#这种情况总是发生吗？" class="headerlink" title="这种情况总是发生吗？"></a>这种情况总是发生吗？</h3><p>不一定。<code>setImmediate()</code> 和 <code>setTimeout()</code> 的行为可能取决于代码中发生的其他异步操作。如果有 I/O 操作，执行顺序可能会改变，因为 <code>setImmediate()</code> 只会在 I/O 事件完成后运行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout after I/O&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate after I/O&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setImmediate after I/O</span><br><span class="line">setTimeout after I/O</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>setImmediate()</code> 总是在 <code>setTimeout()</code> 之前运行，因为事件循环在 I/O 回调之后优先处理 <code>setImmediate()</code>。</p><p>当没有 I/O 事件时，两个 <code>setImmediate()</code> 回调会一个接一个地运行，然后才轮到 <code>setTimeout()</code> 回调。</p><h3 id="process-nextTick-和-Promises"><a href="#process-nextTick-和-Promises" class="headerlink" title="process.nextTick() 和 Promises"></a><code>process.nextTick()</code> 和 Promises</h3><p>以下示例展示了 Node.js 中各种异步操作的处理方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">setImmediate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setImmediate&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Promise then&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.<span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;process.nextTick&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick</span><br><span class="line">Promise then</span><br><span class="line">setTimeout</span><br><span class="line">setImmediate</span><br></pre></td></tr></table></figure><ul><li><code>process.nextTick()</code>：这将在任何其他任务之前运行，甚至在微任务（如 Promises）之前。</li><li><code>Promise.then()</code>：这是一个微任务，因此它在当前操作之后但在宏任务（如 <code>setTimeout()</code> 和 <code>setImmediate()</code>）之前运行。</li><li><code>setTimeout()</code>：在微任务处理完之后运行。</li><li><code>setImmediate()</code>：尽管它类似于 <code>setTimeout()</code>，但它在事件循环周期的后期运行，在当前 I/O 操作之后。</li></ul><p>Node.js 的异步行为有时可能会令人困惑，特别是在处理 <code>setTimeout()</code> 和 <code>setImmediate()</code> 时。关键是理解事件循环以及任务在不同阶段的调度方式。</p><ul><li><code>setImmediate()</code> 在 I/O 事件之后和当前事件循环周期内运行。</li><li><code>setTimeout()</code> 在指定的延迟之后运行，即使延迟为 0，它也会为下一次事件循环迭代调度任务。</li><li>当没有 I/O 操作时，<code>setImmediate()</code> 会在下一个 <code>setTimeout()</code> 之前连续执行。</li></ul><p>理解这些差异有助于你精确控制代码的运行时间，这在高性能应用程序中至关重要，因为时间和效率非常重要。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.trevorlasn.com/blog/setimmediate-vs-settimeout-in-javascript" >setImmediate() vs setTimeout() in JavaScript<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;在 JavaScript 中，&lt;c</summary>
      
    
    
    
    <category term="node 原生" scheme="https://blog.flytam.vip/categories/node-%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="node 原生" scheme="https://blog.flytam.vip/tags/node-%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 中的进程和线程原理学习</title>
    <link href="https://blog.flytam.vip/Node.js%20%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://blog.flytam.vip/Node.js%20%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0.html</id>
    <published>2024-09-16T13:50:43.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><blockquote><p>本文所有的代码均基于 node.js 14 LTS 版本分析</p></blockquote><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>进程是对正在运行中的程序的一个抽象，是系统进行资源分配和调度的基本单位，操作系统的其他所有内容都是围绕着进程展开的</p><p>线程是操作系统能够进行运算调度的最小单位，其是进程中的一个执行任务（控制单元），负责当前进程中程序的执行</p><p>一个进程至少有一个线程，一个进程可以运行多个线程，这些线程共享同一块内存，线程之间可以共享对象、资源</p><h2 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>)</span><br><span class="line">  .<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">    res.<span class="title function_">end</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;process id&quot;</span>, process.<span class="property">pid</span>);</span><br></pre></td></tr></table></figure><p><code>top -pid 28840</code> 查看线程数可见在这种情况下有 7 个线程</p><p><img src="https://files.mdnice.com/user/8265/168ed2ec-2a13-4eab-82f2-44b697b1ed67.png"></p><p>一个 node 进程通常包含：</p><ul><li>1 个 Javascript 执行主线程</li><li>1 个 watchdog 监控线程用于处理调试信息</li><li>1 个 v8 task scheduler 线程用于调度任务优先级</li><li>4 个 v8 线程用于执行代码调优与 GC 等后台任务</li><li>异步 I/O 的 libuv 线程池（如果涉及文件读写，默认为 4 个，可通过<code>process.env.UV_THREADPOOL_SIZE</code>进行设置。网络 I/O 不占用线程池）</li></ul><p><img src="https://files.mdnice.com/user/8265/e63c4aee-6206-4c03-94f6-f739c544d67a.png"></p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>既然 js 执行线程只有一个，那么 node 还能支持高并发在于 node 进程中通过 libuv 实现了一个事件循环机制，当执主程发生阻塞事件，如 I/O 操作时，主线程会将耗时的操作放入事件队列中，然后继续执行后续程序。<br>事件循环会尝试从 libuv 的线程池中取出一个空闲线程去执行队列中的操作，执行完毕获得结果后，通知主线程，主线程执行相关回调，并且将线程实例归还给线程池。通过此模式循环往复，来保证非阻塞 I/O，以及主线程的高效执行<br><br></p><p><img src="https://files.mdnice.com/user/8265/3c8f74fb-31cc-4739-ae68-4f8189ad3b49.png"></p><p>整个流程分为 2 个 while 循环</p><ul><li>外层大循环，执行 <code>uv_run</code> + <code>DrainVMTasks</code></li><li>内层 libuv <code>uv_run</code>事件循环</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/node_main_instance.h</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"> <span class="comment">// Start running the node.js instances, return the exit code when finished.</span></span><br><span class="line">  int <span class="title class_">Run</span>();</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// src/node_main_instance.cc</span></span><br><span class="line">namespace node &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">int <span class="attr">nodeMainInstance</span>::<span class="title class_">Run</span>() &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 执行一次libuv事件循环</span></span><br><span class="line">        <span class="title function_">uv_run</span>(env-&gt;<span class="title function_">event_loop</span>(), <span class="variable constant_">UV_RUN_DEFAULT</span>);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 执行v8中的一些挂起的任务队列的函数</span></span><br><span class="line">        <span class="attr">per_process</span>::v8_platform.<span class="title class_">DrainVMTasks</span>(isolate_);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查事件循环是否还有待处理</span></span><br><span class="line">        more = <span class="title function_">uv_loop_alive</span>(env-&gt;<span class="title function_">event_loop</span>());</span><br><span class="line">        <span class="comment">// 继续</span></span><br><span class="line">        <span class="keyword">if</span> (more &amp;&amp; !env-&gt;<span class="title function_">is_stopping</span>()) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无待处理</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_">uv_loop_alive</span>(env-&gt;<span class="title function_">event_loop</span>())) &#123;</span><br><span class="line">        <span class="comment">// 检查process.on(beforeExit)事件，若无退出</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="title class_">EmitProcessBeforeExit</span>(env.<span class="title function_">get</span>()).<span class="title class_">IsNothing</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若有继续下一轮循环处理一下</span></span><br><span class="line">        <span class="comment">// Emit `beforeExit` if the loop became alive either after emitting</span></span><br><span class="line">        <span class="comment">// event, or after running some callbacks.</span></span><br><span class="line">        more = <span class="title function_">uv_loop_alive</span>(env-&gt;<span class="title function_">event_loop</span>());</span><br><span class="line">  &#125; <span class="keyword">while</span> (more == <span class="literal">true</span> &amp;&amp; !env-&gt;<span class="title function_">is_stopping</span>());</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>主要有 libuv 提供的两个函数<code>uv_run</code> 和 <code>uv_loop_alive</code></p><ul><li><code>uv_run(env-&gt;event_loop(), UV_RUN_DEFAULT)</code> 执行一轮事件循环 。<code>UV_RUN_DEFAULT</code> 是 libuv 执行事件循环的执行模式，事件循环会一直运行直到没有更多的事件要处理或者程序被强制退出</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">  UV_RUN_DEFAULT = <span class="number">0</span>,<span class="comment">// 默认模式。在该模式下，事件循环会一直运行，直到没有更多的事件要处理或者程序被强制退出</span></span><br><span class="line">  UV_RUN_ONCE,<span class="comment">// 单次模式。在该模式下，事件循环只会运行一次，处理完所有当前已有的事件后立即退出。主要用于一些清理操作</span></span><br><span class="line">  UV_RUN_NOWAIT <span class="comment">// 非阻塞模式。在该模式下，事件循环会轮询当前的 I/O 事件，如果没有 I/O 事件需要处理则立即退出。在node代码中用来写单测</span></span><br><span class="line">&#125; uv_run_mode;</span><br></pre></td></tr></table></figure><p><code>uv_run</code>代码如下，它的返回值是<code>是否有活跃事件</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uv_run</span><span class="params">(<span class="type">uv_loop_t</span>* loop, uv_run_mode mode)</span> &#123;</span><br><span class="line">  <span class="type">int</span> timeout;</span><br><span class="line">  <span class="type">int</span> r;</span><br><span class="line">  <span class="type">int</span> ran_pending;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断有没有活跃的事件（事件监听 I/O、定时器等）</span></span><br><span class="line">  r = uv__loop_alive(loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 无活跃事件，更新时间 loop-&gt;time = uv__hrtime(UV_CLOCK_FAST) / 1000000</span></span><br><span class="line">  <span class="keyword">if</span> (!r)</span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  若有活跃事件进进入</span></span><br><span class="line">  <span class="keyword">while</span> (r != <span class="number">0</span> &amp;&amp; loop-&gt;stop_flag == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新处理时间</span></span><br><span class="line">    uv__update_time(loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行定时事件，从定时事件的最小堆里遍历出相较于loop-&gt;time 已过期的事件，并依次执行其回调</span></span><br><span class="line">    uv__run_timers(loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐️ 运行事件循环中当前已经被添加到队列中但还未执行的任务。如上次事件循环结束后进入的回调、IO结束的回调</span></span><br><span class="line">    ran_pending = uv__run_pending(loop);</span><br><span class="line">    <span class="comment">// 遍历并执行空转（Idle）事件 ，内部的低优先级的任务或者清理工作等操作</span></span><br><span class="line">    uv__run_idle(loop);</span><br><span class="line">    <span class="comment">// 遍历并执行准备（Prepare）事件，一些初始化工作或者准备工作，例如检查环境变量、加载配置文件等操作</span></span><br><span class="line">    uv__run_prepare(loop);</span><br><span class="line"></span><br><span class="line">    timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((mode == UV_RUN_ONCE &amp;&amp; !ran_pending) || mode == UV_RUN_DEFAULT)</span><br><span class="line">    <span class="comment">// 获取尚未触发的离现在最近的定时器的时间间隔（uv_backend_timeout），即事件循环到下一次循环的最长时间</span></span><br><span class="line">      timeout = uv_backend_timeout(loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐️ 去监听等待 I/O 事件触发，并以timeout的时间间隔作为最大监听时间，若超时还未有事件触发，则直接取消此次等待，剩下的会在下轮的uv__run_pending处理，因为要去处理定时器事件</span></span><br><span class="line">    <span class="comment">// timeout如果为0则马上进入下次循环不等待</span></span><br><span class="line">    uv__io_poll(loop, timeout);</span><br><span class="line">     <span class="comment">// 更新一下mertic一些统计相关，和事件循环好像没啥关系</span></span><br><span class="line">    uv__metrics_update_idle_time(loop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ⭐️ 遍历并执行复查（Check）事件</span></span><br><span class="line">    uv__run_check(loop);</span><br><span class="line">    <span class="comment">// ⭐️ 对于正在关闭的句柄（一些异步操作引用的底层资源释放）对其进行清理工作，如close事件</span></span><br><span class="line">    uv__run_closing_handles(loop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE) &#123;</span><br><span class="line">       <span class="comment">// 单次模式下更新下最新更新时间，再把定时器清理完下面就break，确保退出时没有一些定时器到期没执行</span></span><br><span class="line">      uv__update_time(loop);</span><br><span class="line">      uv__run_timers(loop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  又检查一遍是否还有活跃事件，因为在上述一系列操作，有可能一些事件已经处理了</span></span><br><span class="line">    r = uv__loop_alive(loop);</span><br><span class="line">    <span class="comment">// 只执行一次的退出</span></span><br><span class="line">    <span class="keyword">if</span> (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (loop-&gt;stop_flag != <span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 重置flag便于下次事件循环</span></span><br><span class="line">    loop-&gt;stop_flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uv_backend_timeout</code> 正常是查询最近的定时器间隔，有几种情况返回 0，即有一些更重要的事要做而不是同步等待 io 事件</p><p><img src="https://files.mdnice.com/user/8265/443ff555-415d-4bfd-ba94-8693a20e7148.png"></p><p>其中<code>idle_handles</code> 由<code>setImmediate</code> 设置执行一些高优任务，马上进入下一次循环处理<code>setImmediate</code>回调<br><br></p><p>一次事件循环总结</p><p><img src="https://files.mdnice.com/user/8265/b4602c47-98fe-4d44-90b6-4bb8b4859973.png"></p><ul><li><code>uv_loop_alive(env-&gt;event_loop())</code></li></ul><p>即上面提到的 uv__loop_alive， 判断有没有活跃的事件（事件监听 I/O、定时器等）<br><br></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>严格意义上来说对开发者写代码来说是单线程的，但是对于底层来说是多线程（例如源码中会有 SafeMap 这种线程安全的 map）。由于对于开发者来说是单线程，所以在 Node.js 日程开发中通常不会存在线程竞争的问题和线程锁的一些概念<br><br></p><h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><p>从上面的单线程机制可知 Node.js 使用事件循环机制来实现高并发的 I/O 操作。但是如果代码中遇到 CPU 密集型场景，主线程将会长时间阻塞，无法处理额外的请求。为了解决这个问题，并充分发挥多核 CPU 的性能，Node 提供了 <a class="link"   href="https://nodejs.org/docs/latest-v19.x/api/child_process.html" >child_process<i class="fas fa-external-link-alt"></i></a> 模块用于创建子进程。通过将 CPU 密集型操作分配给子进程处理，主线程可以继续处理其他请求，从而提高性能<br>主要提供了 4 个方法</p><ul><li><code>spawn(command[, args][, options])</code>：以指定的命令及参数数组创建一个子进程。可以通过<strong>流</strong>来处理子进程的输出和错误信息，大数据量</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; spawn &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ls = <span class="title function_">spawn</span>(<span class="string">&quot;ls&quot;</span>, [<span class="string">&quot;-lh&quot;</span>, <span class="string">&quot;/usr&quot;</span>]);</span><br><span class="line"></span><br><span class="line">ls.<span class="property">stdout</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.<span class="property">stderr</span>.<span class="title function_">on</span>(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`stderr: <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子进程退出码：<span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>exec(command[, options][, callback])</code>：对 <code>spawn()</code> 函数的封装，可以直接传入命令行执行，并以<strong>回调函数</strong>的形式返回输出和错误信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">exec</span>(<span class="string">&quot;ls -lh /usr&quot;</span>, <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`exec error: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>execFile(file[, args][, options][, callback])</code>：类似于 <code>exec()</code> 函数，但默认不会创建命令行环境（相应的无法使用一些 shell 的操作符），而是直接以传入的文件创建新的进程，性能略微优于 <code>exec()</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"><span class="title function_">execFile</span>(<span class="string">&quot;ls&quot;</span>, [<span class="string">&quot;-lh&quot;</span>, <span class="string">&quot;/usr&quot;</span>], <span class="function">(<span class="params">error, stdout, stderr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`execFile error: <span class="subst">$&#123;error&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`stdout: <span class="subst">$&#123;stdout&#125;</span>`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`stderr: <span class="subst">$&#123;stderr&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>fork(modulePath[, args][, options])</code>：内部使用 <code>spawn()</code>实现 ，只能用于创建 node.js 程序的子进程，默认会建立父子进程之间的 IPC 信道来传递消息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; fork &#125; = <span class="built_in">require</span>(<span class="string">&quot;child_process&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lsProcess = <span class="title function_">fork</span>(<span class="string">&quot;./test.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">lsProcess.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`收到子进程的消息：<span class="subst">$&#123;msg&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">lsProcess.<span class="title function_">on</span>(<span class="string">&quot;close&quot;</span>, <span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`子进程退出码：<span class="subst">$&#123;code&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>js - <code>lib/child_process.js</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">&quot;internal/child_process&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">ChildProcess</span> &#125; = child_process;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">spawn</span>(<span class="params">file, args, options</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> child = <span class="keyword">new</span> <span class="title class_">ChildProcess</span>();</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">return</span> child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  _forkChild,</span><br><span class="line">  <span class="title class_">ChildProcess</span>,</span><br><span class="line">  exec,</span><br><span class="line">  execFile,</span><br><span class="line">  execFileSync,</span><br><span class="line">  execSync,</span><br><span class="line">  fork,</span><br><span class="line">  <span class="attr">spawn</span>: spawnWithSignal,</span><br><span class="line">  spawnSync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>lib/internal/child_process.js</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Process</span> &#125; = <span class="title function_">internalBinding</span>(<span class="string">&quot;process_wrap&quot;</span>);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">_handle</span> = <span class="keyword">new</span> <span class="title class_">Process</span>();</span><br><span class="line"></span><br><span class="line"><span class="title class_">ChildProcess</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">spawn</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">const</span> err = <span class="variable language_">this</span>.<span class="property">_handle</span>.<span class="title function_">spawn</span>(options);</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>c++ - <code>src/node_binding.cc</code></li></ul><p><img src="https://files.mdnice.com/user/8265/795f1884-3dce-4c34-b29b-791d80f0ba0f.png"></p><p><img src="https://files.mdnice.com/user/8265/97eeffed-7aa0-40a9-ac5a-ba4f37dc509e.png"></p><br><ul><li><code>src/process_wrap.cc</code></li></ul><p><img src="https://files.mdnice.com/user/8265/61c1ba42-5f62-4d6f-bdaf-43cda203d564.png"></p><p><img src="https://files.mdnice.com/user/8265/71232006-83e5-487f-b044-bf1eaa01dd39.png"></p><h3 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h3><p>基于<code>child_process</code> node 提供了专门用于创建多进程网络服务的<code>[cluster](https://nodejs.org/api/cluster.html)</code>模块<br>创建多个子进程，并在每个子进程中启动一个独立的 HTTP 服务器进行监听和处理客户端请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>).<span class="title function_">cpus</span>().<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.<span class="property">isMaster</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Master <span class="subst">$&#123;process.pid&#125;</span> is running`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建多个子进程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.<span class="title function_">fork</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 监听子进程退出事件，自动重启</span></span><br><span class="line">  cluster.<span class="title function_">on</span>(<span class="string">&quot;exit&quot;</span>, <span class="function">(<span class="params">worker, code, signal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Worker <span class="subst">$&#123;worker.process.pid&#125;</span> died`</span>);</span><br><span class="line">    cluster.<span class="title function_">fork</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Worker <span class="subst">$&#123;process.pid&#125;</span> started`</span>);</span><br><span class="line">  <span class="comment">// 每个子进程的pid是不一样</span></span><br><span class="line">  <span class="comment">// 在每个子进程中启动 HTTP 服务器</span></span><br><span class="line">  http</span><br><span class="line">    .<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">      res.<span class="title function_">writeHead</span>(<span class="number">200</span>);</span><br><span class="line">      res.<span class="title function_">end</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .<span class="title function_">listen</span>(<span class="number">8000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何解决多个工作进程监听一个端口的问题</p><blockquote><p>从 js 层面分析</p></blockquote><ul><li>入口区分 - 子进程环境变量含<code>NODE_UNIQUE_ID</code>，在创建子进程时传入</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/cluster.js</span></span><br><span class="line"><span class="keyword">const</span> childOrMaster = <span class="string">&quot;NODE_UNIQUE_ID&quot;</span> <span class="keyword">in</span> process.<span class="property">env</span> ? <span class="string">&quot;child&quot;</span> : <span class="string">&quot;master&quot;</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="built_in">require</span>(<span class="string">`internal/cluster/<span class="subst">$&#123;childOrMaster&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><ul><li><code>http.createServer</code> -&gt; <code>lib/_http_server.js#Server</code> - <code>lib/_http_server.js#Server</code> 继承于 TCP 的<code>lib/net.js#Server</code></li><li><code>listen</code>方法调用的是<code>lib/net.js#Server</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/net.js</span></span><br><span class="line"><span class="title class_">Server</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">listen</span> = <span class="keyword">function</span> (<span class="params">...args</span>) &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">  <span class="comment">// 关键逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> options.<span class="property">port</span> === <span class="string">&quot;number&quot;</span> || <span class="keyword">typeof</span> options.<span class="property">port</span> === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">validatePort</span>(options.<span class="property">port</span>, <span class="string">&quot;options.port&quot;</span>);</span><br><span class="line">    backlog = options.<span class="property">backlog</span> || backlogFromArgs;</span><br><span class="line">    <span class="comment">// start TCP server listening on host:port</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">host</span>) &#123;</span><br><span class="line">      <span class="title function_">lookupAndListen</span>(</span><br><span class="line">        <span class="variable language_">this</span>,</span><br><span class="line">        options.<span class="property">port</span> | <span class="number">0</span>,</span><br><span class="line">        options.<span class="property">host</span>,</span><br><span class="line">        backlog,</span><br><span class="line">        options.<span class="property">exclusive</span>,</span><br><span class="line">        flags</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Undefined host, listens on unspecified address</span></span><br><span class="line">      <span class="comment">// Default addressType 4 will be used to search for master server</span></span><br><span class="line">      <span class="title function_">listenInCluster</span>(</span><br><span class="line">        <span class="variable language_">this</span>,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        options.<span class="property">port</span> | <span class="number">0</span>,</span><br><span class="line">        <span class="number">4</span>,</span><br><span class="line">        backlog,</span><br><span class="line">        <span class="literal">undefined</span>,</span><br><span class="line">        options.<span class="property">exclusive</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lookupAndListen</code>内部其实也是对<code>option.host</code>进行调<code>dns</code>模块查询<code>host</code>后调的<code>listenInCluster</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工作进程</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listenInCluster</span>(<span class="params"></span></span><br><span class="line"><span class="params">  server,</span></span><br><span class="line"><span class="params">  address,</span></span><br><span class="line"><span class="params">  port,</span></span><br><span class="line"><span class="params">  addressType,</span></span><br><span class="line"><span class="params">  backlog,</span></span><br><span class="line"><span class="params">  fd,</span></span><br><span class="line"><span class="params">  exclusive,</span></span><br><span class="line"><span class="params">  flags</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  exclusive = !!exclusive;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cluster === <span class="literal">undefined</span>) cluster = <span class="built_in">require</span>(<span class="string">&quot;cluster&quot;</span>);</span><br><span class="line">  <span class="comment">// isMaster是通过NODE_UNIQUE_ID是否存在判断</span></span><br><span class="line">  <span class="comment">// 非cluster的http模块直接起服务NODE_UNIQUE_ID是空</span></span><br><span class="line">  <span class="keyword">if</span> (cluster.<span class="property">isMaster</span> || exclusive) &#123;</span><br><span class="line">    server.<span class="title function_">_listen2</span>(address, port, addressType, backlog, fd, flags);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> serverQuery = &#123;</span><br><span class="line">    <span class="attr">address</span>: address,</span><br><span class="line">    <span class="attr">port</span>: port,</span><br><span class="line">    <span class="attr">addressType</span>: addressType,</span><br><span class="line">    <span class="attr">fd</span>: fd,</span><br><span class="line">    flags,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  cluster.<span class="title function_">_getServer</span>(server, serverQuery, listenOnMasterHandle);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">listenOnMasterHandle</span>(<span class="params">err, handle</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取handler后挂载到子进程server上</span></span><br><span class="line">    server.<span class="property">_handle</span> = handle;</span><br><span class="line">    server.<span class="title function_">_listen2</span>(address, port, addressType, backlog, fd, flags);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 listenInCluster 函数中，会判断当前的进程是否是主进程，</p><ul><li>如果是则直接进行调用<code>_listen2</code>监听<code>server</code>。<code>_listen2</code>就是 cluster 出现之前的监听函数</li></ul><p><code>Server.prototype._listen2 = setupListenHandle; // legacy alias</code></p><ul><li>如果不是，则通过工作进程查询到主进程的 <code>handle</code> （<code>const &#123; TCP &#125; = internalBinding(&#39;tcp_wrap&#39;);</code> ，c++层暴露的用于处理 TCP 的对象），然后在主进程的 handle 上进行监听</li></ul><p><code>cluster._getServer</code>实现<br>主要逻辑是向当前工作进程发送一个类型为 queryServer 的消息，这个消息会被处理成 cluster 内部消息后发送给主进程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/cluster/child.js</span></span><br><span class="line">cluster.<span class="property">_getServer</span> = <span class="keyword">function</span>(<span class="params">obj, options, cb</span>) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> message = &#123;</span><br><span class="line">    <span class="attr">act</span>: <span class="string">&#x27;queryServer&#x27;</span>,</span><br><span class="line">    index,</span><br><span class="line">    <span class="attr">data</span>: <span class="literal">null</span>,</span><br><span class="line">    ...options</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  message.<span class="property">address</span> = address;</span><br><span class="line">  <span class="title function_">send</span>(message, <span class="function">(<span class="params">reply, handle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 进这个分支</span></span><br><span class="line">      <span class="title function_">rr</span>(reply, indexesKey, cb);              <span class="comment">// Round-robin.</span></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  obj.<span class="title function_">once</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">    <span class="title function_">send</span>(message);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主进程有相应的响应 queryServer 消息的地方</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/cluster/master.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onmessage</span>(<span class="params">message, handle</span>) &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="property">act</span> === <span class="string">&#x27;queryServer&#x27;</span>)</span><br><span class="line">    <span class="title function_">queryServer</span>(worker, message);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">queryServer</span>(<span class="params">worker, message</span>) &#123;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">// 唯一标识</span></span><br><span class="line"> <span class="keyword">const</span> key = <span class="string">`<span class="subst">$&#123;message.address&#125;</span>:<span class="subst">$&#123;message.port&#125;</span>:<span class="subst">$&#123;message.addressType&#125;</span>:`</span> +</span><br><span class="line">              <span class="string">`<span class="subst">$&#123;message.fd&#125;</span>:<span class="subst">$&#123;message.index&#125;</span>`</span>;</span><br><span class="line">  <span class="keyword">let</span> handle = handles.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (handle === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> address = message.<span class="property">address</span>;</span><br><span class="line">    <span class="comment">//第一次进入时，会创建RoundRobinHandle，RoundRobinHandle内部有实际监听端口的逻辑</span></span><br><span class="line">    <span class="keyword">let</span> constructor = <span class="title class_">RoundRobinHandle</span>;</span><br><span class="line">    handle = <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">key, address, message</span>);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    handles.<span class="title function_">set</span>(key, handle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!handle.<span class="property">data</span>)</span><br><span class="line">    handle.<span class="property">data</span> = message.<span class="property">data</span>;</span><br><span class="line">    <span class="comment">// 添加当前工作进程加入到RoundRobinHandle工作队列</span></span><br><span class="line">  handle.<span class="title function_">add</span>(worker, <span class="function">(<span class="params">errno, reply, handle</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = handles.<span class="title function_">get</span>(key);</span><br><span class="line">    <span class="title function_">send</span>(worker, &#123;</span><br><span class="line">      errno,</span><br><span class="line">      key,</span><br><span class="line">      <span class="attr">ack</span>: message.<span class="property">seq</span>,</span><br><span class="line">      data,</span><br><span class="line">      ...reply</span><br><span class="line">    &#125;, handle);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lib/internal/cluster/round_robin_handle.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">RoundRobinHandle</span>(<span class="params">key, address, &#123; port, fd, flags &#125;</span>) &#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">server</span> = net.<span class="title function_">createServer</span>(assert.<span class="property">fail</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">listen</span>(address);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主进程处理请求分发</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">server</span>.<span class="title function_">once</span>(<span class="string">&#x27;listening&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handle</span> = <span class="variable language_">this</span>.<span class="property">server</span>.<span class="property">_handle</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handle</span>.<span class="property">onconnection</span> = <span class="function">(<span class="params">err, handle</span>) =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">distribute</span>(err, handle);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RoundRobinHandle 也会覆盖主进程的<code>Server.handle</code> 的 onconnection 逻辑，将其替换成 round-robin 逻辑，即<code>this.handle.onconnection = (err, handle) =&gt; this.distribute(err, handle);</code><br><br></p><p>再回到这个代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 工作进程</span></span><br><span class="line">  cluster.<span class="title function_">_getServer</span>(server, serverQuery, listenOnMasterHandle);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _getServer实现</span></span><br><span class="line">  <span class="title function_">send</span>(message, <span class="function">(<span class="params">reply, handle</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 进这个分支</span></span><br><span class="line">    <span class="comment">// reply</span></span><br><span class="line">      <span class="title function_">rr</span>(reply, indexesKey, cb);              <span class="comment">// Round-robin.</span></span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">listenOnMasterHandle</span>(<span class="params">err, handle</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取handler后挂载到子进程server上</span></span><br><span class="line">    server.<span class="property">_handle</span> = handle;</span><br><span class="line">    server.<span class="title function_">_listen2</span>(address, port, addressType, backlog, fd, flags);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在 rr 函数中创建一个 fake handler 返回</p><p><img src="https://files.mdnice.com/user/8265/18a14618-865c-469c-9a2c-cacfc821bdb1.png"></p><p><img src="https://files.mdnice.com/user/8265/831a34ff-11b0-45f2-b3d9-c464b56070af.png"></p><br><p>这个 handler 就是上面 rr 函数中获取的 handler，而<code>_listen2</code>内部调用的实际是 fake handler 中的 listen 空函数，实际上工作进程并没有对端口进行监听<br>RoundRobinHandle 的<code>distribute</code>实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/cluster/round_robin_handle.js</span></span><br><span class="line"><span class="title class_">RoundRobinHandle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">distribute</span> = <span class="keyword">function</span> (<span class="params">err, handle</span>) &#123;</span><br><span class="line">  <span class="title class_">ArrayPrototypePush</span>(<span class="variable language_">this</span>.<span class="property">handles</span>, handle);</span><br><span class="line">  <span class="keyword">const</span> [workerEntry] = <span class="variable language_">this</span>.<span class="property">free</span>; <span class="comment">// this.free is a SafeMap</span></span><br><span class="line">  <span class="comment">// 选择一个空闲的进程处理</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">ArrayIsArray</span>(workerEntry)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; <span class="number">0</span>: workerId, <span class="number">1</span>: worker &#125; = workerEntry;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">free</span>.<span class="title function_">delete</span>(workerId);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handoff</span>(worker);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">RoundRobinHandle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">handoff</span> = <span class="keyword">function</span> (<span class="params">worker</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> handle = <span class="title class_">ArrayPrototypeShift</span>(<span class="variable language_">this</span>.<span class="property">handles</span>);</span><br><span class="line">  <span class="keyword">const</span> message = &#123; <span class="attr">act</span>: <span class="string">&quot;newconn&quot;</span>, <span class="attr">key</span>: <span class="variable language_">this</span>.<span class="property">key</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 取出handler分发给子进程，消息的act为newconn</span></span><br><span class="line">  <span class="title function_">sendHelper</span>(worker.<span class="property">process</span>, message, handle, <span class="function">(<span class="params">reply</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用轮询进行分发</span></span><br><span class="line">    <span class="keyword">if</span> (reply.<span class="property">accepted</span>) handle.<span class="title function_">close</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="variable language_">this</span>.<span class="title function_">distribute</span>(<span class="number">0</span>, handle); <span class="comment">// Worker is shutting down. Send to another.</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">handoff</span>(worker);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>工作进程处理<code>newconn</code>消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/internal/cluster/child.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sendHelper分发的事件会带上cmd: &#x27;NODE_CLUSTER&#x27;，NODE_前缀的会触发internalMessage</span></span><br><span class="line">process.<span class="title function_">on</span>(<span class="string">&quot;internalMessage&quot;</span>, <span class="title function_">internal</span>(worker, onmessage));</span><br><span class="line"><span class="title function_">send</span>(&#123; <span class="attr">act</span>: <span class="string">&quot;online&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onmessage</span>(<span class="params">message, handle</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (message.<span class="property">act</span> === <span class="string">&quot;newconn&quot;</span>) <span class="title function_">onconnection</span>(message, handle);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (message.<span class="property">act</span> === <span class="string">&quot;disconnect&quot;</span>)</span><br><span class="line">    <span class="title class_">ReflectApply</span>(_disconnect, worker, [<span class="literal">true</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">onconnection</span>(<span class="params">message, handle</span>) &#123;</span><br><span class="line">  <span class="comment">// 在子进程接收到handle引用后，它会重新创建一个与主进程相对应的 handle 对象，从而实现对共享资源的访问</span></span><br><span class="line">  <span class="keyword">const</span> key = message.<span class="property">key</span>;</span><br><span class="line">  <span class="keyword">const</span> server = handles.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">const</span> accepted = server !== <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">send</span>(&#123; <span class="attr">ack</span>: message.<span class="property">seq</span>, accepted &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (accepted)</span><br><span class="line">    <span class="comment">// lib/net.js里面tcp server的onconnection处理</span></span><br><span class="line">    server.<span class="title function_">onconnection</span>(<span class="number">0</span>, handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>当主进程的 RoundRobinHandle 接收到一个监听请求时，它会调用<code>distribute</code>函数将客户端的 handle（socket 对象） 传递给工作进程。具体的逻辑为：将这个 handle 保存到队列中，并从工作进程队列中获取一个空闲的工作进程。如果存在空闲的工作进程，则从队列中取出一个工作进程并向其发送<code>act: &quot;newconn&quot;</code> 消息，以将 handle 传递给工作进程。工作进程会使用此 handle 与客户端建立连接，并向主进程发送一条消息表示是否接受了请求。主进程通过 accepted 属性来判断工作进程是否已经接受了请求。如果是则关闭与客户端的连接，并让其与工作进程进行通信。最后，主进程会不断地轮询上述过程以处理更多的客户端请求</p><p><img src="https://files.mdnice.com/user/8265/8a803db5-da1c-4d11-8a7b-d02706517e8d.png"></p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>为了降低 js 对于 CPU 密集型任务计算的负担，node.js v10 之后引入了 <a class="link"   href="https://nodejs.org/api/worker_threads.html" >worker_threads<i class="fas fa-external-link-alt"></i></a>。可以在 nodejs 进程内可以创建多个线程。主线程和 worker 线程之间可以通过<code>parentPort</code>实现通信，worker 线程之间可以使用 <code>MessageChannel</code> 进行通信。多个线程之间可以使用<code>SharedArrayBuffer</code>实现共享内存，无需序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="title class_">Worker</span>,</span><br><span class="line">  isMainThread,</span><br><span class="line">  parentPort,</span><br><span class="line">  workerData,</span><br><span class="line">&#125; = <span class="built_in">require</span>(<span class="string">&quot;worker_threads&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">  <span class="comment">// 主线程创建共享内存</span></span><br><span class="line">  <span class="keyword">const</span> sharedBuffer = <span class="keyword">new</span> <span class="title class_">SharedArrayBuffer</span>(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">const</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(__filename, &#123; <span class="attr">workerData</span>: sharedBuffer &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向子线程发送共享内存的引用</span></span><br><span class="line">  worker.<span class="title function_">postMessage</span>(sharedBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接收子线程发送的消息</span></span><br><span class="line">  worker.<span class="title function_">on</span>(<span class="string">&quot;message&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sharedBuffer&quot;</span>, sharedBuffer);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 子线程接收主线程发送的共享内存引用，并使用Atomics操作进行读写</span></span><br><span class="line">  <span class="keyword">const</span> sharedBuffer = workerData;</span><br><span class="line">  <span class="keyword">const</span> sharedArray = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(sharedBuffer);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> oldValue = <span class="title class_">Atomics</span>.<span class="title function_">load</span>(sharedArray, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">const</span> newValue = oldValue + <span class="number">1</span>;</span><br><span class="line">    <span class="title class_">Atomics</span>.<span class="title function_">store</span>(sharedArray, <span class="number">0</span>, newValue);</span><br><span class="line">    parentPort.<span class="title function_">postMessage</span>(<span class="string">`Current value in shared memory: <span class="subst">$&#123;newValue&#125;</span>`</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程下共享内存为避免者竞态条件。node.js 也提供了<code>Atomics</code>对象用于执行原子操作，可以保证多个线程对共享内存的读写操作原子性<br><br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文所有</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（下）</title>
    <link href="https://blog.flytam.vip/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8B%EF%BC%89.html"/>
    <id>https://blog.flytam.vip/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8B%EF%BC%89.html</id>
    <published>2024-08-29T13:51:50.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><p>书接<a class="link"   href="https://github.com/flytam/blog/issues/43" >上回<i class="fas fa-external-link-alt"></i></a>，我们已经实现了一个 <code>langchain.js</code> 接入火山引擎的 <code>ChatModel</code>。</p><p>本文我们实现将这个大模型接入到聊天 CLI 实现和大模型进行交互式问答</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>我们希望这个简易的聊天 CLI 能够拥有以下功能</p><ul><li>启动时由用户输入 prompt</li><li>支持回答流式输出</li><li>支持连续聊天和清空上下文</li></ul><h2 id="聊天-CLI-基础能力实现"><a href="#聊天-CLI-基础能力实现" class="headerlink" title="聊天 CLI 基础能力实现"></a>聊天 CLI 基础能力实现</h2><p>由于实现基本的 CLI 输入输出不是本文重点。这里我们直接通过以下代码实现一个简单的 node.js 交互式程序，实现了</p><ul><li>启动后接收用户输入的 prompt</li><li>接收<code>/clear</code> 指令打印清空</li><li>其它输入后原样打印</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">&#x27;node:readline&#x27;</span></span><br><span class="line"><span class="keyword">import</span> process, &#123; stdin, stdout &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EventEmitter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:events&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatCli</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span> = stdin</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span> = stdout</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span>.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span>.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">runInputLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prompt = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入 prompt\n &gt; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prompt&#x27;</span>, prompt)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(<span class="variable language_">this</span>.<span class="property">input</span>, <span class="variable language_">this</span>.<span class="property">output</span>)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">setPrompt</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">      rl.<span class="title function_">prompt</span>()</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">async</span> (line) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (line === <span class="string">&#x27;\\clear&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;清空上下文\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">`xxx <span class="subst">$&#123;line&#125;</span>`</span>)</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">prompt</span>()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, resolve)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rl.<span class="title function_">close</span>()</span><br><span class="line">        process.<span class="title function_">emit</span>(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="string">&#x27;SIGINT&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">write</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span>.<span class="title function_">write</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">prompt</span>(<span class="params">query = <span class="string">&#x27;&gt; &#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(<span class="variable language_">this</span>.<span class="property">input</span>, <span class="variable language_">this</span>.<span class="property">output</span>)</span><br><span class="line">      rl.<span class="title function_">question</span>(query, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(answer)</span><br><span class="line">        rl.<span class="title function_">close</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cli = <span class="keyword">new</span> <span class="title class_">ChatCli</span>()</span><br><span class="line"></span><br><span class="line">cli.<span class="title function_">runInputLoop</span>()</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/8265/caf96015-dd6f-4464-baab-b1e619b83c04.png"></p><h2 id="大模型接入"><a href="#大模型接入" class="headerlink" title="大模型接入"></a>大模型接入</h2><p>由于聊天 CLI 已经实现，我们只需要在对应的代码点进行模型的交互。相关接入火山引擎细节见<a class="link"   href="https://github.com/flytam/blog/issues/43" >LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（上）<i class="fas fa-external-link-alt"></i></a></p><h3 id="初始化-langchain-火山大模型"><a href="#初始化-langchain-火山大模型" class="headerlink" title="初始化 langchain 火山大模型"></a>初始化 langchain 火山大模型</h3><p>构造函数中初始化火山大模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChatVolcengine</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;langchain-bytedance-volcengine&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatCli</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// 初始化火山大模型</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chatModel</span> = <span class="keyword">new</span> <span class="title class_">ChatVolcengine</span>(&#123;</span><br><span class="line">      <span class="attr">volcengineApiHost</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_HOST</span>,</span><br><span class="line">      <span class="attr">volcengineApiKey</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_API_KEY</span>,</span><br><span class="line">      <span class="attr">model</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_MODEL</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prompt-接收和大模型聊天交互"><a href="#prompt-接收和大模型聊天交互" class="headerlink" title="prompt 接收和大模型聊天交互"></a>prompt 接收和大模型聊天交互</h3><ul><li><p>将接受的 prompt 作为<code>SystemMessage</code>和将用户输入作为 <code>HumanMessage</code>传入<code>stream</code>方法。这里的<code>SystemMessage</code>和<code>HumanMessage</code>也是 langchain 提供的工具类用于构造消息</p></li><li><p>解析大模型返回的流式数据输出到终端</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HumanMessage</span>, <span class="title class_">SystemMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/messages&#x27;</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">async</span> <span class="title function_">runInputLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> prompt = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入 prompt\n &gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">async</span> (line) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (line === <span class="string">&#x27;\\clear&#x27;</span>) &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;清空上下文\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> stream = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">chatModel</span>.<span class="title function_">stream</span>([<span class="keyword">new</span> <span class="title class_">SystemMessage</span>(prompt), <span class="keyword">new</span> <span class="title class_">HumanMessage</span>(line)])</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">write</span>(chunk.<span class="property">content</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>运行效果</p><p><img src="https://files.mdnice.com/user/8265/71d1bbad-818c-4e79-805c-b7d1b605180d.png"></p><h3 id="连续聊天能力实现"><a href="#连续聊天能力实现" class="headerlink" title="连续聊天能力实现"></a>连续聊天能力实现</h3><p>虽然我们已经和 CLI 打通了和大模型的交互聊天，但是此时聊天 CLI 是没有聊天上下文功能的。</p><p><img src="https://files.mdnice.com/user/8265/29788890-1bf7-490a-b3ff-34a74bed0642.png"></p><p>我们需要为这个聊天 CLI 增加上下文功能。对于直接调用大模型 OPEN API 来说，这通常需要我们将上下文手动处理传入大模型的 API。</p><p>但是上面提过，作为一个强大的 LLM 应用开发框架，langchain 提供了开箱即用的能力帮助我们实现。</p><p><code>langchain</code> 只所以称为 <code>chain</code>，它是可以以自定义<code>chain</code>的形式将多个工具串联起来使用。每个串联起来的工具必须是一个实现了 <code>Runnable</code> 接口的实例，目前 langchain 中实现了<code>Runnable</code> 接口的组件有 <code>Prompt</code> <code>ChatModel</code> <code>LLM</code> <code>OutputParser</code> <code>Retriever</code> <code>Tool</code></p><p>这里我们使用 langchain 提供的<code>RunnableWithMessageHistory</code>进行聊天上下文的记录和调用；使用<code>InMemoryChatMessageHistory</code>来实现内存的聊天上下文的存储</p><p>修改代码实现如下</p><ul><li><p>通过 <code>ChatPromptTemplate.fromMessages</code> 来初始化传给模型的完整 prompt。其中第一项为我们输入的<code>SystemMessage</code>，第二项为占位传递的历史上下文，第三项是本次我们的输入</p></li><li><p>通过自定义链将这个<code>prompt</code>和我们的火山<code>chatModel</code>串联起来</p></li><li><p>将自定义链传递给<code>RunnableWithMessageHistory</code>构造出 <code>withMessageHistory</code> 对象，并实现聊天历史的上下文对象</p></li><li><p>通过 <code>withMessageHistory.stream</code> 进行模型的调用，并同时传递本次的上下文<code>config</code>对象</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">ChatPromptTemplate</span>,</span><br><span class="line">  <span class="title class_">MessagesPlaceholder</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/prompts&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InMemoryChatMessageHistory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/chat_history&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RunnableWithMessageHistory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/runnables&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">runInputLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _prompt = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入 prompt\n &gt; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 `ChatPromptTemplate.fromMessages` 来初始化传给模型的完整 prompt。其中第一项为我们输入的`SystemMessage`，第二项为占位传递的历史上下文，第三项是本次我们的输入</span></span><br><span class="line">  <span class="keyword">const</span> prompt = <span class="title class_">ChatPromptTemplate</span>.<span class="title function_">fromMessages</span>([</span><br><span class="line">    [<span class="string">&#x27;system&#x27;</span>, _prompt],</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessagesPlaceholder</span>(<span class="string">&#x27;chat_history&#x27;</span>),</span><br><span class="line">    [<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;&#123;input&#125;&#x27;</span>],</span><br><span class="line">  ])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过自定义链将这个`prompt`和我们的火山`chatModel`串联起来</span></span><br><span class="line">  <span class="keyword">const</span> chain = prompt.<span class="title function_">pipe</span>(<span class="variable language_">this</span>.<span class="property">chatModel</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> messageHistories = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将自定义链传递给`RunnableWithMessageHistory`构造出 `withMessageHistory` 对象，并实现聊天历史的上下文对象</span></span><br><span class="line">  <span class="keyword">const</span> withMessageHistory = <span class="keyword">new</span> <span class="title class_">RunnableWithMessageHistory</span>(&#123;</span><br><span class="line">    <span class="attr">runnable</span>: chain,</span><br><span class="line">    <span class="attr">getMessageHistory</span>: <span class="keyword">async</span> (sessionId) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (messageHistories[sessionId] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        messageHistories[sessionId] = <span class="keyword">new</span> <span class="title class_">InMemoryChatMessageHistory</span>()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> messageHistories[sessionId]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">inputMessagesKey</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">    <span class="attr">historyMessagesKey</span>: <span class="string">&#x27;chat_history&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> config = &#123;</span><br><span class="line">        <span class="attr">configurable</span>: &#123;</span><br><span class="line">          <span class="attr">sessionId</span>: <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">async</span> (line) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (line === <span class="string">&#x27;\\clear&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 接收重置上下文是更新 config</span></span><br><span class="line">          config.<span class="property">configurable</span>.<span class="property">sessionId</span> = <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 通过 `withMessageHistory.stream` 进行模型的调用，并同时传递本次的上下文`config`对象</span></span><br><span class="line">          <span class="keyword">const</span> stream = <span class="keyword">await</span> withMessageHistory.<span class="title function_">stream</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: line,</span><br><span class="line">          &#125;, config)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">write</span>(chunk.<span class="property">content</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">prompt</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再次运行代码测试，表现符合预期</p><p><img src="https://files.mdnice.com/user/8265/e72af9b4-fe8c-43cb-a3da-850f4a135a25.png"></p><h2 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h2><p>代码<a href="(https://github.com/flytam/langchain-bytedance-volcengine/blob/main/example/chat-cli.mjs)">详见</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">&#x27;node:readline&#x27;</span></span><br><span class="line"><span class="keyword">import</span> process, &#123; stdin, stdout &#125; <span class="keyword">from</span> <span class="string">&#x27;node:process&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">EventEmitter</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;node:events&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChatVolcengine</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;langchain-bytedance-volcengine&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dotenv/config&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HumanMessage</span>, <span class="title class_">SystemMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/messages&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">ChatPromptTemplate</span>,</span><br><span class="line">  <span class="title class_">MessagesPlaceholder</span>,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/prompts&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InMemoryChatMessageHistory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/chat_history&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RunnableWithMessageHistory</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/runnables&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChatCli</span> <span class="keyword">extends</span> <span class="title class_ inherited__">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span> = stdin</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span> = stdout</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span>.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span>.<span class="title function_">setEncoding</span>(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">chatModel</span> = <span class="keyword">new</span> <span class="title class_">ChatVolcengine</span>(&#123;</span><br><span class="line">      <span class="attr">volcengineApiHost</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_HOST</span>,</span><br><span class="line">      <span class="attr">volcengineApiKey</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_API_KEY</span>,</span><br><span class="line">      <span class="attr">model</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_MODEL</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">runInputLoop</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> _prompt = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">prompt</span>(<span class="string">&#x27;请输入 prompt\n &gt; &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> prompt = <span class="title class_">ChatPromptTemplate</span>.<span class="title function_">fromMessages</span>([</span><br><span class="line">      [<span class="string">&#x27;system&#x27;</span>, _prompt],</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">MessagesPlaceholder</span>(<span class="string">&#x27;chat_history&#x27;</span>),</span><br><span class="line">      [<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;&#123;input&#125;&#x27;</span>],</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> chain = prompt.<span class="title function_">pipe</span>(<span class="variable language_">this</span>.<span class="property">chatModel</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> messageHistories = &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> withMessageHistory = <span class="keyword">new</span> <span class="title class_">RunnableWithMessageHistory</span>(&#123;</span><br><span class="line">      <span class="attr">runnable</span>: chain,</span><br><span class="line">      <span class="attr">getMessageHistory</span>: <span class="keyword">async</span> (sessionId) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (messageHistories[sessionId] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">          messageHistories[sessionId] = <span class="keyword">new</span> <span class="title class_">InMemoryChatMessageHistory</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> messageHistories[sessionId]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">inputMessagesKey</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">historyMessagesKey</span>: <span class="string">&#x27;chat_history&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(<span class="variable language_">this</span>.<span class="property">input</span>, <span class="variable language_">this</span>.<span class="property">output</span>)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">setPrompt</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">      rl.<span class="title function_">prompt</span>()</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> config = &#123;</span><br><span class="line">        <span class="attr">configurable</span>: &#123;</span><br><span class="line">          <span class="attr">sessionId</span>: <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="keyword">async</span> (line) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (line === <span class="string">&#x27;\\clear&#x27;</span>) &#123;</span><br><span class="line">          config.<span class="property">configurable</span>.<span class="property">sessionId</span> = <span class="string">`<span class="subst">$&#123;<span class="built_in">Date</span>.now()&#125;</span>`</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> stream = <span class="keyword">await</span> withMessageHistory.<span class="title function_">stream</span>(&#123;</span><br><span class="line">            <span class="attr">input</span>: line,</span><br><span class="line">          &#125;, config)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">write</span>(chunk.<span class="property">content</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">write</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rl.<span class="title function_">prompt</span>()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;close&#x27;</span>, resolve)</span><br><span class="line"></span><br><span class="line">      rl.<span class="title function_">on</span>(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        rl.<span class="title function_">close</span>()</span><br><span class="line">        process.<span class="title function_">emit</span>(<span class="string">&#x27;SIGINT&#x27;</span>, <span class="string">&#x27;SIGINT&#x27;</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">write</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">output</span>.<span class="title function_">write</span>(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">prompt</span>(<span class="params">query = <span class="string">&#x27;&gt; &#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rl = readline.<span class="title function_">createInterface</span>(<span class="variable language_">this</span>.<span class="property">input</span>, <span class="variable language_">this</span>.<span class="property">output</span>)</span><br><span class="line">      rl.<span class="title function_">question</span>(query, <span class="function">(<span class="params">answer</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(answer)</span><br><span class="line">        rl.<span class="title function_">close</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cli = <span class="keyword">new</span> <span class="title class_">ChatCli</span>()</span><br><span class="line"></span><br><span class="line">cli.<span class="title function_">runInputLoop</span>()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文我们实现了一个简易的聊天 CLI，并成功接入了火山引擎大模型，实现了流式输出和上下文管理功能。通过 langchain.js 提供的工具类和自定义链，我们不仅简化了与大模型的交互，还实现了连续聊天的能力</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;书接&lt;a class=&quot;link&quot;</summary>
      
    
    
    
    <category term="LLM" scheme="https://blog.flytam.vip/categories/LLM/"/>
    
    
    <category term="LLM" scheme="https://blog.flytam.vip/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>LLM 应用开发入门 - 实现 langchain.js ChatModel 接入火山引擎大模型和实现一个 CLI 聊天机器人（上）</title>
    <link href="https://blog.flytam.vip/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8A%EF%BC%89.html"/>
    <id>https://blog.flytam.vip/LLM%20%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%85%A5%E9%97%A8%20-%20%E5%AE%9E%E7%8E%B0%20langchain.js%20ChatModel%20%E6%8E%A5%E5%85%A5%E7%81%AB%E5%B1%B1%E5%BC%95%E6%93%8E%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%20CLI%20%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA%EF%BC%88%E4%B8%8A%EF%BC%89.html</id>
    <published>2024-08-28T13:17:47.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Langchain 是一个大语言模型（LLM）应用开发的框架，提供了 LLM 开发中各个阶段很多非常强大的辅助工具支持。对于进行 LLM 开发是必不可少的工具库。</p><p>本文将通过一个实际的开发例子来入门 LLM 开发基础工具链，并实现 langchain.js ChatModel 接入火山引擎大模型和基于 langchain 工具链实现一个简单的 CLI 聊天机器人</p><p><img src="https://files.mdnice.com/user/8265/00fc94fb-de4c-4f74-9607-57ecb52f434f.png"></p><h2 id="ChatModel-amp-LLM"><a href="#ChatModel-amp-LLM" class="headerlink" title="ChatModel &amp; LLM"></a>ChatModel &amp; LLM</h2><p>目前国内外有各种各样的大模型，而 langchain 作为一个通用 LLM 应用框架，它本身是和具体大模型无关的，是可以和任意模型进行交互的。要实现和模型的交互就要实例化使用相应的模型。</p><p>一个以 OpenAI 为例子则是安装相应的<code>@langchain/openai</code>和配置相应的 API key 进行使用即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChatOpenAI</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/openai&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HumanMessage</span>, <span class="title class_">SystemMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/messages&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> messages = [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">SystemMessage</span>(<span class="string">&#x27;Translate the following from English into Italian&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">HumanMessage</span>(<span class="string">&#x27;hi!&#x27;</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> model = <span class="keyword">new</span> <span class="title class_">ChatOpenAI</span>(&#123; <span class="attr">model</span>: <span class="string">&#x27;gpt-4&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> model.<span class="title function_">invoke</span>(messages)</span><br></pre></td></tr></table></figure><p>由于 langchain 目前没有提供火山引擎模型的集成，这里我们需要实现一个对于火山引擎大模型的集成</p><p>在 langchain 中有两个组件都可以实现模型的对接分别是 <a href="https://js.langchain.com/v0.2/docs/concepts#chat-models"><code>ChatModel</code></a> 和 <a href="https://js.langchain.com/v0.2/docs/concepts#llms"><code>LLM</code></a>。</p><p>其中 <code>LLM</code> 实现由于只能接收字符串作为输入输出，对于新模型目前已经不再推荐使用。而是使用 <code>ChatModel</code>的实现来替代，<code>ChatModel</code> 是可以使用一系列消息作为输入并返回聊天消息作为输出的语言模型。支持将不同的角色分配给对话消息，有助于区分来自 AI、用户和系统消息等。</p><p><strong>因此我们这里使用<code>ChatModel</code>来实现火山引擎的接入</strong></p><h2 id="火山引擎大模型开通"><a href="#火山引擎大模型开通" class="headerlink" title="火山引擎大模型开通"></a>火山引擎大模型开通</h2><p>目前火山引擎对于每个大模型都提供了 50 万的白嫖 token 和部分模型的免费试用</p><p><img src="https://files.mdnice.com/user/8265/239f4ff9-e6ae-40f5-91cb-3d97eb471958.png"></p><h3 id="创建接入点"><a href="#创建接入点" class="headerlink" title="创建接入点"></a>创建接入点</h3><p>完成相关基础的注册认证后，前往<a class="link"   href="https://console.volcengine.com/ark/region:ark+cn-beijing/endpoint" >火山方舟在线推理<i class="fas fa-external-link-alt"></i></a>新建接入点</p><p><img src="https://files.mdnice.com/user/8265/f1c7d473-3c96-4abf-811c-e3e13b2709ba.png"></p><p>记住我们的接入点<code>ep-xxx</code>作为下面初始化的 <code>model</code>参数</p><h3 id="创建-API-key"><a href="#创建-API-key" class="headerlink" title="创建 API key"></a>创建 API key</h3><p>前往 <a class="link"   href="https://console.volcengine.com/ark/region:ark+cn-beijing/apiKey" >API key 管理<i class="fas fa-external-link-alt"></i></a> 创建 API key</p><p><img src="https://files.mdnice.com/user/8265/b27cb32d-afb9-4c4c-a2ec-481942e5a537.png"></p><h2 id="实现自定义-ChatModel"><a href="#实现自定义-ChatModel" class="headerlink" title="实现自定义 ChatModel"></a>实现自定义 ChatModel</h2><p>要实现 langchan 中的大模型对接需要实现<code>SimpleChatModel</code>基类，主要实现以下 3 个方法</p><ul><li><code>abstract _call(messages: BaseMessage[], options: this[&quot;ParsedCallOptions&quot;], runManager?: CallbackManagerForLLMRun): Promise&lt;string&gt;;</code></li></ul><p>大模型调用，传入对话消息返回大模型返回的字符串</p><ul><li><code>abstract _llmType(): string;</code></li></ul><p>返回模型名称，便于在日志中打印调试</p><ul><li><code>_streamResponseChunks(_messages: BaseMessage[], _options: this[&quot;ParsedCallOptions&quot;], _runManager?: CallbackManagerForLLMRun): AsyncGenerator&lt;ChatGenerationChunk&gt;;</code></li></ul><p>大模型交互时流式输出支持，调用 <code>model.stream</code>等方法时会调用该实现</p><p>因此对接大模型的实现思路也是比较清晰，主要就是实现<code>_call</code>和<code>_streamResponseChunks</code>根据接收的参数来根据火山引擎的 Open API <a class="link"   href="https://www.volcengine.com/docs/82379/1298454" >文档<i class="fas fa-external-link-alt"></i></a>进行调用</p><h3 id="主要实现"><a href="#主要实现" class="headerlink" title="主要实现"></a>主要实现</h3><ul><li>参数和类型定义</li></ul><p>我们对外导出<code>ChatVolcengine</code>类作为模型对接使用。按照火山引擎的文档将相关的模型参数作为构造类的入参</p><p><img src="https://files.mdnice.com/user/8265/bacdcdc0-0827-438a-a49e-6ca58acff359.png"></p><p><img src="https://files.mdnice.com/user/8265/26213b86-f230-48e4-b375-1a074f491583.png"></p><p>为了提供良好的用户使用体验，并将火山引擎的<a class="link"   href="https://www.volcengine.com/docs/82379/1298454#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2" >数据结构<i class="fas fa-external-link-alt"></i></a>用相应的 ts 声明表示，<a class="link"   href="https://github.com/flytam/langchain-bytedance-volcengine/blob/main/src/types.ts" >详见<i class="fas fa-external-link-alt"></i></a></p><ul><li>Open API 请求封装</li></ul><p>一般大模型的接口返回都支持流式和非流式，这里我们实现<code>request</code>方法将和大模型 OpenApi 的非流式和流式调用作为统一的封装。将 langchain 的数据结构转化为火山引擎接收的数据结构并调用 Open API</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">_request</span>(<span class="attr">messages</span>: <span class="title class_">BaseMessage</span>[], <span class="attr">options</span>: <span class="variable language_">this</span>[<span class="string">&#x27;ParsedCallOptions&#x27;</span>], stream?: <span class="built_in">boolean</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">Response</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> parameters = <span class="variable language_">this</span>.<span class="title function_">invocationParams</span>()</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">messagesMapped</span>: <span class="title class_">MessageParam</span>[] = messages.<span class="title function_">map</span>(<span class="function"><span class="params">message</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="title function_">messageToRole</span>(message),</span><br><span class="line">    <span class="attr">content</span>: message.<span class="property">content</span> <span class="keyword">as</span> <span class="built_in">string</span>,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">request</span>: <span class="title class_">ChatCompletionRequest</span> = &#123;</span><br><span class="line">    ...parameters,</span><br><span class="line">    ...options,</span><br><span class="line">    <span class="attr">messages</span>: messagesMapped,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stream) &#123;</span><br><span class="line">    request.<span class="property">stream</span> = stream</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">caller</span>.<span class="title function_">call</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.volcengineApiHost&#125;</span>/api/v3/chat/completions`</span>, &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">`Bearer <span class="subst">$&#123;<span class="variable language_">this</span>.volcengineApiKey&#125;</span>`</span>,</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(request),</span><br><span class="line">      <span class="attr">signal</span>: options.<span class="property">signal</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">error</span>: <span class="title class_">SimpleChatCompletionResponse</span> | <span class="title class_">StreamChatCompletionResponse</span> = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(error.<span class="property">error</span>?.<span class="property">message</span> ?? <span class="string">&#x27;Unknown error&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_call</code> 方法实现</li></ul><p><code>_call</code> 方法是在模型调用<code>invoke</code>等方法时被调用，返回的是模型返回的字符串回答。我们在该方法下也支持流式调用，如果是流式调用则把流式调用的结果拼接成完整的字符串后再返回</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="title function_">_call</span>(<span class="attr">messages</span>: <span class="title class_">BaseMessage</span>[], <span class="attr">options</span>: <span class="variable language_">this</span>[<span class="string">&#x27;ParsedCallOptions&#x27;</span>], runManager?: <span class="title class_">CallbackManagerForLLMRun</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">enableStream</span>) &#123;</span><br><span class="line">    <span class="comment">// 在该方法下也支持流式调用，如果是流式调用则把流式调用的结果拼接成完整的字符串后再返回</span></span><br><span class="line">    <span class="keyword">let</span> content = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// _streamResponseChunks 是下面提到的流式调用</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="title function_">_streamResponseChunks</span>(</span><br><span class="line">      messages,</span><br><span class="line">      options,</span><br><span class="line">      runManager,</span><br><span class="line">    )) &#123;</span><br><span class="line">      content += chunk.<span class="property">text</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> content</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">_request</span>(messages, options)</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">SimpleChatCompletionResponse</span> = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line">    <span class="keyword">return</span> data.<span class="property">choices</span>?.[<span class="number">0</span>]?.<span class="property">message</span>?.<span class="property">content</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>_streamResponseChunks</code> 方法实现</li></ul><p>该方法用于大模型交互时流式输出支持，例如调用 <code>model.stream</code>等。</p><p>langchain 提供了工具函数<code>convertEventStreamToIterableReadableDataStream</code>。这里我们只需要将调用<code>_request</code>方法返回的响应传递给工具方法即可得到一个<code>IterableReadableDataStream</code>，对该流进行解析即可实现流式返回解析。</p><p>每次接收到的数据进行 JSON 序列化后调用<code>ChatGenerationChunk</code>和<code>AIMessageChunk</code>构造出生成器函数的返回对象就完成了整个流式数据的读取。需要注意的是火山引擎流式接口使用 SSE 协议并以<code>[DONE]</code>作为结束标记，在<code>chunk</code> 为 <code>[DONE]</code> 时需要退出流的解析</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; convertEventStreamToIterableReadableDataStream &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/utils/event_source_parse&#x27;</span></span><br><span class="line">  <span class="keyword">async</span> *<span class="title function_">_streamResponseChunks</span>(</span><br><span class="line">    <span class="attr">_messages</span>: <span class="title class_">BaseMessage</span>[],</span><br><span class="line">    <span class="attr">_options</span>: <span class="variable language_">this</span>[<span class="string">&#x27;ParsedCallOptions&#x27;</span>],</span><br><span class="line">    _runManager?: <span class="title class_">CallbackManagerForLLMRun</span>,</span><br><span class="line">  ): <span class="title class_">AsyncGenerator</span>&lt;<span class="title class_">ChatGenerationChunk</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="title function_">_request</span>(_messages, _options, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!response.<span class="property">body</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;No body in response&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要将调用`_request`方法返回的响应传递给工具方法即可得到一个`IterableReadableDataStream`</span></span><br><span class="line">    <span class="keyword">const</span> stream = <span class="title function_">convertEventStreamToIterableReadableDataStream</span>(response.<span class="property">body</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对该流进行解析即可实现流式返回解析</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> stream) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 需要注意的是火山引擎流式接口使用 SSE 协议并以`[DONE]`作为结束标记，在`chunk` 为 `[DONE]` 时需要退出流的解析</span></span><br><span class="line">        <span class="keyword">if</span> (chunk === <span class="string">&#x27;[DONE]&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="attr">data</span>: <span class="title class_">StreamChatCompletionResponse</span> = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(chunk)</span><br><span class="line">        <span class="keyword">const</span> text = data.<span class="property">choices</span>?.[<span class="number">0</span>]?.<span class="property">delta</span>.<span class="property">content</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次接收到的数据进行 JSON 序列化后调用`ChatGenerationChunk`和`AIMessageChunk`构造出生成器函数的返回对象就完成了整个流式数据的读取</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="keyword">new</span> <span class="title class_">ChatGenerationChunk</span>(&#123;</span><br><span class="line">          text,</span><br><span class="line">          <span class="attr">message</span>: <span class="keyword">new</span> <span class="title class_">AIMessageChunk</span>(&#123;</span><br><span class="line">            <span class="attr">content</span>: text,</span><br><span class="line">            <span class="attr">additional_kwargs</span>: &#123;</span><br><span class="line">              <span class="attr">logprobs</span>: data.<span class="property">choices</span>?.[<span class="number">0</span>].<span class="property">logprobs</span>,</span><br><span class="line">              <span class="attr">finish_reason</span>: data.<span class="property">choices</span>?.[<span class="number">0</span>].<span class="property">finish_reason</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">usage_metadata</span>: &#123;</span><br><span class="line">              <span class="attr">input_tokens</span>: data.<span class="property">usage</span>?.<span class="property">prompt_tokens</span> ?? <span class="number">0</span>,</span><br><span class="line">              <span class="attr">output_tokens</span>: data.<span class="property">usage</span>?.<span class="property">completion_tokens</span> ?? <span class="number">0</span>,</span><br><span class="line">              <span class="attr">total_tokens</span>: data.<span class="property">usage</span>?.<span class="property">total_tokens</span> ?? <span class="number">0</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;),</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">await</span> _runManager?.<span class="title function_">handleLLMNewToken</span>(text)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Received a non-JSON parseable chunk: <span class="subst">$&#123;chunk&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>PS:</strong> 对于更加进一步实现模型调用 tracing 等能力，可以实现基类<code>BaseChatModel</code>。</p><p>由于这里我们只作为聊天工具使用为了简单起见直接实现的<code>SimpleChatModel</code>，<code>SimpleChatModel</code>本身也是继承自<code>BaseChatModel</code>，只是自带实现了简单版本的<code>abstract _generate(messages: BaseMessage[], options: this[&quot;ParsedCallOptions&quot;], runManager?: CallbackManagerForLLMRun): Promise&lt;ChatResult&gt;;</code> 方法</p><p>至此，我们即实现了 langchain 对火山引擎大模型的对接，代码验证</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HumanMessage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@langchain/core/messages&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ChatVolcengine</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;../dist/index.mjs&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;dotenv/config&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chatModel = <span class="keyword">new</span> <span class="title class_">ChatVolcengine</span>(&#123;</span><br><span class="line">  <span class="attr">volcengineApiHost</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_HOST</span>,</span><br><span class="line">  <span class="attr">volcengineApiKey</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_API_KEY</span>,</span><br><span class="line">  <span class="attr">model</span>: process.<span class="property">env</span>.<span class="property">VOLCENGINE_MODEL</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> chatModel.<span class="title function_">invoke</span>([<span class="keyword">new</span> <span class="title class_">HumanMessage</span>(&#123; <span class="attr">content</span>: <span class="string">&#x27;Hi! I\&#x27;m Bob&#x27;</span> &#125;)])</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ans&#x27;</span>, res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可见我们这里已经调用火山引擎大模型成功了</p><p><img src="https://files.mdnice.com/user/8265/cf0e70c6-d9df-4828-822f-1609faeec689.png"></p><p>该 langchain 火山引擎大模型集成代码同时发布了 npm 包 <a href="https://github.com/flytam/langchain-bytedance-volcengine"><code>langchain-bytedance-volcengine</code></a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a class="link"   href="https://js.langchain.com/v0.2/docs/concepts" >Conceptual guide<i class="fas fa-external-link-alt"></i></a></li><li><a class="link"   href="https://js.langchain.com/v0.2/docs/how_to/custom_chat" >Create a custom chat model class<i class="fas fa-external-link-alt"></i></a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="LLM" scheme="https://blog.flytam.vip/categories/LLM/"/>
    
    
    <category term="LLM" scheme="https://blog.flytam.vip/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript Project References npm 包小实践</title>
    <link href="https://blog.flytam.vip/TypeScript%20Project%20References%20npm%20%E5%8C%85%E5%B0%8F%E5%AE%9E%E8%B7%B5.html"/>
    <id>https://blog.flytam.vip/TypeScript%20Project%20References%20npm%20%E5%8C%85%E5%B0%8F%E5%AE%9E%E8%B7%B5.html</id>
    <published>2024-07-01T12:31:58.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h1 id="npm-包输出-es-cjs-产物"><a href="#npm-包输出-es-cjs-产物" class="headerlink" title="npm 包输出 es/cjs 产物"></a>npm 包输出 es/cjs 产物</h1><p>在开发一个 npm 包时，通常需要同时输出 ES 模块和 CommonJS 模块的产物供不同的构建进行使用。在只使用<code>tsc</code>进行产物编译的情况下，我们通常可以通过配置两个独立的 <code>tsconfig.json</code> 配置文件，并在一个 npm script 中 执行两次 tsc 命令来实现</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>假设我们的项目结构如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">my-package/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">src/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">index.ts</span></span><br><span class="line"><span class="string">├──</span> <span class="string">dist/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">es/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">cjs/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">tsconfig.es.json</span></span><br><span class="line"><span class="string">└──</span> <span class="string">tsconfig.cjs.json</span></span><br></pre></td></tr></table></figure><h2 id="配置-TypeScript"><a href="#配置-TypeScript" class="headerlink" title="配置 TypeScript"></a>配置 TypeScript</h2><h3 id="tsconfig-es-json"><a href="#tsconfig-es-json" class="headerlink" title="tsconfig.es.json"></a><code>tsconfig.es.json</code></h3><p>为 ES 模块创建一个 <code>tsconfig.es.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Node&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/es&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="tsconfig-cjs-json"><a href="#tsconfig-cjs-json" class="headerlink" title="tsconfig.cjs.json"></a><code>tsconfig.cjs.json</code></h3><p>为 CommonJS 模块创建一个 <code>tsconfig.cjs.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CommonJS&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Node&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist/cjs&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="配置构建脚本"><a href="#配置构建脚本" class="headerlink" title="配置构建脚本"></a>配置构建脚本</h2><p>在 package.json 中，我们可以添加以下脚本来构建我们的项目，执行两次 tsc 并分别指定不同的配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc -p tsconfig.es.json &amp;&amp; tsc -p tsconfig.cjs.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>通过运行 npm run build，可以生成同时包含 ES 模块和 CommonJS 模块的产物</p><h1 id="TypeScript-的-references-是什么"><a href="#TypeScript-的-references-是什么" class="headerlink" title="TypeScript 的 references 是什么"></a>TypeScript 的 references 是什么</h1><p>TypeScript 的项目引用（<a class="link"   href="https://www.typescriptlang.org/docs/handbook/project-references.html" >Project References<i class="fas fa-external-link-alt"></i></a>）是 TypeScript 3.0 引入的一项功能，允许一个 TypeScript 项目引用另一个 TypeScript 项目。这使得我们可以将大型代码库拆分为多个较小的项目，并且这些项目可以相互依赖</p><h2 id="Project-References-的好处"><a href="#Project-References-的好处" class="headerlink" title="Project References 的好处"></a>Project References 的好处</h2><ul><li>增量编译：当项目引用被正确配置时，TypeScript 只会重新编译发生变化的部分，从而大幅提升编译速度。</li><li>模块化：通过项目引用，可以将代码库拆分为多个独立的、可复用的模块，提升代码的可维护性和可读性。</li><li>类型安全：项目引用确保了项目之间的类型安全，避免了类型不一致的问题。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>要使用项目引用，需要在 tsconfig.json 中添加 <code>references</code> 字段。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;composite&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;../other-project&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>相应的子项目需要存在相应的<code>tsconfig.json</code>配置，并且配置<code>compilerOptions.composite=true</code>，这样才能被主项目引用。如</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;composite&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;types&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Node&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dist&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="使用-TypeScript-的-references-后如何实现一个命令-tsc-输出-ES-和-CommonJS-产物并且提升增量编译的性能"><a href="#使用-TypeScript-的-references-后如何实现一个命令-tsc-输出-ES-和-CommonJS-产物并且提升增量编译的性能" class="headerlink" title="使用 TypeScript 的 references 后如何实现一个命令 tsc 输出 ES 和 CommonJS 产物并且提升增量编译的性能"></a>使用 TypeScript 的 references 后如何实现一个命令 tsc 输出 ES 和 CommonJS 产物并且提升增量编译的性能</h1><p>仍以上面的项目结构为例子，我们使用 TypeScript 的项目引用来实现这个需求。</p><h2 id="项目结构-1"><a href="#项目结构-1" class="headerlink" title="项目结构"></a>项目结构</h2><p>假设我们的项目结构如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">my-package/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">src/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">index.ts</span></span><br><span class="line"><span class="string">├──</span> <span class="string">dist/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">├──</span> <span class="string">es/</span></span><br><span class="line"><span class="string">│</span>   <span class="string">└──</span> <span class="string">cjs/</span></span><br><span class="line"><span class="string">├──</span> <span class="string">package.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">tsconfig.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">tsconfig.base.json</span></span><br><span class="line"><span class="string">├──</span> <span class="string">tsconfig.es.json</span></span><br><span class="line"><span class="string">└──</span> <span class="string">tsconfig.cjs.json</span></span><br></pre></td></tr></table></figure><p>首先，我们需要在根目录下创建一个 tsconfig.json 文件，用于配置项目引用：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;files&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;references&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.es.json&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span> <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.cjs.json&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配置-tsconfig-es-json"><a href="#配置-tsconfig-es-json" class="headerlink" title="配置 tsconfig.es.json"></a>配置 <code>tsconfig.es.json</code></h3><p>为 ES 模块创建一个 tsconfig.es.json 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.base.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/es&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ESNext&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="配置-tsconfig-cjs-json"><a href="#配置-tsconfig-cjs-json" class="headerlink" title="配置 tsconfig.cjs.json"></a>配置 <code>tsconfig.cjs.json</code></h3><p>为 CommonJS 模块创建一个 tsconfig.cjs.json 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;extends&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./tsconfig.base.json&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;outDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./dist/cjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;CommonJS&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="公共配置-tsconfig-base-json"><a href="#公共配置-tsconfig-base-json" class="headerlink" title="公共配置 tsconfig.base.json"></a>公共配置 <code>tsconfig.base.json</code></h3><p>为了避免重复配置，我们可以创建一个 tsconfig.base.json 文件，包含通用的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ES5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;declaration&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;composite&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;rootDir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;src&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h2><p>在 package.json 中，我们可以添加以下脚本来构建我们的项目</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tsc -b&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>此时我们不再需要执行两次 tsc 命令，而是只需要执行一次 tsc -b 命令即可输出符合我们需求的 es + cjs 产物（和上面的两次执行 <code>tsc</code> 是一样的效果）。</p><p>在这个场景下 TypeScript 会根据项目引用的配置，自动构建 ES 模块和 CommonJS 模块，并且只会重新编译发生变化的部分，从而提升增量编译的性能</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;npm-包输出-es-c</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>React 19 升级指南</title>
    <link href="https://blog.flytam.vip/React%2019%20%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97.html"/>
    <id>https://blog.flytam.vip/React%2019%20%E5%8D%87%E7%BA%A7%E6%8C%87%E5%8D%97.html</id>
    <published>2024-05-04T02:23:01.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>React 已于近日发布了 <code>v19</code> 的 beta 版本，同时为了帮助后续的 <code>v19</code> 升级，也同时发布了 <code>v18.3.0</code>的正式版， 与 <code>v18.2</code> 版本完全相同，但添加了弃用 API 的警告和其他为 React 19 所需的更改</p><p><img src="https://files.mdnice.com/user/8265/bca7f247-a515-499b-8337-0e7e29cc659a.png"></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用新版-JSX-Transform"><a href="#使用新版-JSX-Transform" class="headerlink" title="使用新版 JSX Transform"></a>使用新版 JSX Transform</h3><p>为了改善打包体积和可以在 JSX 文件中无需手动引入 <code>React</code>，在 2020 年 React 引入了<a class="link"   href="https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html" >新的 JSX Transform<i class="fas fa-external-link-alt"></i></a>。如果在 React 19 中没有使用这个新的 JSX Transform 会有一个报错提示</p><blockquote><p><img src="https://files.mdnice.com/user/8265/f3621a5b-5dfd-441f-b54b-f516d5413ff3.png"></p></blockquote><p>如果已经使用了新版 JSX Transform 则可以忽略此步骤</p><h3 id="安装最新版本的-React-和-ReactDom"><a href="#安装最新版本的-React-和-ReactDom" class="headerlink" title="安装最新版本的 React 和 ReactDom"></a>安装最新版本的 React 和 ReactDom</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react@beta react-dom@beta</span><br></pre></td></tr></table></figure><p>如果使用 TypeScript，则还需要更新相关类型包。等到 React 19 发布 release 版本后可以就像往常一样从<code>@types/react</code>和<code>@types/react-dom</code>安装类型包。在当前 beta 版本中需要在<code>package.json</code>为类型包配置<code>overrides</code> 锁定版本以确保不同包中的类型是可用的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm:types-react@beta&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm:types-react-dom@beta&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;overrides&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@types/react&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm:types-react@beta&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;@types/react-dom&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm:types-react-dom@beta&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Breaking-changes"><a href="#Breaking-changes" class="headerlink" title="Breaking changes"></a>Breaking changes</h2><h3 id="render-过程中的错误不再二次抛出"><a href="#render-过程中的错误不再二次抛出" class="headerlink" title="render 过程中的错误不再二次抛出"></a>render 过程中的错误不再二次抛出</h3><p>在之前的 React 版本中，渲染过程中抛出的错误会被捕获并重新抛出。在 DEV 模式下，我们还会记录到 console.error，导致出现重复的错误日志。</p><p>在 React 19 中，<a class="link"   href="https://react.dev/blog/2024/04/25/react-19#error-handling" >改进了错误处理方式<i class="fas fa-external-link-alt"></i></a>，通过不重新抛出来减少重复信息：</p><ul><li>未捕获的错误：未被错误边界捕获的错误将调用给 <code>window.reportError</code></li><li>已捕获的错误：被错误边界捕获的错误将报告将调用给 <code>console.error</code><br>这个改变不应该影响大多数应用，但如果生产错误报告依赖于错误被重新抛出，则可能需要更新错误处理。为了支持这一点，React 19 添加了新的<a href="https://react.dev/reference/react-dom/client/createRoot"><code>createRoot</code></a>和<a href="https://react.dev/reference/react-dom/client/hydrateRoot"><code>hydrateRoot</code></a>用于自定义错误处理：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(container, &#123;</span><br><span class="line">  <span class="attr">onUncaughtError</span>: <span class="function">(<span class="params">error, errorInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ... log error report</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">onCaughtError</span>: <span class="function">(<span class="params">error, errorInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ... log error report</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="废弃-React-API-移除"><a href="#废弃-React-API-移除" class="headerlink" title="废弃 React API 移除"></a>废弃 React API 移除</h3><h4 id="移除propTypes和函数组件的defaultProps"><a href="#移除propTypes和函数组件的defaultProps" class="headerlink" title="移除propTypes和函数组件的defaultProps"></a>移除<code>propTypes</code>和函数组件的<code>defaultProps</code></h4><p><code>propTypes</code>是用于运行时校验组件 props 的属性，在 <a href="https://legacy.reactjs.org/blog/2017/04/07/react-v15.5.0.html#new-deprecation-warnings"><code>Reactv15.5.0</code></a>已经被标记为废弃，在 <code>v19</code>这个正式删除</p><p>另外函数组件的<code>defaultProps</code>也已经移除（使用 ES6 默认参数替代），由于 class 组件没有相应的 ES6 语法替代因此仍会保留</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Heading</span>(<span class="params">&#123;text&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Heading</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Heading</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Hello, world!&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line">interface <span class="title class_">Props</span> &#123;</span><br><span class="line">  text?: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Heading</span>(<span class="params">&#123;text = <span class="string">&#x27;Hello, world!&#x27;</span>&#125;: Props</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;text&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除使用contextTypes和getChildContext的-Legacy-Context"><a href="#移除使用contextTypes和getChildContext的-Legacy-Context" class="headerlink" title="移除使用contextTypes和getChildContext的 Legacy Context"></a>移除使用<code>contextTypes</code>和<code>getChildContext</code>的 Legacy Context</h4><p>Legacy Context 在<a class="link"   href="https://legacy.reactjs.org/blog/2018/10/23/react-v-16-6.html" >2018.10（v16.6.0）<i class="fas fa-external-link-alt"></i></a>已被弃用</p><p>Legacy Context 仅适用于使用<code>contextTypes</code>和<code>getChildContext</code> API 的类组件，并由于易于忽略的微妙错误而被<code>contextType</code>替换。在 React 19 中，将删除 Legacy Context 以使 React 更小更快。仍在类组件中使用 Legacy Context，则需要迁移到新的<code>contextType</code> API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> childContextTypes = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">getChildContext</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context.foo&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FooContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">FooContext</span> <span class="attr">value</span>=<span class="string">&#x27;bar&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">FooContext</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">static</span> contextType = <span class="title class_">FooContext</span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.context&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除字符串-refs"><a href="#移除字符串-refs" class="headerlink" title="移除字符串 refs"></a>移除字符串 refs</h4><p>字符串 refs 在<a class="link"   href="https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html" >2018.3（v16.3.0）<i class="fas fa-external-link-alt"></i></a>被弃用</p><p>在被替换为 ref 回调方式之前类组件支持字符串 refs，但存在多个<a class="link"   href="https://github.com/facebook/react/issues/1373" >缺点<i class="fas fa-external-link-alt"></i></a>。在 React 19 中，将删除字符串引用以使 React 更简单易懂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">refs</span>.<span class="property">input</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#x27;input&#x27;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果仍在使用类组件中的字符串引用，则需要迁移到 refs 回调的形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> this.input = input&#125; /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除模块模式工厂"><a href="#移除模块模式工厂" class="headerlink" title="移除模块模式工厂"></a>移除模块模式工厂</h4><p>模块模式工厂在<a class="link"   href="https://legacy.reactjs.org/blog/2019/08/08/react-v16.9.0.html#deprecating-module-pattern-factories" >2019.8（v16.9.0）<i class="fas fa-external-link-alt"></i></a>被弃用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FactoryComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="title function_">render</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种用法其实很少使用，支持它会使 React 比必要的更大和更慢。在 React 19 中，将删除对模块模式工厂的支持，需要迁移到常规函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FactoryComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除React-createFactory"><a href="#移除React-createFactory" class="headerlink" title="移除React.createFactory"></a>移除<code>React.createFactory</code></h4><p>createFactory 在<a class="link"   href="https://legacy.reactjs.org/blog/2020/02/26/react-v16.13.0.html#deprecating-createfactory" >2020.2（v16.13.0）<i class="fas fa-external-link-alt"></i></a>已被弃用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> &#123; createFactory &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="title function_">createFactory</span>(<span class="string">&#x27;button&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 JSX 得到广泛支持之前使用 createFactory 很常见，但是现在已经可以用 JSX 替换。在 React 19 中，将删除 createFactory，需要迁移到 JSX</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">const</span> button = <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> /&gt;</span></span>;</span><br></pre></td></tr></table></figure><h4 id="移除react-test-renderer-shallow"><a href="#移除react-test-renderer-shallow" class="headerlink" title="移除react-test-renderer/shallow"></a>移除<code>react-test-renderer/shallow</code></h4><p>在 React 18 中，更新了<code>react-test-renderer/shallow</code>并重新导出<code>react-shallow-renderer</code>。在 React 19 中，将删除<code>react-test-render/shallow</code>，而直接安装该软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react-shallow-renderer --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">import</span> <span class="title class_">ShallowRenderer</span> <span class="keyword">from</span> <span class="string">&#x27;react-test-renderer/shallow&#x27;</span>;</span><br><span class="line">+ <span class="keyword">import</span> <span class="title class_">ShallowRenderer</span> <span class="keyword">from</span> <span class="string">&#x27;react-shallow-renderer&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="废弃-ReactDOM-API-移除"><a href="#废弃-ReactDOM-API-移除" class="headerlink" title="废弃 ReactDOM API 移除"></a>废弃 ReactDOM API 移除</h3><h4 id="移除react-dom-test-utils"><a href="#移除react-dom-test-utils" class="headerlink" title="移除react-dom/test-utils"></a>移除<code>react-dom/test-utils</code></h4><h4 id="移除ReactDOM-render"><a href="#移除ReactDOM-render" class="headerlink" title="移除ReactDOM.render"></a>移除<code>ReactDOM.render</code></h4><p><code>ReactDOM.render</code>在<a class="link"   href="https://react.dev/blog/2022/03/08/react-18-upgrade-guide" >2022 年 3 月（v18.0.0）<i class="fas fa-external-link-alt"></i></a>已被弃用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br></pre></td></tr></table></figure><p>在 React 19 中，将删除 ReactDOM.render，需要迁移到使用<a href="https://react.dev/reference/react-dom/client/createRoot"><code>ReactDOM.createRoot</code></a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">import</span> &#123;createRoot&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> root = <span class="title function_">createRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line">root.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><h4 id="移除ReactDOM-hydrate"><a href="#移除ReactDOM-hydrate" class="headerlink" title="移除ReactDOM.hydrate"></a>移除<code>ReactDOM.hydrate</code></h4><p><code>ReactDOM.hydrate</code>在<a class="link"   href="https://react.dev/blog/2022/03/08/react-18-upgrade-guide" >2022 年 3 月（v18.0.0）<i class="fas fa-external-link-alt"></i></a>已被弃用。在 React 19 中，将删除 ReactDOM.hydrate，需要迁移到使用<a href="https://react.dev/reference/react-dom/client/hydrateRoot"><code>ReactDOM.hydrateRoot</code></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> &#123;hydrate&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="title function_">hydrate</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">import</span> &#123;hydrateRoot&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/client&#x27;</span>;</span><br><span class="line"><span class="title function_">hydrateRoot</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>), <span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure><h4 id="移除unmountComponentAtNode"><a href="#移除unmountComponentAtNode" class="headerlink" title="移除unmountComponentAtNode"></a>移除<code>unmountComponentAtNode</code></h4><p><code>ReactDOM.unmountComponentAtNode</code>在<a class="link"   href="https://react.dev/blog/2022/03/08/react-18-upgrade-guide" >2022.3（v18.0.0）<i class="fas fa-external-link-alt"></i></a>已被弃用。在 React 19 中需要迁移到使用<code>hydrateRoot</code>和<code>createRoot</code>对应的<code>root.unmount()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="title function_">unmountComponentAtNode</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// After</span></span><br><span class="line">root.<span class="title function_">unmount</span>();</span><br></pre></td></tr></table></figure><h4 id="移除ReactDOM-findDOMNode"><a href="#移除ReactDOM-findDOMNode" class="headerlink" title="移除ReactDOM.findDOMNode"></a>移除<code>ReactDOM.findDOMNode</code></h4><p>ReactDOM.findDOMNode 在<a class="link"   href="https://legacy.reactjs.org/blog/2018/10/23/react-v-16-6.html#deprecations-in-strictmode" >2018 年 10 月（v16.6.0）<i class="fas fa-external-link-alt"></i></a>已被弃用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Before</span></span><br><span class="line"><span class="keyword">import</span> &#123;findDOMNode&#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AutoselectingInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> input = <span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>);</span><br><span class="line">    input.<span class="title function_">select</span>()</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&quot;Hello&quot;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <a class="link"   href="https://react.dev/learn/manipulating-the-dom-with-refs" >DOM 引用<i class="fas fa-external-link-alt"></i></a>替换 <code>ReactDOM.findDOMNode</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">AutoselectingInput</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span>.<span class="title function_">select</span>();</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">defaultValue</span>=<span class="string">&quot;Hello&quot;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增废弃"><a href="#新增废弃" class="headerlink" title="新增废弃"></a>新增废弃</h3><h4 id="废弃element-ref属性"><a href="#废弃element-ref属性" class="headerlink" title="废弃element.ref属性"></a>废弃<code>element.ref</code>属性</h4><p>从 React 19 开始，现在可以将<code>ref</code>作为函数组件的 prop 访问</p><p>如果直接访问 <code>element.ref</code>会出现警告</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyInput</span>(<span class="params">&#123;placeholder, ref&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&#123;placeholder&#125;</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&lt;<span class="title class_">MyInput</span> ref=&#123;ref&#125; /&gt;</span><br></pre></td></tr></table></figure><img width="736" alt="image" src="https://github.com/flytam/blog/assets/20512530/0ce55ff6-c37e-480d-925c-1ac104356779"><p>新的函数组件将不再需要<code>forwardRef</code>，在未来的版本中，React 将弃用并删除<code>forwardRef</code></p><p>但是传递给类的 <code>refs</code> 不会作为 props 传递，因为<code>refs</code>引用的是组件实例</p><h4 id="废弃react-test-renderer"><a href="#废弃react-test-renderer" class="headerlink" title="废弃react-test-renderer"></a>废弃<code>react-test-renderer</code></h4><p>弃用<code>react-test-renderer</code>。<code>react-test-renderer</code>实现了自己的渲染器环境与用户使用的环境不匹配并依赖于 React 内部的实现细节</p><p>在 React 19 中，<code>react-test-renderer</code>会打印了一个弃用警告，并切换到并发渲染。建议将测试迁移到<code>@testing-library/react</code>或<code>@testing-library/react-native</code>以获得更良好支持的测试体验</p><h3 id="一些值得一提的变动"><a href="#一些值得一提的变动" class="headerlink" title="一些值得一提的变动"></a>一些值得一提的变动</h3><h4 id="StrictMode-变化"><a href="#StrictMode-变化" class="headerlink" title="StrictMode 变化"></a><code>StrictMode</code> 变化</h4><p>React 19 包括了对 Strict Mode 的几个修复和改进。在开发中，当在 Strict Mode 下进行双重渲染时，<code>useMemo</code>和<code>useCallback</code>将重用第一次渲染时的结果进行第二次渲染。已经兼容<code>Strict Mode</code>的组件也不会发生差异。与所有<code>Strict Mode</code>行为一样，这些功能为的是在开发过程中主动暴露组件中的错误，以便在它们被发布到生产环境之前修复。例如在开发过程中，<code>Strict Mode</code>将在初始挂载时双重调用<code>ref</code>回调函数，以模拟当挂载的组件被 Suspense 回退替换时的情况</p><h4 id="移除-UMD-产物"><a href="#移除-UMD-产物" class="headerlink" title="移除 UMD 产物"></a>移除 UMD 产物</h4><p>UMD 曾经被广泛使用作为一种无需构建步骤即可加载 React 的便捷方式。现在有现代化的替代方案可以将模块作为脚本加载到 HTML 文档中。从 React 19 开始，React 将不再生成 UMD 构建，以减少其测试和发布过程的复杂性。</p><p>为了使用脚本标签加载 React 19，可以使用基于 ESM 的 CDN，例如<code>esm.sh</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;https://esm.sh/react@19/?dev&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> <span class="title class_">ReactDOMClient</span> <span class="keyword">from</span> <span class="string">&quot;https://esm.sh/react-dom@19/client?dev&quot;</span></span></span><br><span class="line"><span class="language-javascript">  ...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="依赖于-React-内部的库可能会影响升级"><a href="#依赖于-React-内部的库可能会影响升级" class="headerlink" title="依赖于 React 内部的库可能会影响升级"></a>依赖于 React 内部的库可能会影响升级</h4><p>此版本包含对 React 内部的更改，可能会影响那些忽略 React 官方警告不要使用像<code>SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED</code>这样的内部机制的库。这些更改是为了实现 React 19 中的一些优化，但不会破坏遵循官方指南使用的库。</p><p>根据<a class="link"   href="https://react.dev/community/versioning-policy#what-counts-as-a-breaking-change" >版本策略<i class="fas fa-external-link-alt"></i></a>，这些更新不被列为重大更改，并且不包括有关如何升级它们的文档。建议删除依赖于内部机制的任何代码。</p><p>为了反映使用内部机制的影响，已将<code>SECRET_INTERNALS</code>后缀重命名为：</p><p><code>_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE</code></p><p>将来将使用更多方式阻止从 React 访问内部，以防止使用并确保用户不会被阻止升级</p><h3 id="TypeScript-变化"><a href="#TypeScript-变化" class="headerlink" title="TypeScript 变化"></a>TypeScript 变化</h3><h4 id="移除废弃的-TypeScript-类型"><a href="#移除废弃的-TypeScript-类型" class="headerlink" title="移除废弃的 TypeScript 类型"></a>移除废弃的 TypeScript 类型</h4><p>根据 React 19 中删除的相关 API 清理了相关 TypeScript 类型。同时提供了一个<a href="https://github.com/eps1lon/types-react-codemod/"><code>types-react-codemod</code></a>工具可以帮助迁移已有的类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx types-react-codemod@latest preset-19 ./path-to-app</span><br></pre></td></tr></table></figure><h4 id="ref-返回内容必须是清理函数"><a href="#ref-返回内容必须是清理函数" class="headerlink" title="ref 返回内容必须是清理函数"></a><code>ref</code> 返回内容必须是清理函数</h4><p>由于引入了<code>ref</code>清理函数，从<code>ref</code>回调返回任何其他内容现在将被 TypeScript 报错。修复方法通常是停止使用隐式返回：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;current</span> =&gt;</span> (instance = current)&#125; /&gt;</span></span><br><span class="line">+ <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;current</span> =&gt;</span> &#123;instance = current&#125;&#125; /&gt;</span></span><br></pre></td></tr></table></figure><p>原始代码返回<code>HTMLDivElement</code>的实例，TypeScript 无法确定是否清理函数。</p><h4 id="useRef需要传递参数"><a href="#useRef需要传递参数" class="headerlink" title="useRef需要传递参数"></a><code>useRef</code>需要传递参数</h4><p>通过更改类型使得 <code>useRef</code> 现在需要接收一个参数。这显著简化了它的类型签名。现在它的行为更像 <code>createContext</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @ts-expect-error: Expected 1 argument but saw none</span></span><br><span class="line"><span class="title function_">useRef</span>();</span><br><span class="line"><span class="comment">// Passes</span></span><br><span class="line"><span class="title function_">useRef</span>(<span class="literal">undefined</span>);</span><br><span class="line"><span class="comment">// @ts-expect-error: Expected 1 argument but saw none</span></span><br><span class="line"><span class="title function_">createContext</span>();</span><br><span class="line"><span class="comment">// Passes</span></span><br><span class="line"><span class="title function_">createContext</span>(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure><p>现在也意味着所有的引用都是可变的。不再会遇到以下的问题，传递 <code>number</code>类型但是使用 <code>null</code> 初始化</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="keyword">const</span> ref = useRef&lt;<span class="built_in">number</span>&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cannot assign to &#x27;current&#x27; because it is a read-only property</span></span><br><span class="line">ref.<span class="property">current</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><code>MutableRef</code>现已弃用，建议使用单个<code>RefObject</code>类型，该类型将始终由<code>useRef</code>返回：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">RefObject</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">current</span>: T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">function</span> useRef&lt;T&gt;: <span class="title class_">RefObject</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>useRef 仍然有一个方便的重载 useRef<T>(null)，它自动返回 RefObject&lt;T | null&gt;。为了简化由于 useRef 所需参数的迁移，添加了一个方便的重载 useRef(undefined)，它自动返回 RefObject&lt;T | undefined&gt;。</p><h4 id="ReactElement类型变化"><a href="#ReactElement类型变化" class="headerlink" title="ReactElement类型变化"></a><code>ReactElement</code>类型变化</h4><p>如果元素被标记为<code>ReactElement</code>，则<code>ReactElement</code>的<code>props</code>现在默认为<code>unknown</code>而不是<code>any</code>。如果向<code>ReactElement</code>传递类型参数则不会受到影响</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Example2</span> = <span class="title class_">ReactElement</span>&lt;&#123; <span class="attr">id</span>: <span class="built_in">string</span> &#125;&gt;[<span class="string">&quot;props&quot;</span>];</span><br><span class="line"><span class="comment">//   ^? &#123; id: string &#125;</span></span><br></pre></td></tr></table></figure><p>但是如果依赖默认设置，则需要处理<code>unknown</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Example</span> = <span class="title class_">ReactElement</span>[<span class="string">&quot;props&quot;</span>];</span><br><span class="line"><span class="comment">//   ^? Before, was &#x27;any&#x27;, now &#x27;unknown&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="TypeScript-中的-JSX-namespace-变化"><a href="#TypeScript-中的-JSX-namespace-变化" class="headerlink" title="TypeScript 中的 JSX namespace 变化"></a>TypeScript 中的 JSX namespace 变化</h4><p>类型中删除全局<code>JSX</code>命名空间转而使用<code>React.JSX</code>。防止全局类型的污染和不同 UI 库之间利用 JSX 产生冲突</p><p>现在，需要在<code>declare module</code>中的<code>JSX</code>命名空间的模块进行修改</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global.d.ts</span></span><br><span class="line">+ <span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&quot;react&quot;</span> &#123;</span><br><span class="line">    <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">      <span class="keyword">interface</span> <span class="title class_">IntrinsicElements</span> &#123;</span><br><span class="line">        <span class="string">&quot;my-element&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">myElementProps</span>: <span class="built_in">string</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure><p>准确的模块说明符取决于在<code>tsconfig.json</code>的<code>compilerOptions</code>中指定的 JSX 运行时：</p><ul><li>对于<code>&quot;jsx&quot;: &quot;react-jsx&quot;</code>，将是 <code>react/jsx-runtime</code>。</li><li>对于 <code>&quot;jsx&quot;: &quot;react-jsxdev&quot;</code>，将是 <code>react/jsx-dev-runtime</code>。</li><li>对于 <code>&quot;jsx&quot;: &quot;react&quot;</code> 和 <code>&quot;jsx&quot;: &quot;preserve&quot;</code>，它将是 <code>react</code>。</li></ul><h4 id="更好的useReducer类型"><a href="#更好的useReducer类型" class="headerlink" title="更好的useReducer类型"></a>更好的<code>useReducer</code>类型</h4><p><code>useReducer</code>类型推断得到了改善。然而这需要一个破坏性的变化，其中<code>useReducer</code>不再接受完整的<code>reducer</code>类型作为类型参数，而是需要接收<code>State</code>和<code>Action</code>的类型</p><p>新的最佳实践是不要向 useReducer 传递类型参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- useReducer&lt;<span class="title class_">React</span>.<span class="property">Reducer</span>&lt;<span class="title class_">State</span>, <span class="title class_">Action</span>&gt;&gt;(reducer)</span><br><span class="line">+ <span class="title function_">useReducer</span>(reducer)</span><br></pre></td></tr></table></figure><p>这可能在边缘情况下无法正常工作，例如可以通过在元组中传递<code>Action</code>来显式输入状态和操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- useReducer&lt;<span class="title class_">React</span>.<span class="property">Reducer</span>&lt;<span class="title class_">State</span>, <span class="title class_">Action</span>&gt;&gt;(reducer)</span><br><span class="line">+ useReducer&lt;<span class="title class_">State</span>, [<span class="title class_">Action</span>]&gt;(reducer)</span><br></pre></td></tr></table></figure><p>如果内联定义 reducer，建议注释函数参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- useReducer&lt;<span class="title class_">React</span>.<span class="property">Reducer</span>&lt;<span class="title class_">State</span>, <span class="title class_">Action</span>&gt;&gt;(<span class="function">(<span class="params">state, action</span>) =&gt;</span> state)</span><br><span class="line">+ <span class="title function_">useReducer</span>(<span class="function">(<span class="params">state: State, action: Action</span>) =&gt;</span> state)</span><br></pre></td></tr></table></figure><p>这也是如果将 reducer 移动到<code>useReducer</code>调用之外需要做的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state: State, action: Action</span>) =&gt; state;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://react.dev/blog/2024/04/25/react-19#whats-new-in-react-19" >React 19 Beta Upgrade Guide<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://react.dev/blog/2024/04/25/react-19#whats-new-in-react-19" >React 19 Beta<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="react" scheme="https://blog.flytam.vip/categories/react/"/>
    
    
    <category term="react" scheme="https://blog.flytam.vip/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端 js 异常那些事</title>
    <link href="https://blog.flytam.vip/%E5%89%8D%E7%AB%AF%20js%20%E5%BC%82%E5%B8%B8%E9%82%A3%E4%BA%9B%E4%BA%8B.html"/>
    <id>https://blog.flytam.vip/%E5%89%8D%E7%AB%AF%20js%20%E5%BC%82%E5%B8%B8%E9%82%A3%E4%BA%9B%E4%BA%8B.html</id>
    <published>2024-05-03T03:10:31.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人无完人，所以代码总会出异常的，异常并不可怕，关键是怎么处理</p><h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p><strong>程序发生了意想不到的情况，影响到了程序的正确运行</strong></p><p>从根本上来说，异常就是一个普通的对象，其保存了异常发生的相关信息，比如错误码、错误信息等。以 JS 中的标准内置对象 Error 为例，其标准属性有 message。许多宿主环境额外增加了 filename 和 stack 等属性</p><p>错误只有被 throw，才会产生异常，不被抛出的错误不会产生异常。比如直接<code>new Error()</code>甚至打印 Error 但是不 throw，也是不会产生异常</p><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><h4 id="编译时异常"><a href="#编译时异常" class="headerlink" title="编译时异常"></a>编译时异常</h4><p>源代码在编译成可执行代码之前产生的异常，无需执行即有异常。编译、语法解析发生错误。编译型语言对于这种很常见的，但是解析型的 js 也是会有编译型异常。通常是非合法的 js 语句、ts 编译报错</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="number">1</span> <span class="comment">// Uncaught SyntaxError: Unexpected number</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码本身不会执行就抛异常，不会处理到打印 1 的阶段。这种情况通常不会有实际影响，因为 babel/ts 等工具处理时就会直接报错。除非不经编译直接写代码，例如有时候我们直接写在 html 中写的一些代码</p><h4 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h4><p>代码被执行之后产生的异常。这些通常是很难提前发现的，因为代码实际运行中会遇到。比较常见的如<code>TypeError: Cannot read properties of undefined</code>这样的读取了<code>undefined</code>的属性。运行时异常对比编译时异常的特点是代码执行到异常代码前都是会正常执行的</p><p>执行到<code>a.b.c</code>前的打印能成功，异常抛出后后面的语句就不能执行了。运行时异常即可是这种引擎层面抛出的也可以是代码手动抛出的</p><p>而上面说的编译时异常，即使异常语句前的正常语句也是不会执行</p><h2 id="异常传播"><a href="#异常传播" class="headerlink" title="异常传播"></a>异常传播</h2><p>异常抛出就像事件冒泡一样具有传递性。如果一个异常没有被 catch，它会沿着函数调用栈一层层传播直到栈空。</p><p>异常会不断传播直到遇到第一个 catch。 如果都没有捕获，会抛出类似 unCaughtError，表示发生了一个异常，未被捕获的异常通常会被打印在控制台上</p><h4 id="error-对象"><a href="#error-对象" class="headerlink" title="error 对象"></a>error 对象</h4><p><code>Error</code>本身作为函数直接调用和被 new 调用的效果是一样的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a = Error(&#x27;a&#x27;)</span><br><span class="line"></span><br><span class="line">const b = new Error(&#x27;b&#x27;)</span><br></pre></td></tr></table></figure><p>javascript 规范中总共有 8 中错误类型构造函数</p><ul><li>Error – 错误对象</li><li>SyntaxError –解析过程语法错误（上面提到的编译时异常）</li><li>TypeError – 不属于有效类型（上面举例的运行时异常）</li><li>ReferenceError – 无效引用（严格模式下直接访问一个未定义的变量）</li><li>RangeError – 数值超出有效范围</li><li>URIError – 解析 URI 编码出错</li><li>EvalError – 调用 eval 函数错误</li><li>InternalError – Javascript 引擎内部错误的异常抛出， “递归太多”</li></ul><p>Error 是错误的基类，其他类型都继承 Error 这个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">SyntaxError</span>) === <span class="title class_">Error</span>);    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">TypeError</span>) === <span class="title class_">Error</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">ReferenceError</span>) === <span class="title class_">Error</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">RangeError</span>) === <span class="title class_">Error</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">URIError</span>) === <span class="title class_">Error</span>);   <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">EvalError</span>) === <span class="title class_">Error</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>默认的 error 对象只有一个 message 信息，很多时候对于错误的细分是很不好使，一般可以通过扩展这个错误对象，抛异常时抛出自定义的错误对象，在异常处理或时实现更精细化的处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ApiError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Error</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">message, code</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">super</span>(message);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">code</span> = code</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> err = <span class="keyword">new</span> <span class="title class_">ApiError</span>(<span class="string">&#x27;xxx&#x27;</span>, <span class="number">404</span>)</span><br><span class="line"></span><br><span class="line">err <span class="keyword">instanceof</span>  <span class="title class_">ApiError</span></span><br></pre></td></tr></table></figure><p>一种常见的应用就是在 axios 处理的异常中抛出一个扩展的 ApiError 对象，传递错误信息、错误等，在错误处理时对于这种错误进行特殊处理。如自定义上报、catch 住不作为 js 异常上报。不进行这种处理的话平时比较常见的情况就是会造成 slardar 的中 js 错误部分会有很多 axios 抛出的噪音</p><p>除了扩展错误对象，目前有一个处于 stage 4 的 Error Cause 提案 <a class="link"   href="https://github.com/tc39/proposal-error-cause%E3%80%82%E8%BF%99%E4%B8%AA%E6%8F%90%E6%A1%88%E4%B9%9F%E6%98%AF%E7%94%B1%E9%98%BF%E9%87%8C%E6%8E%A8%E8%BF%9B%E7%9A%84%E5%9B%BD%E5%86%85%E7%9A%84%E9%A6%96%E4%B8%AAes%E6%8F%90%E6%A1%88" >https://github.com/tc39/proposal-error-cause。这个提案也是由阿里推进的国内的首个es提案<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>Chrome 96 版本目前还不可用，firefox 可用</p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/115e09c55b7141ac8ac992f752469b2c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=684&h=368&s=49868&e=png&b=ffffff"></p><p>通过传递给 Error 构造函数的第二个参数一个 cause 属性为一个 Error 对象，即可看到是哪个错误具体产生当前的错误，对于一些调用链路比较深的可可能存在多个异常抛出情况这个特性还是相当好用的，可以准确追踪。Error Cause 当然用自定义扩展错误也能够实现这个功能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">doJob</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> rawResource = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;//domain/resource-a&#x27;</span>)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Download raw resource failed&#x27;</span>, &#123; <span class="attr">cause</span>: err &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="keyword">const</span> jobResult = <span class="title function_">doComputationalHeavyJob</span>(rawResource);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;//domain/upload&#x27;</span>, &#123; <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>, <span class="attr">body</span>: jobResult &#125;)</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Upload job result failed&#x27;</span>, &#123; <span class="attr">cause</span>: err &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">doJob</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Caused by&#x27;</span>, e.<span class="property">cause</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error: Upload job result failed</span></span><br><span class="line"><span class="comment">// Caused by TypeError: Failed to fetch</span></span><br></pre></td></tr></table></figure><p>Error 的相关 api</p><ul><li>改变堆栈帧数</li></ul><p>默认情况下，V8 引发的几乎所有错误都具有一个 stack 属性，该属性保存最顶层的 10 个堆栈帧，格式为字符串 <code>at xxx</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa06058f95364452a2c9d8cf5d02793c~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1090&h=178&s=54446&e=png&b=fef5f5"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error.stackTraceLimit</span><br></pre></td></tr></table></figure><p><code>Error.stackTraceLimit</code> 属性指定堆栈跟踪收集的堆栈帧数。默认值为 <code>10</code>，可以设置为任何有效的 JavaScript 数值。 更改将影响值更改后捕获的任何堆栈跟踪。如果设置为非数字值，或设置为负数，则堆栈跟踪将不会捕获任何帧</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a55aea0730e948f1905b246fba44c0ac~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=538&h=378&s=35553&e=png&b=fefefe"></p><ul><li>收集自定义异常</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(error, constructorOpt)</span><br></pre></td></tr></table></figure><p>这个 API 可以给自定义对象追加 stack 属性，达到模拟 Error 的效果，追加的 stack 表示调用 <code>Error.captureStackTrace()</code> 的代码中的位置的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomError</span>(<span class="params">message</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">message</span> = message;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="title class_">CustomError</span>.<span class="property">name</span>;</span><br><span class="line">  <span class="title class_">Error</span>.<span class="title function_">captureStackTrace</span>(<span class="variable language_">this</span>); <span class="comment">// 给对象追加stack属性</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&#x27;msg&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/18a3f459d2284749a87f0ced62a63a2b~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1212&h=210&s=70842&e=png&b=fffefe"></p><p>需要注意的是<code>stack</code>属性对于不同浏览器的格式是不一致的，通常而言监控 sdk 会统一做处理</p><p>这个方法支持传递一个<code>constructorOpt</code>参数，表示所有 <code>constructorOpt</code> 以上的帧，包括 <code>constructorOpt</code>，都将从生成的堆栈跟踪中省略。具体的差异如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4569a1fe0e4a4a2fb83cd1cf31f13528~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1242&h=336&s=56655&e=png&b=ffffff"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1730aaca4dc54bd381a0d437be13b088~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1082&h=304&s=50166&e=png&b=ffffff"></p><p>使用这个参数可以用于调用栈过深时隐藏深层次的一些调用细节</p><ul><li>sourcemap 还原错误</li></ul><p>还原错误也是利用了 error 对象的 stack 属性。可以使用<code>stacktracey</code>和<code>source-map</code>实现根据错误堆栈还原到实际发生错误的代码</p><p>线上代码经过压缩后一般只有 1 行，对于定位原始错误是很困难的。并且默认的<code>e.stack</code>属性是个字符串，可以借助<code>stacktracey</code>进行解析并结合<code>source-map</code>进行反解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceMap = <span class="built_in">require</span>(<span class="string">&#x27;source-map&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SourceMapConsumer</span> = sourceMap.<span class="property">SourceMapConsumer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Stacktracey</span> = <span class="built_in">require</span>(<span class="string">&#x27;stacktracey&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> errorStack = <span class="string">&#x27;...&#x27;</span>; <span class="comment">// 错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceMapFileContent = <span class="string">&#x27;...&#x27;</span>; <span class="comment">// sourcemap文件内容</span></span><br><span class="line"><span class="keyword">const</span> tracey = <span class="keyword">new</span> <span class="title class_">Stacktracey</span>(errorStack); <span class="comment">// 解析错误信息</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceMapContent = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(sourceMapFileContent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> consumer = <span class="keyword">await</span> <span class="keyword">new</span> <span class="title class_">SourceMapConsumer</span>(sourceMapContent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> frame <span class="keyword">of</span> tracey) &#123; <span class="comment">// 这里的frame就是stack中的一行所解析出来的内容</span></span><br><span class="line">    <span class="comment">// originalPosition不仅仅是行列信息，还有错误发生的文件 originalPosition.source</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> originalPosition = consumer.<span class="title function_">originalPositionFor</span>(&#123;</span><br><span class="line">        <span class="attr">line</span>: frame.<span class="property">line</span>,</span><br><span class="line">        <span class="attr">column</span>: frame.<span class="property">column</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拿到错误所对应的源码以及上面的行列号</span></span><br><span class="line">    <span class="keyword">const</span> sourceContent = consumer.<span class="title function_">sourceContentFor</span>(originalPosition.<span class="property">source</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(sourceContent);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动、手动抛出"><a href="#自动、手动抛出" class="headerlink" title="自动、手动抛出"></a>自动、手动抛出</h4><p>异常可手动抛出也可自动抛出</p><p>自动抛出：代码执行报错由引擎抛出。这种由于逻辑缺失容错造成的自动抛出错误应该是要尽最大程度杜绝并防范的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a.<span class="property">b</span>.<span class="property">c</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>手动抛出：直接调用<code>throw</code></p><p>那什么时候应该手动抛出异常呢？一个指导原则就是已经预知到程序不能正确进行下去了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">a</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="attr">b</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;xxxx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抛出异常还是返回特定错误信息"><a href="#抛出异常还是返回特定错误信息" class="headerlink" title="抛出异常还是返回特定错误信息"></a>抛出异常还是返回特定错误信息</h4><p>对于上面提到可预知的异常需要终止流程，也可以使用抛出异常或者返回特定数据来让调用方感知。</p><ul><li>抛出异常</li></ul><p>好处，调用方无需判断返回值，抛出异常默认就不会走后面的逻辑代码了。常见于 axios 对于 code 非 0 的异常抛出处理并自定义上报。再结合上面提到的扩展 error 对象，可以在监控上报前判断属于特定错误不作为 js 上报，避免网络异常造成的 js 错误增加噪音</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">instance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(<span class="keyword">async</span> (<span class="attr">res</span>: <span class="title class_">AxiosResponse</span>&lt;<span class="title class_">Result</span>&gt;) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res?.<span class="property">data</span>?.<span class="property">statusCode</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ApiError</span>(<span class="string">&#x27;xx&#x27;</span>, res?.<span class="property">data</span>?.<span class="property">statusCode</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>不抛异常而是返回特定信息</li></ul><p>如果上述的代码不抛出异常而是直接返回 res 的话，每一处调用就都要手动判断 code。接口 http 返回 http code 200 而响应体 code 不等于 0 也属于不抛异常而是返回特定信息的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">api</span>()</span><br><span class="line"><span class="keyword">if</span> (res.<span class="property">code</span> !==<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h4 id="同步、异步"><a href="#同步、异步" class="headerlink" title="同步、异步"></a>同步、异步</h4><p>try-catch 作为 JavaScript 中处理异常的一种标准方式，如果 try 块中的任何同步代码发生了错误，就会立即退出代码执行过程，然后执行 catch 块。此时 catch 块会接收到一个包含错误信息的对象。try-catch 使用时也可以搭配 finnally 使用。 finally 一经使用，其代码无论如何都会执行。对于异步调用可封装成 promise 的 catch 方法进行调用或借助 async/await 语法糖使用 try/catch</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="title function_">fn</span>()</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// catch</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>().<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123; <span class="keyword">await</span> <span class="title function_">fn</span>() &#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>可能到处 try catch 确实不是一种优雅的方式，可以进行适当的封装</p><ol><li> 对于异步 promise 调用可以直接使用<a class="link"   href="https://github.com/scopsy/await-to-js" >await-to-js<i class="fas fa-external-link-alt"></i></a>，利用 Promise 的特性，分别在 promise.then 和 promise.catch 中返回不同的数组，其中 fulfilled 的时候返回数组第一项为 null，第二个是结果。rejected 的时候，返回数组第一项为错误信息，第二项为 undefined。使用的时候，判断第一项是否为空，即可知道是否有错误</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> to <span class="keyword">from</span> <span class="string">&#x27;await-to-js&#x27;</span>;</span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncTask</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">let</span> err, user, savedTask;</span><br><span class="line">     [err, user] = <span class="keyword">await</span> <span class="title function_">to</span>(<span class="title class_">UserModel</span>.<span class="title function_">findById</span>(<span class="number">1</span>));</span><br><span class="line">     <span class="keyword">if</span>(!user) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomerError</span>(<span class="string">&#x27;No user found&#x27;</span>);</span><br><span class="line">     [err, savedTask] = <span class="keyword">await</span> <span class="title function_">to</span>(<span class="title class_">TaskModel</span>(&#123;<span class="attr">userId</span>: user.<span class="property">id</span>, <span class="attr">name</span>: <span class="string">&#x27;Demo Task&#x27;</span>&#125;));</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span>(err) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CustomError</span>(<span class="string">&#x27;Error occurred while saving task&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user.<span class="property">notificationsEnabled</span>) &#123;</span><br><span class="line">       <span class="keyword">const</span> [err] = <span class="keyword">await</span> <span class="title function_">to</span>(<span class="title class_">NotificationService</span>.<span class="title function_">sendNotification</span>(user.<span class="property">id</span>, <span class="string">&#x27;Task Created&#x27;</span>));</span><br><span class="line">       <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Just log the error and continue flow&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> 对于 class 方法调用适当使用装饰器进行 catch</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">CatchAsync</span>(<span class="params">errorLabel = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: unknown, key: string, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        errorLabel = errorLabel || key</span><br><span class="line">        <span class="keyword">const</span> originFn = descriptor.<span class="property">value</span></span><br><span class="line">        descriptor.<span class="property">value</span> = <span class="keyword">async</span> <span class="keyword">function</span> (<span class="params">...rest: unknown[]</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> originFn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...rest)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">               <span class="comment">// do something</span></span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">CatchSync</span>(<span class="params">errorLabel = <span class="string">&#x27;&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">target: unknown, key: string, descriptor: PropertyDescriptor</span>) &#123;</span><br><span class="line">        errorLabel = errorLabel || key</span><br><span class="line">        <span class="keyword">const</span> originFn = descriptor.<span class="property">value</span></span><br><span class="line">        descriptor.<span class="property">value</span> = <span class="keyword">function</span> (<span class="params">...rest: unknown[]</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> originFn.<span class="title function_">call</span>(<span class="variable language_">this</span>, ...rest)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line">                <span class="keyword">throw</span> e</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    @<span class="title class_">CatchAsync</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Promise catch 小细节</p><blockquote><p>以下两种写法的区别</p></blockquote><p><code>then(f1,f2) vs then(f1).catch(f2)</code></p><p>绝大多数情况下是相同的。</p><p>区别在于第一种写法 f2 无法捕获 f1 中的异常。第二种写法 f2 能捕获 f1 中的异常</p><h4 id="全局兜底"><a href="#全局兜底" class="headerlink" title="全局兜底"></a>全局兜底</h4><p>对于无需手动捕获或者没有捕获的异常最终会抛到全局。通过全局<code>error</code> 和<code>unhandledrejection</code>进行监听并处理。监听全局异常和未捕获的 Promise 异常并进行相关处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onReject</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="title function_">report</span>(e)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unhandledrejection&#x27;</span>, onReject, <span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onError</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p><code>window.onerror</code>和<code>window.addEventListener error</code>的区别</p><ul><li><code>window.onerror</code> 函数返回 true 可以阻止执行默认事件处理函数（即控制台没有 error 打印出来）</li><li><code>window.addEventListener error</code>若为捕获阶段，则可额外捕获静态资源的加载错误。<code>window.onerror</code>则无法捕获静态资源的加载错误</li></ul><h2 id="React-中的异常"><a href="#React-中的异常" class="headerlink" title="React 中的异常"></a>React 中的异常</h2><h4 id="白屏异常"><a href="#白屏异常" class="headerlink" title="白屏异常"></a>白屏异常</h4><blockquote><p>React 处理阶段的同步代码报错，整个组件树挂了导致卸载掉，页面展示白屏</p></blockquote><ul><li>生命周期函数报错</li><li>render 方法报错</li><li>构造函数报错</li></ul><p>上述提到的是同步代码报错，异步代码的报错是不会产生页面白屏，只是会产生一些 console 中的 error。同理，因为事件回调函数的处理不是在 React 处理阶段（初始化或者事件处理<code>setState</code>驱动 react 进行下次渲染的），所以事件处理函数中的报错同样不会触发白屏</p><h4 id="Error-Boundary"><a href="#Error-Boundary" class="headerlink" title="Error Boundary"></a><code>Error Boundary</code></h4><p>既然白屏问题如此严重，必须要有一种方式帮助开发者来感知 React 中的白屏问题。 于是 React16 就有了<code>Error Boundary</code>来用来捕获渲染时错误的概念，在 React 新增了两个生命周期<code>componentDidCatch</code>和<code>static getDerivedStateFromError</code>用于捕获渲染时的错误，也仅能捕获上面提到的白屏异常（如异步错误等也是没有办法被捕获到），也就是说如果我们在<code>Error Boundary</code>中捕获到错误并上报，这个错误通常是非常严重的。<code>Error Boundary</code>只可用于捕获子组件中发生的异常（自身出现渲染错误也是无法捕获的）</p><blockquote><p>无法捕获的异常</p></blockquote><ul><li><blockquote><p>事件处理</p></blockquote></li><li><blockquote><p>异步代码（例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 回调函数）</p></blockquote></li><li><blockquote><p>服务端渲染</p></blockquote></li><li><blockquote><p>它自身抛出来的错误（并非它的子组件）</p></blockquote></li><li>componentDidCatch</li></ul><p>用于出错时去执行的副作用代码，比如错误上报、错误兜底等</p><ul><li>static getDerivedStateFromError</li></ul><p>在出错后触发，改函数返回的值能进行 setState 更新，触发一次重新 render 来渲染错误时的 fallback 组件。如果这次渲染仍然出现渲染错误，页面仍然会白屏，而不是执行类似 render error -&gt; getDerivedStateFromError -&gt; render error 这样的死循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">error</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">error</span>: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">error</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>error<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Child中发生渲染错误</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Child</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`</p><ul><li><code>static getDerivedStateFromError</code>渲染阶段调用的，所以不允许出现副作用</li><li><code>componentDidCatch</code>【commit】阶段被调用，所以允许出现副作用</li></ul><p>目前 React 的 Error Boundary 提供的两个生命周期只存在于 class 组件；并没有相应的 hooks 能实现类似的功能</p><blockquote><p>There are no Hook equivalents to the uncommon <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code> and <code>componentDidCatch</code> lifecycles yet, but we plan to add them soon.</p></blockquote><p>但是有一个比较有趣的是，Preact 提供了相应的 hook <a class="link"   href="https://preactjs.com/guide/v10/hooks/#useerrorboundary" >useErrorBoundary<i class="fas fa-external-link-alt"></i></a>去实现 Error Boundary。preact 中的<code>useErrorBoundary</code>的功能和<code>getDerivedStateFromError</code>、<code>componentDidCatch</code>是一模一样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// error = The error that was caught or `undefined` if nothing errored.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resetError = Call this function to mark an error as resolved. It&#x27;s</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   up to your app to decide what that means and if it is possible</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//   to recover from errors.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [error, resetError] = <span class="title function_">useErrorBoundary</span>();</span><br></pre></td></tr></table></figure><p>用法也是非常简单，子组件触发异常会触发函数组件的 render 并且 error 是对应的错误信息，并且还提供了对应的 resetError 去重置错误。至于为何 Preact 能先于 React 支持功能，原因在于对于 Preact 的实现来说，它的函数组件和 class 组件都是实例化成一样的实例，函数组件的 hook 中直接定义<code>componentDidCatch</code>进行处理，componentDidCatch 捕获到错误后通过<code>setState</code>设置错误对象驱动下一次的 render 来拯救白屏</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useErrorBoundary</span>(<span class="params">cb</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> errState = <span class="title function_">useState</span>();</span><br><span class="line"></span><br><span class="line">    state.<span class="property">_value</span> = cb;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!currentComponent.<span class="property">componentDidCatch</span>) &#123;</span><br><span class="line"></span><br><span class="line">        currentComponent.<span class="property">componentDidCatch</span> = <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (state.<span class="property">_value</span>) state.<span class="title function_">_value</span>(err);</span><br><span class="line"></span><br><span class="line">            errState[<span class="number">1</span>](err);</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line"></span><br><span class="line">        errState[<span class="number">0</span>],</span><br><span class="line"></span><br><span class="line">        <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            errState[<span class="number">1</span>](<span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这是一个 react 的 Error Boundary 只存在于 class 组件，但是对于子组件是函数组件的情况下，相关 hooks 的异常（<code>useEffect</code>、<code>useLayoutEffect</code>）一样是能捕获到的</p><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>这么基础常用的 error-boundary 通常来说不需要我们手动去搞。开源社区已经有了成熟的封装解决方案<a class="link"   href="https://github.com/bvaughn/react-error-boundary" >react-error-boundary<i class="fas fa-external-link-alt"></i></a>。它基于 React 提供的 error boundary 能力提供了开箱即用的功能，使用的时候只需要将我们的组件作为<code>ErrorBoundary</code>的子组件传入即可，并且 ErrorBoundary 还提供 FallbackComponent 属性供出错时渲染 fallback 内容、错误恢复等许多更进阶的功能。并且也提供了 HOC 的方式供使用</p><h5 id="Error-Boundary-包子组件"><a href="#Error-Boundary-包子组件" class="headerlink" title="Error Boundary 包子组件"></a>Error Boundary 包子组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ErrorBoundary</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-error-boundary&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ErrorFallback</span>(<span class="params">&#123;error, resetErrorBoundary&#125;</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">role</span>=<span class="string">&quot;alert&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>Something went wrong:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;error.message&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;resetErrorBoundary&#125;</span>&gt;</span>Try again<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  )&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ui = (</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">FallbackComponent</span>=<span class="string">&#123;ErrorFallback&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  &gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ComponentThatMayError</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span>)</span><br></pre></td></tr></table></figure><h5 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;withErrorBoundary&#125; <span class="keyword">from</span> <span class="string">&#x27;react-error-boundary&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ComponentWithErrorBoundary</span> = <span class="title function_">withErrorBoundary</span>(<span class="title class_">ComponentThatMayError</span>, &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title class_">FallbackComponent</span>: <span class="title class_">ErrorBoundaryFallbackComponent</span>,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">onError</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something with the error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// E.g. log to an error logging client here</span></span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">@<span class="title function_">withErrorBoundary</span>(&#123;</span><br><span class="line">  <span class="title class_">FallbackComponent</span>: <span class="title class_">ErrorBoundaryFallbackComponent</span>,</span><br><span class="line">  <span class="title function_">onError</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// Do something with the error</span></span><br><span class="line">    <span class="comment">// E.g. log to an error logging client here</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ComponentThatMayError</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ui = <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentWithErrorBoundary</span> /&gt;</span></span></span><br></pre></td></tr></table></figure><p>在需要使用的地方对我们的组件进行一层包装即可。这时候可能会一种需求，手动包一层太麻烦了，为啥 react 不提供一个配置字段每个组件自带 error boundary 呢？</p><p>万能的开源社区也有人通过 babel 插件实现了这个能力<a class="link"   href="https://github.com/vodkabears/babel-plugin-transform-react-error-boundary" >babel-plugin-transform-react-error-boundary<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/.jsx?$/</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">use</span>: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line"></span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line"></span><br><span class="line">            <span class="attr">plugins</span>: [</span><br><span class="line"></span><br><span class="line">                [ <span class="string">&#x27;babel-plugin-transform-react-error-boundary&#x27;</span>, &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="title class_">ErrorBoundary</span>: <span class="string">&#x27;common/components/ErrorBoundary/index.js&#x27;</span></span><br><span class="line"></span><br><span class="line">                &#125; ]</span><br><span class="line"></span><br><span class="line">            ]</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过配置一个自定义的 Error Boundary 路径，即可实现所有的组件包一个 ErrorBoundary 了，再结合<code>react-error-boundary</code>一顿操作，<del>页面再也不会白屏了</del>。具体实现就是通过 babel 实现以下这样的转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ErrorBoundary</span> = <span class="built_in">require</span>(<span class="string">&#x27;./path/to/my/ErrorBoundary.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorBoundary</span>&gt;</span>&#123;this.__r__()&#125;<span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    __r__) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面提到 <code>Error boundaries</code>是不支持 ssr 场景的，所以又有人做了一个针对 ssr 的 babel 插件</p><p><a class="link"   href="https://github.com/doochik/babel-plugin-transform-react-ssr-try-catch" >babel-plugin-transform-react-ssr-try-catch<i class="fas fa-external-link-alt"></i></a>。 通过对 render 函数进行 trycatch 实现类似的功能</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">[</span><span class="string">&quot;react-ssr-try-catch&quot;</span><span class="punctuation">,</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// global errorHandler</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;errorHandler&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./path/to/my/SSRErrorHandler.js&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// component error render method</span></span><br><span class="line"></span><br><span class="line">            <span class="attr">&quot;errorRenderMethod&quot;</span><span class="punctuation">:</span> <span class="string">&quot;renderErrorState&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompoenent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>/&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ReactSSRErrorHandler</span> = <span class="built_in">require</span>(<span class="string">&#x27;./path/to/my/SSRErrorHandler.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCompoenent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">__originalRenderMethod__</span>();</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">ReactSSRErrorHandler</span>(e, <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="property">name</span>, <span class="variable language_">this</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="title function_">__originalRenderMethod__</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现更多的功能"><a href="#实现更多的功能" class="headerlink" title="实现更多的功能"></a>实现更多的功能</h5><p>Error Boundary 除了用于捕获错误，这个特性也可以用来实现 React Suspense 相关的功能</p><ol><li> Suspense + Lazy</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ProfilePage</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./ProfilePage&#x27;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Spinner</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ProfilePage</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简化实现Lazy + Suspense</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">lazy</span>(<span class="params">loader</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> component;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">Lazy</span>(<span class="params">props</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!prom) &#123;</span><br><span class="line"></span><br><span class="line">            prom = <span class="title function_">loader</span>();</span><br><span class="line"></span><br><span class="line">            prom.<span class="title function_">then</span>(</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="params">exports</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">                    component = <span class="built_in">exports</span>.<span class="property">default</span> || <span class="built_in">exports</span>;</span><br><span class="line"></span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">                    error = e;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> error;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lazy组件的render中，若组件未加载完成，抛出一个promise异常供Suspense的componentDidCatch捕获</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!component) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> prom;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">createElement</span>(component, props);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Lazy</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">Suspense</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    state = &#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">isLoading</span>: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidCatch</span>(<span class="params">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_mounted</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> error.<span class="property">then</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isLoading</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">                error.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">_mounted</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">isLoading</span>: <span class="literal">false</span> &#125;)</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mounted</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_mounted</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; children, fallback &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123; isLoading &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isLoading ? fallback : children;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li> Suspense + render 中的【同步】数据获取</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchApi</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 异步api</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;数据&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">useData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> [data,setData] = <span class="title function_">useState</span>()</span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">fetchApi</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">x</span>) =&gt;</span> <span class="title function_">setData</span>(x))</span><br><span class="line"></span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ProfilePage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="keyword">const</span> data = <span class="title function_">useData</span>()</span><br><span class="line">    <span class="keyword">if</span> (!data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span>/&gt;</span></span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchApi</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">   <span class="comment">// 异步api</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(<span class="string">&quot;数据&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getData = <span class="title function_">createFetcher</span>(fetchApi);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ProfilePage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">const</span> data = <span class="title function_">getData</span>()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;data&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loading</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ProfilePage</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cached = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createFetcher</span> = (<span class="params">promiseTask</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ref = cached;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref !== cached) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ref</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> task = <span class="title function_">promiseTask</span>();</span><br><span class="line"></span><br><span class="line">        task.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">            ref = res</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ref === cached) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> task</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Vue-中的异常"><a href="#Vue-中的异常" class="headerlink" title="Vue 中的异常"></a>Vue 中的异常</h2><p>vue 提供了 4 个异常处理的 API，分别是 <code>errorHandler，errorCaptured，renderError，warnHandler</code>。</p><h4 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h4><p>我们最常用的是全局配置中注册的 <code>errorHandler</code>，例如异常上报场景，可用如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="keyword">function</span> (<span class="params">error, vm, info</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">Slardar</span> &amp;&amp; <span class="variable language_">window</span>.<span class="title class_">Slardar</span>(<span class="string">&#x27;Sentry&#x27;</span>, <span class="function">(<span class="params">Sentry</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="title class_">Sentry</span>.<span class="title function_">captureMessage</span>(error);</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>errorHandler</code> 可以捕获 <code>render</code>（vue 模板）、生命周期钩子、watch 回调、methods 方法等函数内的<strong>同步代码异常</strong>，info 参数会接收到报错函数类型（render/mounted/…）；<strong>如果这些函数返回 promise ，则 promise 异常也会被捕获；</strong></p><h4 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h4><p><code>errorCaptured</code> 入参和 <code>errorHandler</code> 一样，它是 vue 组件的钩子函数，作用是<strong>捕获来自后代组件（注意不包含本组件）的错误。</strong> vue 中的错误传播规则可以总结为，<strong>从子到父传播，依次触发各组件的</strong> <code>errorCaptured</code> <strong>钩子，若某</strong> <code>errorCaptured</code> <strong>返回 false，则停止传播，否则最终会传播到全局的</strong> <code>errorHandler</code> <strong>；</strong></p><p>使用场景：我们可以在组件库等场景使用 <code>errorCaptured</code>，捕获内部异常并上报，从而避免和业务代码报错混淆；</p><h4 id="renderError"><a href="#renderError" class="headerlink" title="renderError"></a>renderError</h4><p><code>renderError</code> 只在开发者环境下工作，当 <code>render</code> 函数报错时，其错误将会作为第二个参数传递到 <code>renderError</code>，<code>renderError</code> 返回的 <code>vnode</code> 将会被渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line"></span><br><span class="line">  render (h) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;oops&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  renderError (h, err) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">h</span>(<span class="string">&#x27;pre&#x27;</span>, &#123; <span class="attr">style</span>: &#123; <span class="attr">color</span>: <span class="string">&#x27;red&#x27;</span> &#125;&#125;, err.<span class="property">stack</span>)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><p>使用场景：<code>renderError</code>可用于开发环节实时把组件错误渲染到页面；</p><h4 id="warnHandler"><a href="#warnHandler" class="headerlink" title="warnHandler"></a>warnHandler</h4><p><code>warnHandler</code> 和 <code>errorHandler</code>一样是全局配置项，但 <code>warnHandler</code> 只在开发者环境下生效，用于捕获 vue 告警。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.config.warnHandler = function (msg, vm, trace) &#123;</span><br><span class="line"></span><br><span class="line">  // `trace` 是组件的继承关系追踪</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：一般情况下开发者直接在控制台查看 warn，所以 <code>warnHandler</code> 使用场景非常有限。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://juejin.cn/post/6974383324148006926" >React，优雅的捕获异常 - 掘金<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/133632612" >精读《React Error Boundaries》<i class="fas fa-external-link-alt"></i></a></p><p><a class="link"   href="https://zhuanlan.zhihu.com/p/34210780" >React：Suspense 的实现与探讨<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="react 原生" scheme="https://blog.flytam.vip/categories/react-%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="react 原生" scheme="https://blog.flytam.vip/tags/react-%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>在ES模块中的使用 __dirname</title>
    <link href="https://blog.flytam.vip/%E5%9C%A8ES%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%20__dirname%20.html"/>
    <id>https://blog.flytam.vip/%E5%9C%A8ES%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%20__dirname%20.html</id>
    <published>2024-04-07T09:49:01.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ECMAScript 模块是 JavaScript 的新标准格式。在 Node.js 中越来越多的库逐渐从从 CommonJS 转移到 ES 模块</p><blockquote><p>注：这里是指“真”ES 模块并不是指代码中 Node.js 中使用 import 写法但是实际被 tsc 转成 commonJS 的形式</p></blockquote><p>但是 Node.js ES 开发中此前有一个棘手的问题是获取当前文件目录、路径。不过这个问题在最近也已经解决</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>在 ES 模块中，现在可以使用以下方式而不是使用<code>__dirname</code>或<code>__filename</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">dirname</span>  <span class="comment">// 当前模块的目录名 (__dirname)</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">filename</span> <span class="comment">//当前模块文件名 (__filename)</span></span><br></pre></td></tr></table></figure><h2 id="获取当前目录"><a href="#获取当前目录" class="headerlink" title="获取当前目录"></a>获取当前目录</h2><p>通过访问当前模块的目录路径，可以相对于代码所在位置遍历文件系统并在项目中读取或写入文件，或动态导入代码。相关的使用方式随着时间的推移而发生了一些变化，从 CommonJS 的实现到最新的 ES 模块更新</p><h3 id="旧的-CommonJS-方式"><a href="#旧的-CommonJS-方式" class="headerlink" title="旧的 CommonJS 方式"></a>旧的 CommonJS 方式</h3><p>Node.js 最初使用 CommonJS 模块系统。CommonJS 提供了两个变量，返回当前模块的目录名称和文件名称，分别是<code>__dirname</code>和<code>__filename</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__dirname  <span class="comment">// 当前模块所在的目录</span></span><br><span class="line">__filename <span class="comment">// 当前模块文件名</span></span><br></pre></td></tr></table></figure><h3 id="旧的-ES-模块方式"><a href="#旧的-ES-模块方式" class="headerlink" title="旧的 ES 模块方式"></a>旧的 ES 模块方式</h3><p><code>__dirname</code>和<code>__filename</code>在 ES 模块中不可用。需要使用以下代码来实现获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> url <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = url.<span class="title function_">fileURLToPath</span>(<span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&#x27;.&#x27;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>));</span><br><span class="line"><span class="keyword">const</span> __filename = url.<span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/8265/b0f06c61-a3a7-4fb1-a7cd-93ae39425c85.png"></p><h3 id="最新的-ES-模块方式"><a href="#最新的-ES-模块方式" class="headerlink" title="最新的 ES 模块方式"></a>最新的 ES 模块方式</h3><p>最终在经过许多讨论后，现在有了更好的方法。自从<a class="link"   href="https://nodejs.org/en/blog/release/v20.11.0" >Node.js20.11.0<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://deno.com/blog/v1.40#importmetafilename-and-importmetadirname" >Deno 1.40.0<i class="fas fa-external-link-alt"></i></a>和<a class="link"   href="https://bun.sh/blog/bun-v1.0.23#import-meta-dirname-and-import-meta-filename-support" >Bun 1.0.23<i class="fas fa-external-link-alt"></i></a>之后可以调用<code>import.meta</code>对象的<code>dirname</code>和<code>filename</code>属性来获取了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">dirname</span> <span class="comment">// 当前模块所在的目录</span></span><br><span class="line"><span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">filename</span><span class="comment">// 当前模块文件名</span></span><br></pre></td></tr></table></figure><h3 id="为什么需要一个新的-API"><a href="#为什么需要一个新的-API" class="headerlink" title="为什么需要一个新的 API"></a>为什么需要一个新的 API</h3><p>ES 模块是 JavaScript 的标准。然而 JavaScript 最初是作为在 Web 浏览器中运行的语言而诞生的。Node.js 流行起来后开始在服务器上运行 JavaScript，但必须使用一些约定来加载模块，Node.js 项目早期做出的一个选择是采用 CommonJS 模块系统及其相关内容</p><p>ES 模块是为浏览器和服务器环境设计的。浏览器通常没有文件系统访问权限，因此提供对当前目录或文件名的访问是没有意义。然而对于浏览器处理 URL，可以使用<code>file://scheme</code>以 URL 格式提供文件路径。因此，ES 模块具有对模块的 URL 的引用。即<code>import.meta.ur</code>l。可以看看在 Node.js 中可以使用 URL 的相关使用</p><p>假设一个名<code>为module.js</code>的 ES 模块包含以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br></pre></td></tr></table></figure><p>如果使用 Node.js 的服务器上运行此文件，则会得到以下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node module.js</span><br><span class="line">file:///path/to/module.js</span><br></pre></td></tr></table></figure><p>如果 Web 浏览器中加载 module.js，则会得到以下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/module.js</span><br></pre></td></tr></table></figure><p>基于不同上下文会有不同的结果</p><p><code>import.meta.url</code>是一个描述 URL 的字符串，而不是一个 URL 对象。可以通过将该字符串传递给<code>URL</code>构造函数将其转换为真正的 URL 对象：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fileUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(url.<span class="property">protocol</span>);</span><br><span class="line"><span class="comment">// Node.js: &quot;file:&quot;</span></span><br><span class="line"><span class="comment">// Browser: &quot;https:&quot;</span></span><br></pre></td></tr></table></figure><p>使用 URL 对象，可以使用 Node.js 的 URL 模块将模块的 URL 转换为文件路径，等价于 <code>__filename</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> url <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> filePath = url.<span class="title function_">fileURLToPath</span>(fileUrl);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(filePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /path/to/module.js</span></span><br></pre></td></tr></table></figure><p>也可以操作 URL 来获取目录名，等价于<code>__dirname</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> url <span class="keyword">from</span> <span class="string">&quot;url&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> directoryUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;.&quot;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> directoryPath = url.<span class="title function_">fileURLToPath</span>(directoryUrl);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(directoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /path/to</span></span><br></pre></td></tr></table></figure><h3 id="使用-URL-而不是字符串"><a href="#使用-URL-而不是字符串" class="headerlink" title="使用 URL 而不是字符串"></a>使用 URL 而不是字符串</h3><p>大多数的代码可能都是需要使用路径字符串来在 Node.js 中执行常见的文件操作。但其实许多在字符串路径上工作的 Node.js API 也可以使用<code>URL</code>对象</p><p><code>__dirname</code> 最常见的用途是遍历目录以查找要加载的数据文件。例如，如果 <code>module.js</code> 文件与名为 <code>data.json</code> 的文件位于同一目录中，并且想将数据加载到脚本中，则以前会像这样使用 <code>__dirname</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; join &#125; = <span class="built_in">require</span>(<span class="string">&quot;node:path&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; readFile &#125; = <span class="built_in">require</span>(<span class="string">&quot;node:fs/promises&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = <span class="title function_">join</span>(__dirname, <span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(filePath, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf8&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 ES 模块中可以直接使用<code>import.meta.dirname</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; join &#125; <span class="keyword">from</span> <span class="string">&quot;node:path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&quot;node:fs/promises&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> filePath = <span class="title function_">join</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">dirname</span>, <span class="string">&quot;data.json&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(filePath, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf8&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是也可以像如下使用 URL 对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&quot;node:fs/promises&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">readData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> fileUrl = <span class="keyword">new</span> <span class="title function_">URL</span>(<span class="string">&quot;data.json&quot;</span>, <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">readFile</span>(fileUrl, &#123; <span class="attr">encoding</span>: <span class="string">&quot;utf8&quot;</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 ES 模块为客户端和服务器编写的 JavaScript 带来了一致性，因此使用 URL 对象而不是路径字符串也可以实现相同的效果。更多关于替代<code>__dirname</code>可以<a class="link"   href="https://blog.logrocket.com/alternatives-dirname-node-js-es-modules/#what-is-your-goal" >参考<i class="fas fa-external-link-alt"></i></a></p><h2 id="如何找到-import-meta-dirname"><a href="#如何找到-import-meta-dirname" class="headerlink" title="如何找到 import.meta.dirname"></a>如何找到 <code>import.meta.dirname</code></h2><p><code>import.meta.dirname</code>和<code>import.meta.filename</code>可以在最新版本的 Node.js、Deno 和 Bun 中使用</p><p>Bun 已经提前实现了<code>import.meta.dir</code>和<code>import.meta.pat</code>，它们是等效的，所以<code>dirname</code>和<code>filename</code>在 bun 其实是<code>dir</code>和<code>path</code>的别名</p><p>由于这个属性仅涉及基础文件系统，因此仅在<code>import.meta.url</code>的 scheme 为<code>file:</code>时可用。也就是说在浏览器环境中不可用；在浏览器中尝试使用<code>import.meta.dirname</code>将仅返回 <code>undefined</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://www.sonarsource.com/blog/dirname-node-js-es-modules/" >__dirname is back in Node.js with ES modules<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>巧用 exports 和 typeVersions 提升 npm 包用户使用体验</title>
    <link href="https://blog.flytam.vip/%E5%B7%A7%E7%94%A8%20exports%20%E5%92%8C%20typeVersions%20%E6%8F%90%E5%8D%87%20npm%20%E5%8C%85%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C.html"/>
    <id>https://blog.flytam.vip/%E5%B7%A7%E7%94%A8%20exports%20%E5%92%8C%20typeVersions%20%E6%8F%90%E5%8D%87%20npm%20%E5%8C%85%E7%94%A8%E6%88%B7%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C.html</id>
    <published>2023-05-07T02:39:08.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h2><p>对于开发一个 JavaScript 三方库供外部使用而言，<code>package.json</code>是其中不可缺少的一部分</p><p>一般而言，对于库开发者来说，我们会在<code>package.json</code>中指定我们的导出入口。一般而言会涉及两个字段<code>main</code>和<code>export</code>，它们会涉及到当前模块在被导入的行为。通常我们会将<code>main</code>字段指向 cjs 产物，<code>module</code>字段指向 ES 产物</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a><code>main</code></h3><p><code>main</code>字段指定了该模块的主入口文件，即 require 该模块时加载的文件。该字段的值应为相对于模块根目录的路径或者是一个模块名（如<code>index.js</code>或<code>lib/mymodule.js</code>，如果是模块名，则需要保证在该模块根目录下存在该模块）。主入口文件可以是 JavaScript 代码、JSON 数据或者是 Node.js C++扩展</p><h3 id="module"><a href="#module" class="headerlink" title="module"></a><code>module</code></h3><p><code>module</code>字段是 ES 模块规范下的入口文件，它被用于支持 import 语法。当使用 esm 或 webpack 等工具打包时，会优先采用 module 字段指定的入口文件。如果没有指定 module 字段，则会使用 main 字段指定的入口文件作为默认的 ES 模块入口文件</p><h2 id="指定导出"><a href="#指定导出" class="headerlink" title="指定导出"></a>指定导出</h2><p>一般情况下，我们使用<code>main</code>和<code>module</code>在大部分场景下对于开发一个库来说已经足够。但是如果想实现更精细化的导出控制就无法满足</p><p>当我们一个库本身同时包含运行时和编译时的导出时，如果我们导出的模块在编译时（node 环境）包含副作用，如果运行时模块也从同一入口导出就会出现问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如编译时入口存在以下编译时副作用</span></span><br><span class="line"><span class="comment">// buildtime.ts</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(process.<span class="property">env</span>.<span class="property">xxx</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">buildLog</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;build time&quot;</span>)</span><br><span class="line"><span class="comment">// runtime.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">runLog</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;run time&quot;</span>)</span><br><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./buildtime.ts&quot;</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./runtime.ts&quot;</span></span><br></pre></td></tr></table></figure><p>当前，可以通过解决掉副作用规避这个问题，但是很可能我们依赖的第三方模块也是有复作用的这个时候就无解了。此时最好的办法是将这个库的运行时和编译时从两个入口进行导出，这样子就不存在某一方影响到另一方。库使用者也不需关心从统一入口导入的方法到底是编译时方法还是运行时方法</p><p>这个时候就可以利用<code>package.json</code>的<code>exports</code>字段进行导出，当存在该字段时会忽略<code>main</code>和<code>module</code>字段。该字段在 Node.js 12 版本中引入，可用来大幅简化模块的导出方式，支持同时支持多个环境下的导出方式，提供了更好的可读性和可维护性</p><p>支持以下用法</p><ol><li>多文件导出</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;name&quot;</span>: <span class="string">&quot;pkg&quot;</span>,</span><br><span class="line"><span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./dist/index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;./runtime&quot;</span>: <span class="string">&quot;./dist/runtime.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;./buildtime&quot;</span>: <span class="string">&quot;./dist/buildtime.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当运行<code>require(&#39;pkg&#39;)</code> 时会加载<code>dist/index.js</code>，而当运行 <code>require(&#39;pkg/runtime&#39;)</code>时会加载<code>dist/runtime.js</code>，<code>require(&#39;pkg/buildtime&#39;)</code> 则会加载 <code>dist/buildtime.js</code></p><ol start="2"><li>多条件导出</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;pkg&quot;</span>,</span><br><span class="line">  <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;dist/index.js&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/index.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/index.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;node&quot;</span>: <span class="string">&quot;./dist/index.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./dist/index.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./runtime&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/runtime.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/runtime.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;node&quot;</span>: <span class="string">&quot;./dist/runtime.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./dist/runtime.js&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;./buildtime&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./dist/buildtime.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./dist/buildtime.mjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;node&quot;</span>: <span class="string">&quot;./dist/buildtime.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./dist/buildtime.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于条件，目前 node 支持<code>import</code>、<code>require</code>、 <code>node</code>、<code>node-addons</code>和<code>default</code>。同时社区对于其它环境也定义了如<code>types</code>、<code>deno</code>、<code>browser</code>等供不同环境使用。具体规范<a class="link"   href="https://github.com/nodejs/node/blob/HEAD/doc/api/packages.md#conditions-definitions" >可见<i class="fas fa-external-link-alt"></i></a></p><ol start="3"><li>目录导出<br>支持目录的整体导出</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exports&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;./lib/*&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./lib/*.js&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>按照上述操作完成后，打包就能符合相关预期，但是对于 typescript 文件的导入如果使用<code>runtime</code>路径是会找不到相应的类型文件，typescript 并不会去识别该字段，已有的讨论<a class="link"   href="https://github.com/microsoft/TypeScript/issues/33079" >issues<i class="fas fa-external-link-alt"></i></a></p><blockquote><p>注：对于配置 <code>tsconfig.json</code> <code>&quot;compilerOptions.moduleResolution&quot;: &quot;Node16&quot;</code>的项目可以在 <code>exports</code> 命名导出配置相应的 types 字段指向 ts 声明文件</p></blockquote><p><img src="https://files.mdnice.com/user/8265/83877d4d-5682-4044-bbd2-3b2bd598fd6b.png"></p><p>此时需要借助<code>package.json</code>的<code>typeVersions</code>字段进行声明供 ts 识别</p><p>对于这个例子，我们在库的<code>package.json</code>中增加如下，表示各路径分别导出的类型文件路径</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;typesVersions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;*&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;.&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./dist/index.d.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;runtime&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dist/runtime.d.ts&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;buildtime&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dist/dist/runtime.d.ts&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>此时我们就能看见能正确找到相应的类型提示</p><p><img src="https://files.mdnice.com/user/8265/6ac120fe-f6ce-4977-bb98-1eaa438943ff.png"></p><p><img src="https://files.mdnice.com/user/8265/5c0c70c2-24ed-4a99-bfb1-8385c9753796.png"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>目前 Node.js 12+和主流的打包工具都已经支持<code>exports</code>字段的解析，下面来简单看下 webpack 的实现</p><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p>webpack 已经内置支持对于<code>exports</code>的解析，它的解析由<a href="https://github.com/webpack/enhanced-resolve"><code>enhance-resolve</code></a>实现</p><p><img src="https://files.mdnice.com/user/8265/e9bf71e5-a59a-42fe-8d45-e5fc565cbe2a.png"></p><p><code>createResolver</code>是<code>enhance-resolve</code>导出的<code>create</code>函数，用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/webpack/enhanced-resolve/blob/main/README.md</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">CachedInputFileSystem</span>, <span class="title class_">ResolverFactory</span> &#125; = <span class="built_in">require</span>(<span class="string">&quot;enhanced-resolve&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a resolver</span></span><br><span class="line"><span class="keyword">const</span> myResolver = <span class="title class_">ResolverFactory</span>.<span class="title function_">createResolver</span>(&#123;</span><br><span class="line"><span class="comment">// Typical usage will consume the `fs` + `CachedInputFileSystem`, which wraps Node.js `fs` to add caching.</span></span><br><span class="line"><span class="attr">fileSystem</span>: <span class="keyword">new</span> <span class="title class_">CachedInputFileSystem</span>(fs, <span class="number">4000</span>),</span><br><span class="line"><span class="attr">extensions</span>: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>]</span><br><span class="line"><span class="comment">/* any other resolver options here. Options/defaults can be seen below */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve a file with the new resolver</span></span><br><span class="line"><span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> lookupStartPath = <span class="string">&quot;/Users/webpack/some/root/dir&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> request = <span class="string">&quot;./path/to-look-up.js&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> resolveContext = &#123;&#125;;</span><br><span class="line">myResolver.<span class="title function_">resolve</span>(context, lookupStartPath, request, resolveContext, <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">err <span class="comment">/*Error*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">filepath <span class="comment">/*string*/</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// Do something with the path</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过创建一个自定义 resolver 函数后可调用<code>resolve</code>函数根据当前的模块路径和一些配置查找一个模块的绝对路径</p><p>相关自定义 resolver 选项含义</p><ul><li><code>extensions</code> 查找的文件扩展名</li><li><code>conditionNames</code> 对应<code>package.json</code>中的<code>exports</code>条件</li><li><code>exportsFields</code> 指定从 package.json 哪个字段读取<code>exports</code>条件</li><li><code>fullySpecified</code> 为 true 时，解析器会优先尝试使用完全指定的路径来解析模块请求，而忽略其他任何条件。如果找到了对应的模块文件，则直接返回该路径；否则抛出错误</li></ul><p>通过相关上述代码我们可以知道</p><ul><li>对于解析<code>es</code>导入，webpack 会尝试读取<code>exports</code>字段的导出，依次读取<code>import</code>和<code>node</code>字段。并且这里也是直接配置了<code>fullySpecified</code>。即处理相对路径的导入如<code>import foo from &#39;./foo&#39;;</code>时，Webpack 在解析模块请求时会直接将 ./foo.js 当作完整路径来处理，而不进行路径的拼接和解析</li><li>对于解析<code>cjs</code>导入，webpack 会尝试读取<code>exports</code>字段的导出，依次读取<code>require</code>和<code>node</code>字段。并且会尝试使用各种解析策略来解析该路径</li></ul><p>由于<code>enhance-resolve</code>是一个完全独立于 webpack 的模块，当我们自己实现一个三方打包器或者插件时，如果想实现类似的模块解析能力，也可以完全独立使用<code>enhance-resolve</code>来实现</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为了实现一个库更友好的导出，我们可以借助 package.json 的<code>exports</code>字段指定多条件的导出方式，主流打包工具以及 Node.js 都已经支持；对于 ts 类型，我们可以结合<code>typeVersions</code>进行配置</p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;默认导出&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="工程化" scheme="https://blog.flytam.vip/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="工程化" scheme="https://blog.flytam.vip/tags/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>React Labs： 我们最近在做什么——2023 年 3 月</title>
    <link href="https://blog.flytam.vip/React%20Labs%EF%BC%9A%20%E6%88%91%E4%BB%AC%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%E2%80%94%E2%80%942023%20%E5%B9%B4%203%20%E6%9C%88.html"/>
    <id>https://blog.flytam.vip/React%20Labs%EF%BC%9A%20%E6%88%91%E4%BB%AC%E6%9C%80%E8%BF%91%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%E2%80%94%E2%80%942023%20%E5%B9%B4%203%20%E6%9C%88.html</id>
    <published>2023-04-04T09:22:12.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><blockquote><p> 本文翻译自：<a class="link"   href="https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023" >https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023<i class="fas fa-external-link-alt"></i></a></p></blockquote><h2 id="React-Server-Components"><a href="#React-Server-Components" class="headerlink" title="React Server Components"></a>React Server Components</h2><p>React Server Components(下文简称 RSC) 是由 React 团队设计的新应用程序架构。</p><p>我们首先在一个<a class="link"   href="https://react.dev/blog/2020/12/21/data-fetching-with-react-server-components" >介绍性演讲<i class="fas fa-external-link-alt"></i></a>和一个<a class="link"   href="https://github.com/reactjs/rfcs/pull/188" >RFC<i class="fas fa-external-link-alt"></i></a>中分享了我们对 RSC 的研究。简要概括一下，我们正在引入一种新型组件——Server Components，它们可以提前运行，并且不包含在你的 JavaScript bundle 中。RSC 可以在构建过程中运行，让你从文件系统中读取或获取静态内容。它们也可以在服务器上运行，让你无需构建 API 即可访问数据层。你可以通过 props 将数据从 Server Components 传递到浏览器中的交互式 Client Components。</p><p>RSC 将服务端中心多页应用程序的简单“请求/响应”心智模型与客户端为中心的单页应用程序的无缝交互结合起来提供最佳体验。</p><p>自上次更新以来，我们已经合并了<a class="link"   href="https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md" >React Server Components RFC<i class="fas fa-external-link-alt"></i></a>以验证该提议。我们解决了与<a class="link"   href="https://github.com/reactjs/rfcs/blob/main/text/0227-server-module-conventions.md" >React Server 模块约定<i class="fas fa-external-link-alt"></i></a>提案有关的未决问题，并与合作伙伴达成共识，采用<code>&quot;use client&quot;</code>约定。这些文档还充当符合 RSC 兼容实现所需支持的规范。</p><p>最大的变化是我们引入了<code>async/await</code>作为从 Server Components 进行数据提取的主要方法。我们还计划通过引入一个名为<code>use</code>的新 hook，从客户端支持数据加载，该 hook 将数据从<code>Promise</code>中取出来。虽然我们无法在客户端应用程序中的任意组件中支持<code>async/await</code>，但是当你将客户端应用程序构建为与 RSC 应用程序类似的结构时，我们计划添加对其的支持</p><p>既然我们已经很好地解决了数据提取问题，我们正在探索另一个方向：从客户端向服务器发送数据，以便可以执行数据库变更和实现表单逻辑。我们通过让你在服务器/客户端之前传递<code>Server Action</code>函数来做到这一点，客户端可以调用这些函数来无缝调用 RPC。<code>Server Action</code>可以在 JavaScript 加载之前提供渐进式增强表单</p><p>React Server Component 已经内置在[Next.js App Router](Next.js App Router)中。这演示了路由与 RSC 作为基本组件之间深度集成的示例，但这不是构建符合 RSC 兼容路由器和框架的唯一方法。 RSC 规范和实现提供了功能明确分离。 React Server Components 旨在成为可跨兼容 React 框架工作的组件规范。</p><p>通常建议使用现有框架，但如果需要构建自己定制化框架也是可能的。构建符合 RSC 兼容框架并不像我们希望的那样容易，这主要是由于需要进行深度打包集成。目前的打包工具并没有为在服务器和客户端之间拆分单个模块图提供完整的支持。这就是为什么现在我们直接与打包工具开发者合作，以便将 RSC 的基本组件集成进去。</p><h2 id="资源加载"><a href="#资源加载" class="headerlink" title="资源加载"></a>资源加载</h2><p><a class="link"   href="https://react.dev/reference/react/Suspense" >Suspense<i class="fas fa-external-link-alt"></i></a>让你可以指定在组件的数据或代码仍在加载时屏幕上显示什么内容。这使得用户可以逐步看到更多内容，而页面正在加载以及在路由器导航期间加载更多数据和代码</p><p>我们正在努力将 Suspense 与样式表、字体和图像的加载生命周期完全整合在一起，以便 React 考虑它们来确定内容是否准备好显示。即使没有更改 React 组件编写方式，在更新方面也会以更一致且令人愉悦的方式。作为优化措施，我们还将提供手动预装像字体这样的资源直接从组件中提取资源。</p><p>我们目前正在实现这些功能，并将很快有更多分享。</p><h2 id="Document-Metadata"><a href="#Document-Metadata" class="headerlink" title="Document Metadata"></a>Document Metadata</h2><p>应用程序中的不同页面和屏幕可能具有不同的元数据，例如 <code>title</code> 标签、描述和其它特定于此屏幕的<code>meta</code> 标签。从维护的角度来看，将此信息保持接近页面或屏幕的 React 组件更加可扩展。但是，这些元数据的 HTML 标签需要在文档 head 中，通常在应用程序根部渲染组件中呈现。</p><p>今天，通常可以使用以下两种技术解决这个问题。</p><p>一种方案是呈现一个特殊的第三方组件，将 <code>title</code>、<code>meta</code> 和其它 tag 移到<code>head</code>标签中。这适用于大部分浏览器，但有很多客户端不会运行客户端 JavaScript（例如 Open Graph 解析器），因此这种技术并不普适</p><p>另一种方案是将页面在服务端渲染分成两步。首先渲染主要内容并收集所有此类标记。然后使用这些<code>tag</code>渲染文档的<code>head</code>。最后将文档<code>head</code>和内容发送到浏览器中。这种方法可行但无法利用 React 18 的 Streaming Server Renderer 的优势，因为必须等待所有内容渲染完成后才能发送文档和<code>head</code></p><p>因此我们正在添加内置支持，可以在组件树中任何位置直接呈现 <code>title</code>、<code>meta</code> 和 <code>link</code> 标签。在所有环境中，包括完全客户端代码、SSR 和未来的 RSC 中都可以使用相同的方式工作。我们很快将分享更多关于这个功能的细节</p><h2 id="React-Optimizing-Compiler"><a href="#React-Optimizing-Compiler" class="headerlink" title="React Optimizing Compiler"></a>React Optimizing Compiler</h2><p>自我们上次更新以来，我们一直在积极迭代 <a class="link"   href="https://react.dev/blog/2022/06/15/react-labs-what-we-have-been-working-on-june-2022#react-compiler" >React Forget<i class="fas fa-external-link-alt"></i></a> 的设计，这是一个针对 React 的优化编译器。我们以前曾将其称为“自动记忆化编译器”，从某种意义上说这是正确的。但是，构建编译器帮助我们更深入地了解了 React 的编程模型。更好地理解 React Forget 的一种方法是将其视为自动响应式编译器。</p><p>React 的核心思想是开发人员将用户界面定义为当前状态的函数。可以使用普通 JavaScript 值（数字、字符串、数组、对象）和标准 JavaScript 语法（<code>if/else</code>、for 等）来描述组件逻辑。心智模型是当应用程序状态更改时，React 会重新渲染。我们认为这个简单的心理模型和接近 JavaScript 语义的原则是 React 编程模型中的重要原则。</p><p>问题在于，React 有时过于反应迅速：它可能会重新渲染太多次。例如，在 JavaScript 中，我们没有低成本的方式来比较两个对象或数组是否相等（具有相同的键和值），因此在每次渲染时创建一个新对象或数组可能会导致 React 做出比必要更多的工作 。这意味着开发人员必须明确地记忆组件以避免对更改过度响应。</p><p>React Forget 的目标是确保 React 应用程序具有恰到好处的响应性：即仅在状态值有意义地更改时重新渲染应用程序。从实现的角度来看，这意味着自动记忆化，但我们认为反应性框架是更好地理解 React 和 Forget 的一种方法。可以将其视为 React 当前重新渲染时更改对象标识时，React Forge 会在语义值改变时重新渲染-但不会产生深层比较的运行时成本。</p><p>在具体进展方面，自我们上次更新以来，我们已经大量迭代了编译器设计以符合这种自动响应的方法，并纳入了内部使用编译器的反馈意见。去年末开始对编译器进行了一些重大重构之后，我们现在开始在 Meta 的有限领域中将编译器用于生产。一旦我们证明它可以用于生产环境中并成功开源后，我们计划开源它。</p><p>最后，很多人对编译器是如何工作感兴趣。当我们证明了该编译器并进行开源后，期待分享更多细节内容。但是现在有一些细节可以分享：</p><p>该编译器的核心几乎完全与 Babel 脱钩，并且核心编译器 API 是（大致上）输入旧 AST 输出新 AST（同时保留源位置数据）。在底层，我们使用自定义代码表示和转换管道来进行低级语义分析。但是，编译器的主要公共接口将通过 Babel 和其他构建系统插件进行。为了便于测试，我们目前有一个 Babel 插件，它是一个非常薄的包装器，它调用编译器生成每个函数的新版本并将其交换。</p><p>过去几个月中，在对编译器进行重构时，我们希望专注于细化核心编译模型以确保能够处理复杂性（例如条件、循环、变量重新赋值和修改等）。但是 JavaScript 有很多表达每个功能的方法：<code>if/else</code>、三元运算符、<code>for</code>、<code>for-in</code>、<code>for-of</code>等。试图支持完整语言会延迟我们验证核心模型的时间节点。相反，我们从语言中选择了一小部分但代表性较强的子集：<code>let/const</code>、<code>if/else</code> 语句、<code>for</code> 循环、对象数组原始值函数调用和其他一些特性。随着我们对核心模型信心增强并改进内部抽象层次结构，在受支持的语言子集中扩展支持范围。关于尚未支持的语法，我们也明确地记录了未经支持的输入的诊断日志并跳过编译。我们拥有工具，可以在 Meta 的代码库上尝试编译器并查看最常见的不受支持特性，以便我们可以优先处理它们。我们将继续逐步扩展以支持整个语言。</p><p>使 React 组件中的普通 JavaScript 具有响应式需要具有深刻语义理解的编译器，使其能够准确理解代码实际在做什么。通过采取这种方法，我们正在创建一个 JavaScript 中用于响应式操作的系统，它可以让你使用语言的全部表现力编写任何复杂度产品代码，而不是仅限于特定领域语言。</p><h2 id="Offscreen-Rendering"><a href="#Offscreen-Rendering" class="headerlink" title="Offscreen Rendering"></a>Offscreen Rendering</h2><p>Offscreen rendering 是 React 中即将推出的一种能力，可以在不增加额外性能开销的情况下，在后台渲染屏幕。你可以将其视为<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/CSS/content-visibility" >content-visibility CSS 属性<i class="fas fa-external-link-alt"></i></a>的一种版本，它不仅适用于 DOM 元素，而且适用于 React 组件。在我们的研究中，我们发现了不同的用例：</p><ul><li><p>路由可以在后台预渲染屏幕，这样当用户导航到它们时就可以立即使用。</p></li><li><p>标签切换组件可以保留隐藏标签的状态，这样用户就可以在不丢失进度的情况下切换。</p></li><li><p>虚拟化列表组件可以预先渲染可见窗口上方和下方的额外 padding。</p></li><li><p>打开弹框或弹出窗口时，应用程序中的其余部分可以进入“后台”模式，以便事件和更新对除模态以外的所有内容都被禁止。</p></li></ul><p>大多数 React 开发人员不会直接与 React offscreen APIs 交互。相反，offscreen rendering 将被集成到路由器和 UI 库等组件中，并且使用这些库的开发人员将自动受益而无需进行额外工作。</p><p>关键思想是应该能够在不改变编写组件方式情况下呈现任何 React 树形结构。当组件被离屏渲染时，它不会实际挂载，直到组件变得可见，其效果不会触发。例如，如果组件使用<code>useEffect</code>在首次出现时记录分析数据，则预渲染不会影响这些分析数据的准确性。同样，在组件离开屏幕时，它的效果也将被卸载。offscreen rendering 的一个关键特性是你可以在不丢失其状态的情况下切换组件的可见性。</p><p>自我们上次更新以来，在 Meta 内部我们已经测试了 React Native 应用程序上 Android 和 iOS 版本中预渲染的实验版本，并取得了积极表现。我们还改进了如何将悬挂与离屏呈现结合使用——在离屏树中悬停将不会触发悬挂回退操作。我们剩下的工作是完成暴露给库开发人员的基本元素。我们希望在今年晚些时候发布 RFC 并提供实验 API 进行测试和反馈</p><h2 id="Transition-Tracing"><a href="#Transition-Tracing" class="headerlink" title="Transition Tracing"></a>Transition Tracing</h2><p>Transition Tracing API 是 React 中的一个 API，可以帮助检测<a class="link"   href="https://react.dev/reference/react/useTransition" >React Transition<i class="fas fa-external-link-alt"></i></a>变慢的原因并进行排查。在我们上次更新后，我们已经完成了 API 的初始设计并发表了<a class="link"   href="https://github.com/reactjs/rfcs/pull/238" >RFC<i class="fas fa-external-link-alt"></i></a>。基本功能也已被实现。该项目目前处于暂停状态。我们欢迎对 RFC 提供反馈，并期待恢复其开发以提供更好的 React 性能测量工具。这将特别适用于基于 React Transitions 构建的路由器，例如<a class="link"   href="https://react.dev/learn/start-a-new-react-project#nextjs-app-router" >Next.js App Router<i class="fas fa-external-link-alt"></i></a>。</p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 本文翻</summary>
      
    
    
    
    <category term="react" scheme="https://blog.flytam.vip/categories/react/"/>
    
    
    <category term="react" scheme="https://blog.flytam.vip/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Koa源码学习</title>
    <link href="https://blog.flytam.vip/Koa%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://blog.flytam.vip/Koa%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0.html</id>
    <published>2023-03-11T02:43:31.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://user-images.githubusercontent.com/20512530/224461174-8752bc0a-882c-4b9f-b210-f2dc144a9431.png" alt="WX20230311-104750@2x"></p><p>koa是一个非常流行的Node.js http框架。本文我们来学习下它的使用和相关源码</p><blockquote><p>来自官网的介绍：<br>Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序</p></blockquote><h2 id="为什么使用koa"><a href="#为什么使用koa" class="headerlink" title="为什么使用koa"></a>为什么使用koa</h2><p>使用koa而不直接使用Node.js的http模块</p><ol><li><p>高度可定制性：koa中实现了一套中间件机制以及在koa中万物皆中间件，我们通过中间件处理请求和响应并可以按需自由添加和修改中间件，并且koa的中间件生态非常丰富。而使用http需要自己编写全部的请求处理逻辑</p></li><li><p>异步编程：koa基于async/await语法，可以让异步编程变得更加简单和优雅。而直接使用http模块，则需要使用回调函数或事件监听的方式进行异步编程，不够直观</p></li><li><p>错误处理：koa内置的错误处理机制可以很好的捕获和处理错误，让代码更加健壮和可靠。而使用http模块，则需要自己编写错误处理逻辑，容易出现漏洞</p></li><li><p>扩展性：koa内置的扩展机制可以让开发者在不改变核心代码的情况下，轻松地扩展和定制koa的功能。而使用http模块，则需要自己编写全部的扩展逻辑，不够便捷</p></li></ol><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>koa的使用非常简单，引入koa后只需要6行代码即可访问3000端口的http服务返回一个<code>Hello koa</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello Koa&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>koa本身几乎没有封装任何进一步处理http请求的能力，而是实现了一套中间件的机制，所有的逻辑均由相关的中间件进行实现，中间件可以说是koa的灵魂</p><p>koa的中间件本质是一个函数，接收一个上下文对象（context）和一个next函数作为参数，然后对请求和响应进行处理，并将控制权传递给下一个中间件。中间件可以实现各种功能，例如路由、请求处理、错误处理等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">myMiddleware</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理请求</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 调用下一个中间件</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">  <span class="comment">// 处理响应</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如我们实现一个错误处理中间件，在服务端发生任何错误时给客户端返回一个500的状态码，可以以下实现即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">errorHandler</span> = <span class="keyword">async</span> (<span class="params">ctx, next</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 处理请求</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 调用下一个中间件</span></span><br><span class="line">    <span class="keyword">await</span> <span class="title function_">next</span>();</span><br><span class="line">    <span class="comment">// 处理响应</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 处理错误</span></span><br><span class="line">    ctx.<span class="property">status</span> = <span class="number">500</span>;</span><br><span class="line">    ctx.<span class="property">body</span> = err.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(errorHandler)</span><br></pre></td></tr></table></figure><p>以两个最常用的中间件为例</p><ul><li>koa-router</li></ul><p>koa默认也是没有封装对于特定的请求方法进行处理的功能，像很多http中处理路由相关的逻辑则需要引入<a class="link"   href="https://github.com/ZijianHe/koa-router" >koa-router<i class="fas fa-external-link-alt"></i></a> 进行使用。koa router提供了基础的路由路径处理、嵌套路由等一些基础路由能力</p><p><img src="https://files.mdnice.com/user/8265/d3e6d461-4b1c-4e05-9a58-a56ddb5fb7dc.png"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Router</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line"><span class="keyword">var</span> router = <span class="keyword">new</span> <span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ctx.router available</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">routes</span>())</span><br><span class="line">  .<span class="title function_">use</span>(router.<span class="title function_">allowedMethods</span>());</span><br></pre></td></tr></table></figure><p>koa-router的源码就不展开了，原理基本上在中间件中读取<code>req.url</code> 、 <code>req.method</code> 和相关<code>req</code>上的一些属性进行分发到相应的路由注册的回调返回中进行处理</p><ul><li>koa-body</li></ul><p>另一个常用的功能就是将请求的请求体数据解析成js对象，方便代码进行消费<br>对于node原生的http服务，我们需要监听请求对象的<code>data</code>和<code>end</code>事件，在data 事件中接收二进制buffer数据，在end事件中将buffer转成字符串再序列化成js对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">bodyParser</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">  <span class="comment">// the parsed body will store in ctx.request.body</span></span><br><span class="line">  <span class="comment">// if nothing was parsed, body will be an empty object &#123;&#125;</span></span><br><span class="line">  ctx.<span class="property">body</span> = ctx.<span class="property">request</span>.<span class="property">body</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样对于这类请求我们通过<code>ctx.request.body</code>就能获取到json请求的数据，无需关心从请求流关心如何获取请求体。koa-body不止处理json类型，它还会对form、text、xml等类型做相应的处理</p><p><img src="https://files.mdnice.com/user/8265/a334c01c-a4c1-4f8e-a14a-a05ac2d0e9b7.png"></p><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>koa的源码非常简洁，一共只有4个文件</p><p><img src="https://files.mdnice.com/user/8265/849988b7-7556-43d6-a830-3b0a3ffa448b.png"></p><h3 id="application"><a href="#application" class="headerlink" title="application"></a>application</h3><p>application.js定义了Koa类，用于创建koa app对象，下面是koa类的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Emitter</span> = <span class="built_in">require</span>(<span class="string">&#x27;events&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> compose = <span class="built_in">require</span>(<span class="string">&#x27;koa-compose&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> context = <span class="built_in">require</span>(<span class="string">&#x27;./context&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&#x27;./request&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> response = <span class="built_in">require</span>(<span class="string">&#x27;./response&#x27;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Koa</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Emitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">middleware</span> = [];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(context);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">request</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(request);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">response</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(response);</span><br><span class="line">    <span class="comment">// constructor中其它的逻辑忽略</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Koa类继承了<code>Emitter</code>类，用于实现事件的发布和订阅。还定义了一些属性，主要包括<code>middleware</code>、<code>context</code>、<code>request</code>和<code>response</code>。其中，<code>middleware</code>是中间件函数数组，用于存储所有的中间件函数；<code>context</code>是koa的请求上下文对象、<code>reques</code>t是请求对象实例、<code>response</code>是响应对象实例</p><p>koa实例上也暴露了几个对外使用的方法</p><ul><li><code>app.listen</code></li></ul><p>上面的使用demo，可以看到调用listen后就是监听指定端口运行起我们的http服务</p><p><img src="https://files.mdnice.com/user/8265/a60dd9f0-cab9-4856-937c-514563d84f2d.png"></p><p>通过查看<code>app.listen</code> 的实现本质是调用了<code>app.callback</code>获取到回调函数处理逻辑，再传给<code>http.createSerever</code>。所以也等价于以下调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Koa</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">http.<span class="title function_">createServer</span>(app.<span class="title function_">callback</span>()).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li><code>app.callback</code></li></ul><p>返回可以直接传递给 <code>http.createServer()</code> 方法的回调函数来处理请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">callback () &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">listenerCount</span>(<span class="string">&#x27;error&#x27;</span>)) <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onerror</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="variable language_">this</span>.<span class="title function_">createContext</span>(req, res)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> handleRequest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  handleRequest (ctx, fnMiddleware) &#123;</span><br><span class="line">  <span class="keyword">const</span> res = ctx.<span class="property">res</span></span><br><span class="line">  res.<span class="property">statusCode</span> = <span class="number">404</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onerror</span> = err =&gt; ctx.<span class="title function_">onerror</span>(err)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleResponse</span> = (<span class="params"></span>) =&gt; <span class="title function_">respond</span>(ctx)</span><br><span class="line">  <span class="title function_">onFinished</span>(res, onerror)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fnMiddleware</span>(ctx).<span class="title function_">then</span>(handleResponse).<span class="title function_">catch</span>(onerror)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要有以下几个逻辑</p><ul><li><p>判断我们是否有监听错误事件进行处理（<code>this.listenerCount</code>是继承的<code>EventEmiter</code>上用于获取某个事件监听次数的方法），如果没有则使用koa自带的默认错误处理</p></li><li><p>使用回调入参的<code>request</code>对象和<code>response</code>对象构造请求上下文对象并传递给<code>this.handleRequest</code>函数进行处理</p></li><li><p>在<code>handleRequest</code>中，就是调用了被compose完成后的中间件函数，在处理完成后调用<code>respond</code>进行结束整个请求的流程</p></li><li><p>在koa中我们无需像Node.js中http需要显式调用<code>res.end</code>或者<code>res.pipe</code>进行响应的结束发送，因为在<code>handleResponse</code>的<code>respond</code>函数中处理了。它会根据我们在业务逻辑设置的不同的body的类型进行相关调用，例如如果是一个流则调用<code>pipe</code>进行流式返回、特定状态码不返回body、非buffer和string的body序列化成字符串等</p></li></ul><p><img src="https://files.mdnice.com/user/8265/aa6c5f05-88e9-4c79-9505-8796712baeb9.png"></p><ul><li>洋葱模型</li></ul><p>koa的洋葱模型是一种中间件处理机制其核心是将请求和响应对象传递给一系列中间件函数，每个中间件函数都可以对请求和响应进行处理，并将控制权传递给下一个中间件函数，最终将响应返回给客户端。中间件函数在请求处理过程中像是一个个套在一起的“洋葱”，请求从外层中间件函数开始处理，逐层深入，直到最内层中间件函数，然后逐层返回，最终响应从最外层中间件函数返回给客户端</p><p>在洋葱模型中，每个中间件函数都是一个异步async函数。在处理请求时，每个中间件函数都接收一个<code>context</code>对象和一个<code>next</code>函数作为参数，context对象包含了请求和响应的信息，next函数可以调用下一个中间件函数</p><p>处理顺序如下</p><ol><li><p>请求从外层中间件函数开始处理，先经过第一个中间件函数</p></li><li><p>第一个中间件函数处理请求，然后调用<code>next</code>函数，将控制权传递给下一个中间件函数</p></li><li><p>下一个中间件函数也处理请求，然后调用<code>next</code>函数，将控制权传递给下一个中间件函数，直到最内层中间件函数</p></li><li><p>最内层中间件函数处理请求完成后逐层返回每个中间件函数在返回时可以对响应进行处理</p></li><li><p>最后，响应从最外层中间件函数返回给客户端</p></li></ol><p>洋葱模型的优点是可以将请求和响应的处理逻辑分解成多个模块，每个模块只需关注自己的逻辑，提高了代码的可维护性。由于每个中间件函数都可以对请求和响应进行处理，因此可以实现一些复杂的功能例如身份验证、日志记录、错误处理等</p><p>主要是<code>koa-compose</code>包的实现将中间件函数组合在一起，<code>compoose</code>实现代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span> (middleware) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// last called middleware #</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span> (i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;next() called multiple times&#x27;</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"> <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>)</span><br></pre></td></tr></table></figure><p><code>compose</code>函数接收一个中间件函数数组作为参数，返回一个新的中间件。新的中间件函数接收<code>context</code>和<code>next</code>对应于常规中间件的入参</p><p>函数内部实现了<code>dispatch</code>，用于递归调用中间件数组中的每个函数。<br><code>dispatch</code>函数接收一个参数<code>i</code>，表示当前调用的中间件函数在数组中的索引。如果i小于等于上一次调用的索引<code>index</code>，则表示<code>next</code>函数被多次调用，koa中间件中<code>next</code>只能被调用一次，调用多次会抛出一个错误。然后，<code>dispatch</code>将<code>index</code>赋值为i，表示当前调用的中间件函数已经被执行。然后<code>dispatch</code>函数会从中间件数组中取出当前索引对应的函数<code>fn</code>，如果当前索引<code>i</code>等于数组长度则说明已经到达中间件函数数组的末尾然后将<code>fn</code>设置为<code>next</code>函数。如果<code>fn</code>不存在则直接返回一个已经<code>resolve</code>的<code>Promise</code>。最后<code>dispatch</code>函数通过<code>Promise.resolve</code>调用当前中间件函数，并将<code>dispatch.bind(null, i + 1)</code>作为下一个中间件函数的next参数传入，以便递归调用下一个中间件函数。如果当前中间件函数抛出了一个错误则通过<code>Promise.reject</code>将错误传递给下一个中间件函数</p><p>总结原理是通过递归调用中间件函数数组中的每个函数，并将<code>next</code>函数作为参数传入，实现洋葱模型中间件的处理顺序。在递归调用的过程中，如果某个中间件函数抛出了错误则通过<code>Promise.reject</code>将错误逐层传递给下一个中间件函数，直到最终返回错误响应或者成功响应</p><h3 id="context"><a href="#context" class="headerlink" title="context"></a>context</h3><p>请求上下文对象，对应中间件的<code>ctx</code>入参<br><code>context.js</code>文件主要是对外导出了一个对象，以及执行了一系列<code>delegate</code>操作</p><p><img src="https://files.mdnice.com/user/8265/b41bba01-b559-4ca0-ab76-696f5e2ec700.png"></p><p><img src="https://files.mdnice.com/user/8265/5f9355ec-8587-4f72-a096-b0e5a457dc08.png"></p><ul><li><p>导出的对象主要是封装了cookie的读取逻辑</p></li><li><p><code>delegate</code>方法是从<a href="https://www.npmjs.com/package/delegates"><code>delegates</code></a> npm包进行导入（这个包的解读见<a class="link"   href="https://juejin.cn/post/6844903672543969287" ># 每天阅读一个 npm 模块(7)- delegates - 掘金<i class="fas fa-external-link-alt"></i></a>）</p></li></ul><p>简单来说就是将对<code>context</code>对象上的操作代理到koa封装的<code>request</code>和<code>response</code>对象中去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proto这里是context</span></span><br><span class="line"><span class="title function_">delegate</span>(proto, <span class="string">&#x27;response&#x27;</span>).<span class="title function_">method</span>(<span class="string">&#x27;append&#x27;</span>).<span class="title function_">access</span>(<span class="string">&#x27;body&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这个执行后的结果就是</p><ul><li><p><code>context.append</code>方法调用实际调用的是<code>context.response.append</code></p></li><li><p><code>context.body</code>的读写实际调的是<code>context.response.body</code>的读写<br>而<code>context.response</code>则在下面的<code>createContext</code>时将<code>koa</code>的<code>response</code>对象设置在<code>context</code>对象中去</p></li></ul><p>在<code>application</code>中通过<code>createContext</code>方法构造后传入请求处理回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Koa</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Emitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(context);</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    callback () &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="variable language_">this</span>.<span class="title function_">compose</span>(<span class="variable language_">this</span>.<span class="property">middleware</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">listenerCount</span>(<span class="string">&#x27;error&#x27;</span>)) <span class="variable language_">this</span>.<span class="title function_">on</span>(<span class="string">&#x27;error&#x27;</span>, <span class="variable language_">this</span>.<span class="property">onerror</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">handleRequest</span> = (<span class="params">req, res</span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> ctx = <span class="variable language_">this</span>.<span class="title function_">createContext</span>(req, res)</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">handleRequest</span>(ctx, fn)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> handleRequest</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">    createContext (req, res) &#123;</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">Context</span>&#125; */</span></span><br><span class="line">    <span class="keyword">const</span> context = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">context</span>)</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">KoaRequest</span>&#125; */</span></span><br><span class="line">    <span class="keyword">const</span> request = context.<span class="property">request</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">request</span>)</span><br><span class="line">    <span class="comment">/** <span class="doctag">@type</span> &#123;<span class="type">KoaResponse</span>&#125; */</span></span><br><span class="line">    <span class="keyword">const</span> response = context.<span class="property">response</span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="variable language_">this</span>.<span class="property">response</span>)</span><br><span class="line">    <span class="comment">// 挂载</span></span><br><span class="line">    context.<span class="property">app</span> = request.<span class="property">app</span> = response.<span class="property">app</span> = <span class="variable language_">this</span></span><br><span class="line">    context.<span class="property">req</span> = request.<span class="property">req</span> = response.<span class="property">req</span> = req</span><br><span class="line">    context.<span class="property">res</span> = request.<span class="property">res</span> = response.<span class="property">res</span> = res</span><br><span class="line">    request.<span class="property">ctx</span> = response.<span class="property">ctx</span> = context</span><br><span class="line">    request.<span class="property">response</span> = response</span><br><span class="line">    response.<span class="property">request</span> = request</span><br><span class="line">    context.<span class="property">originalUrl</span> = request.<span class="property">originalUrl</span> = req.<span class="property">url</span></span><br><span class="line">    context.<span class="property">state</span> = &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> context</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是将我们koa中常用的几个对象挂载到相应的地方，经过<code>createContext</code>的操作，我们可以得到可以通过以下方式获取相关对象</p><ul><li>koa <code>app</code>实例<ul><li><code>app === context.app === context.request.app === context.response.app</code></li></ul></li><li>koa 请求<code>context</code>对象<ul><li><code>context  === context.request.ctx === context.response.ctx</code></li></ul></li><li>koa <code>request</code>对象 <ul><li><code>ctx.request === ctx.response.request</code></li></ul></li><li>koa <code>response</code>对象<ul><li><code>ctx.response === ctx.request.response</code></li></ul></li><li>原生<code>req</code>对象<ul><li><code>context.req === context.request.req === context.response.req</code></li></ul></li><li>原生<code>res</code>对象<ul><li><code>context.res === context.response.res === context.request.res</code></li></ul></li></ul><h2 id="request"><a href="#request" class="headerlink" title="request"></a>request</h2><p>koa中的请求对象封装。基本上都是基于Node.js的http请求的request做一些便捷使用的二次封装的属性和方法，并挂载在<code>ctx.request</code>中</p><p>一个例子就是Node.js 的http server回调函数入参的req对象<code>http.ImcomingMessage</code> 是没有提供便捷的获取query参数信息，它只有一个url属性</p><p>而koa的<code>request</code>对象则实现了<code>query</code>的解析、获取、设置等</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// request.js</span></span><br><span class="line">get query () &#123;</span><br><span class="line">    <span class="keyword">const</span> str = <span class="variable language_">this</span>.<span class="property">querystring</span></span><br><span class="line">    <span class="keyword">const</span> c = <span class="variable language_">this</span>.<span class="property">_querycache</span> = <span class="variable language_">this</span>.<span class="property">_querycache</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> c[str] || (c[str] = qs.<span class="title function_">parse</span>(str))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">get querystring () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">req</span>) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">parse</span>(<span class="variable language_">this</span>.<span class="property">req</span>).<span class="property">query</span> || <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="response"><a href="#response" class="headerlink" title="response"></a>response</h3><p>koa中的响应对象封装，基于Node.js的http请求的response做一些封装的属性和方法，挂载在<code>ctx.response</code>中</p><p>一个比较常用到的就是会有根据我们的<code>ctx.body</code>设置的值（会delegate到<code>ctx.response.body</code>中）帮我们去设置response的<code>Content-Type</code>的值，例如给<code>ctx.body</code>设置一个普通js对象的话，会将<code>Content-Type</code>设置为json类型并将js对象json序列化（序列化逻辑在上面提到的respond函数中）</p><p><img src="https://files.mdnice.com/user/8265/1292b027-babb-4854-9d91-0600398f4655.png"></p><p><img src="https://files.mdnice.com/user/8265/7cd6062c-9148-4e6b-b605-007ea2f771a9.png"></p><h2 id="最近更新"><a href="#最近更新" class="headerlink" title="最近更新"></a>最近更新</h2><p>作为一个代码实现非常精简且已经非常稳定的广泛使用的框架，一般来说不会有什么更新了，2.x也已经稳定了很久。但是在1/2却更新了3.0.0-alpha.0版本，翻看更新记录这个大版本目前只更新了一个功能</p><p><img src="https://files.mdnice.com/user/8265/73335603-4104-465b-aa5e-75d1bfd86e6a.png"></p><p>可以直接使用<code>app.currentContext</code>来获取当前的请求上下文对象，这个功能可以方便不少我们的代码开发</p><p>通过上面我们知道，koa的<code>contxt</code>对象是每次请求维度的一个新对象，如果我们想在一些封装的方法中获拿到当前请求的<code>context</code>对象，必须层层传递<code>context</code>对象会比较麻烦</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  fn.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params">ctx</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx.<span class="property">url</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">fn</span> = fn</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> <span class="title class_">Koa</span>();</span><br><span class="line">app.<span class="title function_">use</span>(<span class="function"><span class="params">ctx</span> =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">body</span> = <span class="string">&#x27;Hello Koa&#x27;</span>;</span><br><span class="line">  <span class="title function_">fn</span>(ctx)</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>而支持了<code>app.currentContext</code>后，我们在任意地方想获取当前的请求上下文对象直接<code>app.currentContext</code>即可，无需再多层透传context对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  fn.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(app.<span class="property">currentContext</span>.<span class="property">url</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个功能的实现利用了Node.js的<code>async_hooks</code>模块提供的<code>AsyncLocalStorage</code>。<code>AsyncLocalStorage</code> 是 Node.js 在v14.8.0 版本中引入的一个模块，是官方推荐的在异步代码中管理数据的方式之一，会将我们保存的数据与异步操作所在的上下文关联起来，确保在异步操作中访问到相应正确的数据</p><p><code>AsyncLocalStorage</code> 有两个主要的方法</p><ul><li><p><code>run()</code>：用于在异步操作中保存数据。接收一个回调函数作为参数，该回调函数会在异步操作执行期间被调用，并且在该回调函数中保存的数据会与异步操作所在的上下文关联起来</p></li><li><p><code>getStore()</code>：用于在异步操作中获取数据。它会返回与异步操作所在的上下文关联的数据</p></li></ul><p>所以在koa中实现<code>app.currentContext</code>功能主要就是以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// application.js</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Emitter</span> &#123;</span><br><span class="line">   <span class="title function_">constructor</span> (options) &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">asyncLocalStorage</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="title class_">AsyncLocalStorage</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;async_hooks&#x27;</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">ctxStorage</span> = <span class="keyword">new</span> <span class="title class_">AsyncLocalStorage</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">use</span>(<span class="variable language_">this</span>.<span class="title function_">createAsyncCtxStorageMiddleware</span>())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  createAsyncCtxStorageMiddleware () &#123;</span><br><span class="line">    <span class="keyword">const</span> app = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">asyncCtxStorage</span> (ctx, next) &#123;</span><br><span class="line">      <span class="keyword">await</span> app.<span class="property">ctxStorage</span>.<span class="title function_">run</span>(ctx, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">   get currentContext () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">ctxStorage</span>) <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">ctxStorage</span>.<span class="title function_">getStore</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>如果初始化时配置了<code>option.asyncLocalStorage</code>，就注册一个放在第一位的koa中间件</p></li><li><p>在请求进入中间件时会执行<code>ctxStorage.run</code> 存入当前的<code>context</code>对象并马上在回调函数中执行<code>next</code>（即请求后续所有的操作）</p></li><li><p>在后续获取即可通过<code>getStore()</code>获取到当前请求的<code>context</code>对象</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的学习我们了解到了koa的一些使用和实现，koa的源码是非常精简的没有太多耦合功能，但是设计了巧妙的中间件机制设计来方便让我们开发各种功能</p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>一个超方便将现有博客生成VuePress2文档站的插件</title>
    <link href="https://blog.flytam.vip/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%96%B9%E4%BE%BF%E5%B0%86%E7%8E%B0%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90VuePress2%E6%96%87%E6%A1%A3%E7%AB%99%E7%9A%84%E6%8F%92%E4%BB%B6.html"/>
    <id>https://blog.flytam.vip/%E4%B8%80%E4%B8%AA%E8%B6%85%E6%96%B9%E4%BE%BF%E5%B0%86%E7%8E%B0%E6%9C%89%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90VuePress2%E6%96%87%E6%A1%A3%E7%AB%99%E7%9A%84%E6%8F%92%E4%BB%B6.html</id>
    <published>2022-12-10T15:27:03.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><h2 id="一个超方便将现有博客生成vuepress2文档站的插件"><a href="#一个超方便将现有博客生成vuepress2文档站的插件" class="headerlink" title="一个超方便将现有博客生成vuepress2文档站的插件"></a>一个超方便将现有博客生成vuepress2文档站的插件</h2><p>闲来无事，研究了一下vuepress2和它的插件机制，写了一个可以一键通过已有博客生成vuepress2的文档站的vuepress2插件<a class="link"   href="https://github.com/flytam/vuepress-plugin-blog-sync" >vuepress-plugin-blog-sync<i class="fas fa-external-link-alt"></i></a></p><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>在vuepress2中简单引入即可达到将<a class="link"   href="https://juejin.cn/user/3456520257288974/posts" >政采云掘金博客<i class="fas fa-external-link-alt"></i></a>一键生成vuepress2页面，效果✨ 详见<a href="https://blog.flytam.vip/vuepress-plugin-blog-sync">Demo</a></p><p><img src="https://files.mdnice.com/user/8265/6707c2f9-506f-4d55-9406-7bdac2ff674d.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vuepress-plugin-blog-sync</span><br></pre></td></tr></table></figure><p>按照vuepress<a class="link"   href="https://v2.vuepress.vuejs.org/zh/guide/getting-started.html" >文档<i class="fas fa-external-link-alt"></i></a>初始化后，<code>vuepress.config.ts</code>中修改成如下配置引入插件即可达到效果</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vuepress.config.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; defaultTheme, defineUserConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vuepress&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; blogSyncPlugin &#125; <span class="keyword">from</span> <span class="string">&#x27;vuepress-plugin-blog-sync&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineUserConfig</span>(&#123;</span><br><span class="line">  <span class="attr">lang</span>: <span class="string">&#x27;zh-CN&#x27;</span>,</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;vuepress-plugin-blog-sync Demo&#x27;</span>,</span><br><span class="line">  <span class="attr">description</span>: <span class="string">&#x27;Input juejin/csdn/github/etc, output vuepress2 web site&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: <span class="string">&#x27;/vuepress-plugin-blog-sync/&#x27;</span>,</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="title function_">blogSyncPlugin</span>(&#123;</span><br><span class="line">      <span class="attr">syncConfig</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;juejin&#x27;</span>,</span><br><span class="line">        <span class="attr">userId</span>: <span class="string">&#x27;3456520257288974&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">theme</span>: <span class="title function_">defaultTheme</span>(&#123;</span><br><span class="line">    <span class="attr">navbar</span>: [&#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&#x27;Github&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;https://github.com/flytam/vuepress-plugin-blog-sync&#x27;</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>主要利用了之前自己开发的<a class="link"   href="https://github.com/flytam/CsdnSyncHexo" >csdnsynchexo<i class="fas fa-external-link-alt"></i></a>提供的爬取网站文章的能力结合vuepress2提供的插件能力，150行代码即可实现，源码<a class="link"   href="https://github.com/flytam/vuepress-plugin-blog-sync/blob/main/packages/vuepress-plugin-blog-sync/src/node/plugin.ts" >详见<i class="fas fa-external-link-alt"></i></a>，下面简单介绍下相关实现点</p><h4 id="文章拉取"><a href="#文章拉取" class="headerlink" title="文章拉取"></a>文章拉取</h4><p>在vuepress2的<a class="link"   href="https://v2.vuepress.vuejs.org/zh/reference/plugin-api.html#oninitialized" >onInitialized<i class="fas fa-external-link-alt"></i></a>中进行拉取（使用<a class="link"   href="https://github.com/flytam/CsdnSyncHexo" >csdnsynchexo<i class="fas fa-external-link-alt"></i></a>提供的run函数），并进行相关的数据处理，然后通过插件传递的app实例往<code>app.pages</code>中添加我们拉取回来的文章信息，这里按照category作为路由分类</p><p><img src="https://files.mdnice.com/user/8265/f573a887-f6b1-4431-82e6-aef5706872b3.png"></p><h4 id="自动生成目录页"><a href="#自动生成目录页" class="headerlink" title="自动生成目录页"></a>自动生成目录页</h4><p>为了便于统一导航，设计了一个目录页的自动生成的逻辑，同时用户也可以自己传递<code>generateContent</code>进行目录页的内容生成</p><p><img src="https://files.mdnice.com/user/8265/3e8bd827-0fec-4151-b061-c394304dcee9.png"></p><h4 id="自动生成navbar"><a href="#自动生成navbar" class="headerlink" title="自动生成navbar"></a>自动生成navbar</h4><p>vuepress2的插件不再提供配置导航栏的相关api。对于默认主题，提供了在config文件中类似以下的配置能力</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineUserConfig</span>(&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="attr">theme</span>: <span class="title function_">defaultTheme</span>(&#123;</span><br><span class="line">    <span class="attr">navbar</span>: [&#123;</span><br><span class="line">      <span class="attr">text</span>: <span class="string">&#x27;Github&#x27;</span>,</span><br><span class="line">      <span class="attr">link</span>: <span class="string">&#x27;https://github.com/flytam/vuepress-plugin-blog-sync&#x27;</span>,</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>通过查阅vuepress2源码我们可以得知。vuepress2在node侧编译时，会将主题的<code>themeData</code>相关信息输出到一个本地文件，在客户端打包时去引用该文件获取到navbar相关信息进行渲染导航栏</p><p>输出<code>themeData</code>信息到一个本地文件<br><img src="https://files.mdnice.com/user/8265/26da7b7f-0caf-46dd-b37f-49b242cbc8d5.png"></p><p><img src="https://files.mdnice.com/user/8265/f7327144-7bc6-4b81-9f82-60848f1ad284.png"></p><p>显而易见，如果我们需要根据文章目录自动生成导航，就需要在生命周期中去将我们需要生成的导航信息写入到该文件的指定字段</p><p>经过查阅文档和调试，可以在<a class="link"   href="https://v2.vuepress.vuejs.org/zh/reference/plugin-api.html#onprepared" >onPrepared<i class="fas fa-external-link-alt"></i></a>hook中进行实现。并设计了默认会自动按照文章分类进行生成导航，也可以用户自己传递自定义函数来生成该导航的逻辑，自定义函数的两个入参分别是原来的导航对象和我们处理好的文章信息，返回一个新的导航对象用于替换掉原先的导航对象</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否根据文章category自动生成navbar</span></span><br><span class="line"><span class="comment">     * 默认主题</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@default</span> <span class="variable">true</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  navbar?: &#123;</span><br><span class="line">    custom?: <span class="function">(<span class="params">originNavbarConfig: DefaultThemeData[<span class="string">&#x27;navbar&#x27;</span>], blogMetaContext: BlogMetaContext</span>) =&gt;</span> <span class="title class_">DefaultThemeData</span>[<span class="string">&#x27;navbar&#x27;</span>]</span><br><span class="line">  &#125; | <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了保证对代码文件修改操作的稳定性，这里引入babel进行ast转换进行修改该字段并修改，修改完成后写入原来的<code>internal/themeData</code>文件</p><p><img src="https://files.mdnice.com/user/8265/a1464048-8bf3-452c-b5ca-456810c7448f.png"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>然后就搞定了。整个功能还是比较简单的。通过这样一个简单的插件编写，就能实现一个非常好玩的功能，并且也了解到vuepress2的源码和架构。还是挺不错的</p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个超方便将现有博客生成</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>AbortController的使用</title>
    <link href="https://blog.flytam.vip/AbortController%E7%9A%84%E4%BD%BF%E7%94%A8.html"/>
    <id>https://blog.flytam.vip/AbortController%E7%9A%84%E4%BD%BF%E7%94%A8.html</id>
    <published>2022-06-24T06:57:58.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"><br>今天介绍一个有用的 JavaScript api <code>AbortController</code></p><h4 id="AbortController是什么"><a href="#AbortController是什么" class="headerlink" title="AbortController是什么"></a><code>AbortController</code>是什么</h4><blockquote><p>AbortController 接口表示一个控制器对象，允许你根据需要中止一个或多个 Web 请求。你可以使用 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController/AbortController" >AbortController.AbortController()<i class="fas fa-external-link-alt"></i></a> 构造函数创建一个新的 AbortController。使用 <a class="link"   href="https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal" >AbortSignal<i class="fas fa-external-link-alt"></i></a> 对象可以完成与 DOM 请求的通信</p></blockquote><p>这个 api 简单来说就是可以提供一个能力给我们去提前终止一个 fetch 请求</p><p>一个终止 fetch 请求的 demo 如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">fetchButton.<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 点击abort button实现终止fetch请求</span></span><br><span class="line">  abortButton.<span class="property">onclick</span> = <span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> r = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;/json&#x27;</span>, &#123; <span class="attr">signal</span>: controller.<span class="property">signal</span> &#125;);</span><br><span class="line">    <span class="keyword">const</span> json = <span class="keyword">await</span> r.<span class="title function_">json</span>();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 如果fetch请求被终止会抛出一个AbortError的错误</span></span><br><span class="line">    <span class="keyword">const</span> isUserAbort = (e.<span class="property">name</span> === <span class="string">&#x27;AbortError&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/8265/35bc2099-0fb9-487d-b995-8144be0d5acb.png"></p><p>提前终止后这个请求在 network 面板中的 status 显示为 canceled</p><p>在没有<code>AbortController</code>这个 api 之前，我们是没法去让浏览器提前去终止一个请求的。而有了这个 api 之后，浏览器就能提前终止请求进而节约一些用户带宽。除此之外，这个 api 也能给我们带来一些新的开发模式</p><h4 id="Controller-和-Signal"><a href="#Controller-和-Signal" class="headerlink" title="Controller 和 Signal"></a>Controller 和 Signal</h4><p>下面实例化了一个<code>AbortController</code>，它的<code>signal</code>属性就是一个<code>AbortSignal</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; signal &#125; = controller;</span><br></pre></td></tr></table></figure><ul><li>controller 可通过<code>controller.abort()</code>去终止它对应的<code>signal</code></li><li><code>signal</code>本身是不能被直接终止的。可以将它传递给一些函数调用如 fetch 或者直接监听<code>signal</code>的状态变化（可以通过<code>signal.aborted</code>查看<code>signal</code>的状态或者监听它的<code>abort</code>事件）</li></ul><h4 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h4><h5 id="普通对象中的终止"><a href="#普通对象中的终止" class="headerlink" title="普通对象中的终止"></a>普通对象中的终止</h5><p>一些旧的 DOM api 是不支持<code>AbortSignal</code>。例如<code>WebScocket</code>只提供了一个<code>close</code>方法当我们无需使用时进行关闭。如果要使用<code>AbortSignal</code>则可以类似以下的封装</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abortableSocket</span>(<span class="params">url, signal</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> w = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(url);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (signal.<span class="property">aborted</span>) &#123;</span><br><span class="line">    w.<span class="title function_">close</span>();  <span class="comment">// signal已经终中止的情况下马上关闭websocket</span></span><br><span class="line">  &#125;</span><br><span class="line">  signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> w.<span class="title function_">close</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个使用也很简单，但是需要注意的是如果<code>signal</code>已经终止的情况下是不会触发<code>abort</code>事件，需要我们先进行一个判断是否<code>signal</code>已经终止</p><h5 id="移除事件监听"><a href="#移除事件监听" class="headerlink" title="移除事件监听"></a>移除事件监听</h5><p>我们经常需要在 js 中处理 dom 的监听和卸载工作。但是下面的例子由于事件监听和卸载传入的函数不是同一个引用时不会生效的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">doSomething</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不会生效</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">doSomething</span>());</span><br></pre></td></tr></table></figure><p>因此我们经常需要一些额外的代码去维护这个回调函数的引用的一致性。而有了<code>AbortSignal</code>之后我们就可以有一种的新的方式去实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; signal &#125; = controller;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> <span class="title function_">doSomething</span>(), &#123; signal &#125;);</span><br><span class="line"></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><p>因为<code>addEventListener</code>也能接收<code>signal</code>属性的。我们最后只需要调用<code>controller.abort()</code>，这个<code>controller</code>的<code>signal</code>传递的相关事件监听都会被自动相应卸载了</p><h5 id="构造器模式"><a href="#构造器模式" class="headerlink" title="构造器模式"></a>构造器模式</h5><p>在 JavaScript 中我们可能需要在对象中管理非常复杂的生命周期，如<code>WebSocket</code>。我们需要执行开启然后执行一系列逻辑后终止。可能我们会写以下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> someObject = <span class="keyword">new</span> <span class="title class_">SomeObject</span>();</span><br><span class="line">someObject.<span class="title function_">start</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一些操作后</span></span><br><span class="line">someObject.<span class="title function_">stop</span>();</span><br></pre></td></tr></table></figure><p>也可以通过<code>AbortSignal</code>进行实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line"><span class="keyword">const</span> &#123; signal &#125; = controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someObject = <span class="keyword">new</span> <span class="title function_">someObject</span>(signal);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一些操作后</span></span><br><span class="line">controller.<span class="title function_">abort</span>();</span><br></pre></td></tr></table></figure><ol><li><p>这能非常清晰地表示这个对象只能被执行一次，只能从开始到结束，而不能反过来。如果它终止了后想再次使用则需要再次创建一个对象</p></li><li><p>可以在很多地方共享一个<code>signal</code>。我们无需持有多个<code>SomeObject</code>的实例。只需要调用<code>controller.abort()</code>，这些<code>SomeObject</code>的实例都能被终止掉</p></li><li><p>如果<code>SomeObject</code>内部也有调用像<code>fetch</code>之类的内部 api 只需要把这个<code>signal</code>继续传递，则<code>fetch</code>也能被一起终止掉</p></li></ol><p>如下是一个例子。展示了两种 signal 的用法。传递给内置 api<code>fetch</code>和检查<code>signal</code>状态执行一些操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">SomeObject</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">signal</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">signal</span> = signal;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行一些操作例如发请求</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="title function_">fetch</span>(<span class="string">&#x27;/json&#x27;</span>, &#123; signal &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">doComplexOperation</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">signal</span>.<span class="property">aborted</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">`thing stopped`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1_000_000</span>; ++i) &#123;</span><br><span class="line">      <span class="comment">// 执行复杂操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="react-hook-中的异步调用"><a href="#react-hook-中的异步调用" class="headerlink" title="react hook 中的异步调用"></a>react hook 中的异步调用</h5><p>我们通常会在<code>useEffect</code>中进行一些异步 api 调用。借助<code>signal</code>可以在下一次<code>useEffect</code>重新调用 api 的时候将前一次的调用终止</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">FooComponent</span>(<span class="params">&#123; something &#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">    <span class="keyword">const</span> &#123; signal &#125; = controller;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> p = (<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> j = <span class="keyword">await</span> <span class="title function_">fetch</span>(url + something, &#123; signal &#125;);</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>();</span><br><span class="line">  &#125;, [something]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span>...<span class="tag">&lt;&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>也可以封装一个<code>useEffectAsync</code>的 hook</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useEffectAsync</span>(<span class="params">cb,dependence</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">   <span class="keyword">const</span> &#123; signal &#125; = controller;</span><br><span class="line">   <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="title function_">cb</span>(signal);</span><br><span class="line">     <span class="keyword">return</span> <span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>();</span><br><span class="line">   &#125;,dependence)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些有用的-AbortSignal-方法"><a href="#一些有用的-AbortSignal-方法" class="headerlink" title="一些有用的 AbortSignal 方法"></a>一些有用的 AbortSignal 方法</h4><blockquote><p>这些方法当前有可能还没有实现</p></blockquote><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout"><code>AbortSignal.timeout(ms)</code></a>: 创建一个给定时间后终止的<code>AbortSignal</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abortTimeout</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>(), ms);</span><br><span class="line">  <span class="keyword">return</span> controller.<span class="property">signal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>AbortSignal.any(signals)</code>：创建一个<code>AbortSignal</code>，如果传入的任一<code>signal</code>终止了，这个返回的<code>signal</code>也会被终止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abortAny</span>(<span class="params">signals</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> controller = <span class="keyword">new</span> <span class="title class_">AbortController</span>();</span><br><span class="line">  signals.<span class="title function_">forEach</span>(<span class="function">(<span class="params">signal</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (signal.<span class="property">aborted</span>) &#123;</span><br><span class="line">      controller.<span class="title function_">abort</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      signal.<span class="title function_">addEventListener</span>(<span class="string">&#x27;abort&#x27;</span>, <span class="function">() =&gt;</span> controller.<span class="title function_">abort</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> controller.<span class="property">signal</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted"><code>AbortSignal.throwIfAborted()</code></a>：如果<code>signal</code>本身已经终止了，调用该方法会抛出执行<code>abort(reason)</code>时指定的 reason 异常；否则只会静默执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (signal.<span class="property">aborted</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// becomes</span></span><br><span class="line">signal.<span class="title function_">throwIfAborted</span>();</span><br></pre></td></tr></table></figure><p>这个方法目前不太容易 polyfill，但是可通过下面的工具函数实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function throwIfSignalAborted(signal) &#123;</span><br><span class="line">  if (signal.aborted) &#123;</span><br><span class="line">    throw new Error(...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a class="link"   href="https://whistlr.info/2022/abortcontroller-is-your-friend/" >https://whistlr.info/2022/abortcontroller-is-your-friend/<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;br&gt;今天介绍一个有用的 JavaScript </summary>
      
    
    
    
    <category term="原生" scheme="https://blog.flytam.vip/categories/%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="原生" scheme="https://blog.flytam.vip/tags/%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>如何将Node.js库转换到Deno</title>
    <link href="https://blog.flytam.vip/%E5%A6%82%E4%BD%95%E5%B0%86Node.js%E5%BA%93%E8%BD%AC%E6%8D%A2%E5%88%B0Deno.html"/>
    <id>https://blog.flytam.vip/%E5%A6%82%E4%BD%95%E5%B0%86Node.js%E5%BA%93%E8%BD%AC%E6%8D%A2%E5%88%B0Deno.html</id>
    <published>2022-05-28T07:29:54.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"><br>由于Node和Deno的一些差异，一个库要想同时支持Node和Deno是需要一些改造的</p><blockquote><p>本文翻译自EdgeDb博客：<a class="link"   href="https://www.edgedb.com/blog/how-we-converted-our-node-js-library-to-deno-using-deno" >https://www.edgedb.com/blog/how-we-converted-our-node-js-library-to-deno-using-deno<i class="fas fa-external-link-alt"></i></a><br>如果需要将Deno项目直接迁移为Node项目可参考笔者另一篇文章<a class="link"   href="https://github.com/flytam/blog/issues/19" >deno 初体验，实战记录一个node项目迁移到deno需要做什么<i class="fas fa-external-link-alt"></i></a></p></blockquote><p><img src="https://files.mdnice.com/user/8265/73e25c5a-6705-4f55-b5b4-a7a656cb25e3.png"></p><p>Deno是一个新的JavaScript运行时，无需编译即原生支持TypeScript。它是由Node.js作者Ryan Dahl创建的，为了解决Node的一些基本设计、安全漏洞问题并集成了当前的一些开发实践如ES Module和TypeScript</p><p>在EdgeDb中，我们建立和维护了一个<a class="link"   href="https://github.com/edgedb/edgedb-js" >官方的npm上的Node.js客户端<i class="fas fa-external-link-alt"></i></a>。然而，Deno使用了一套完全不同的实践来处理依赖，即直接从公共包库(如<a href="https://deno.land/x"><code>deno.land/x</code></a>)<code>import</code>路径。我们将寻找一种简单的方法来<code>Deno化</code>我们的代码库。也就是用最简单的重构从现有的Node.js实现中生成一个Deno兼容的模块。这解决维护和同步两个几乎相同的代码库的重复工作带来的问题</p><p>我们采用了一种“运行时适配器”模式。这是一种通用的解决方法对其他希望支持Deno库的作者也会有用</p><h2 id="Node-js-vs-Deno"><a href="#Node-js-vs-Deno" class="headerlink" title="Node.js vs Deno"></a>Node.js vs Deno</h2><p>Node.js和Deno有一些重要的区别</p><ol><li><p><strong>TypeScript支持：</strong><br>Deno可以直接执行TypeScript而Node.js只能运行JavaScript代码</p></li><li><p><strong>模块解析：</strong><br>默认情况下，Node.js使用CommonJS导入模块并使用<code>require/module.exports</code>语法。它也有一个复杂的解析算法，会从<code>node_modules</code>加载像<code>react</code>这样的普通模块名，并在无额外扩展名导入时尝试添加<code>.js</code>或<code>.json</code>。如果导入路径是一个目录，则导入<code>index.js</code>文件</p></li></ol><p>Deno模块解析逻辑简化了很多。它使用了ECMAScript模块语法进行导入和导出。该语法也被TypeScript使用。所有导入必须是有显式文件扩展名的相对路径或者是一个URL</p><p>这意味着不存在像npm或yarn那样有<code>node_module</code>或<code>包管理器</code>。外部模块可以通过URL直接从公开代码库导入，比如<a href="https://deno.land/x/"><code>deno.land/x</code></a>或GitHub</p><ol start="3"><li><p><strong>标准库：</strong><br>Node.js有一些内置的<a class="link"   href="https://www.w3schools.com/nodejs/ref_modules.asp" >标准模块<i class="fas fa-external-link-alt"></i></a>如<code>fs</code>、<code>crypto</code>、<code>http</code>。这些包名由Node.js保留。相比之下Deno标准库是通过<code>https://deno.land/std/</code>URL导入的。Node和Deno标准库的功能也不同，Deno放弃了一些旧的或过时的Node.js api，引入了一个新的标准库(受Go的启发)，并统一支持现代JavaScript特性如<code>Promise</code>(而许多Node.js api仍然使用老的回调风格)</p></li><li><p><strong>内置全局变量：</strong><br>Deno所有的核心api都在全局变量Deno中，其它全局变量则只有标准的web api。和Node.js不同的是，Deno没有<code>Buffer</code>或<code>process</code>这些全局变量</p></li></ol><p>所以需要如何做才能让我们的Node.js库尽可能容易地在Deno中运行呢？下面将一步一步进行改造</p><h2 id="TypeScript和模块语法"><a href="#TypeScript和模块语法" class="headerlink" title="TypeScript和模块语法"></a>TypeScript和模块语法</h2><p>幸运的是，我们无需考虑将CommonJS的<code>require/module.exports</code>语法转换到到ESM<code>import/export</code>。我们使用用TypeScript编写<code>edgedb-js</code>，它已经使用了ESM语法。在编译过程中，<code>tsc</code>将我们的文件转换成普通的=CommonJS语法的JavaScript文件。Node.js可以直接运行编译后的文件</p><p>本文下面将讨论如何将TypeScript源文件修改为Deno可以直接使用的格式</p><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p><code>edgedb-js</code>没有任何第三方依赖，所以这里不必担心任何三方库的Deno兼容性问题。但仍需要将所有从Node.js标准库中导入(例如<code>path</code>、<code>fs</code>等)替换为等价的Deno文件</p><blockquote><p>注意：如果你的包确实依赖于外部包，可在<code>deno.land/x</code>中查看是否有Deno版本</p></blockquote><p>由于Deno标准库提供了<a class="link"   href="https://deno.land/std@0.140.0/node" >Node.js兼容模块<i class="fas fa-external-link-alt"></i></a>，这个改造比较简单。Deno的标准库上提供了一个包装器并尽可能和Node的api保持一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">import</span> * <span class="keyword">as</span> crypto <span class="keyword">from</span> <span class="string">&quot;crypto&quot;</span>;</span><br><span class="line">+ <span class="keyword">import</span> * <span class="keyword">as</span> crypto <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/crypto.ts&quot;</span>;</span><br></pre></td></tr></table></figure><p>为了简化问题，将所有Node.js api导入移到一个名为<code>adapter.node.ts</code>的文件中，并只重新导出我们需要的功能</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adapter.node.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">&quot;util&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> crypto <span class="keyword">from</span> <span class="string">&quot;crypto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;path, net, crypto&#125;;</span><br></pre></td></tr></table></figure><p>然后在一个名为<code>adapter.deno.ts</code>的文件中为Deno实现相同的适配器</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// adapter.deno.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> crypto <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/crypto.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/path.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> util <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/util.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;path, util, crypto&#125;;</span><br></pre></td></tr></table></figure><p>当需要使用Node.js的特定功能时，直接从<code>adapter.node.ts</code>导入这些功能。通过这种方式，可以通过简单地将所有<code>adapter.node.ts</code>导入重写为<code>adapter.deno.ts</code>即可使<code>edgedb-js</code>兼容Deno。只要确保这些文件重新导出相同的功能就能符合预期</p><p>但实际上应该如何重写这些导入呢。这里我们需要开发一个简单的codemod脚本。下面将使用Deno来开发这个脚本</p><h2 id="开发Deno-ifier"><a href="#开发Deno-ifier" class="headerlink" title="开发Deno-ifier"></a>开发Deno-ifier</h2><p>在开发之前，列举下需要做的事情：</p><ul><li><p>将Node.js风格的导入重写为更显式的Deno风格。包括添加<code>.ts</code>扩展名和目录导入添加<code>/index.ts</code></p></li><li><p>将<code>adapter.node.ts</code>的导入替换成从<code>adapter.deno.ts</code>的导入</p></li><li><p>注入Node.js全局变量（如<code>process</code>和<code>Buffer</code>）到Deno的代码中。虽然可以简单地从适配器导出这些变量，但我们必须重构Node.js文件以显式地导入它们。为了简化处理，将检测代码中使用了Node.js全局变量的时候注入一个导入</p></li><li><p>将<code>src</code>目录重命名为<code>_src</code>，表示它只被<code>edgedb-js</code>内部使用不应该被外部直接导入使用</p></li><li><p>将主入口文件<code>src/index.ts</code>移动到项目根目录并重命名为<code>mod.ts</code>。这是Deno中的习惯用法（这里<code>index.node.ts</code>的命名并不表明它是只能给Node.js使用而是用来区别于<code>index.browser.ts</code>，<code>index.browser.ts</code>导出的是<code>edgedb-js</code>中浏览器兼容的部分代码）</p></li></ul><h4 id="获取所有文件列表"><a href="#获取所有文件列表" class="headerlink" title="获取所有文件列表"></a>获取所有文件列表</h4><p>第一步先获取出源文件。Deno原生<code>fs</code>模块提供了<code>walk</code>函数可以实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;walk&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/fs/mod.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceDir = <span class="string">&quot;./src&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> <span class="title function_">walk</span>(sourceDir, &#123;<span class="attr">includeDirs</span>: <span class="literal">false</span>&#125;)) &#123;</span><br><span class="line">  <span class="comment">// 遍历源文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里使用的是Deno原生的<code>std/fs</code>模块而不是Node兼容版本的<code>std/node/fs</code></p></blockquote><p>声明一个重写规则集合并初始化一个<code>Map</code>对象表示源文件路径到需要重写的目标文件的路径</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceDir = <span class="string">&quot;./src&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> destDir = <span class="string">&quot;./edgedb-deno&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pathRewriteRules = [</span><br><span class="line">  &#123;<span class="attr">match</span>: <span class="regexp">/^src\/index.node.ts$/</span>, <span class="attr">replace</span>: <span class="string">&quot;mod.ts&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">match</span>: <span class="regexp">/^src\//</span>, <span class="attr">replace</span>: <span class="string">&quot;_src/&quot;</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceFilePathMap = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> <span class="title function_">walk</span>(sourceDir, &#123;<span class="attr">includeDirs</span>: <span class="literal">false</span>&#125;)) &#123;</span><br><span class="line">  <span class="keyword">const</span> sourcePath = entry.<span class="property">path</span>;</span><br><span class="line">  sourceFilePathMap.<span class="title function_">set</span>(sourcePath, <span class="title function_">resolveDestPath</span>(sourcePath));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolveDestPath</span>(<span class="params">sourcePath: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> destPath = sourcePath;</span><br><span class="line">  <span class="comment">// 使用重写规则</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> rule <span class="keyword">of</span> pathRewriteRules) &#123;</span><br><span class="line">    destPath = destPath.<span class="title function_">replace</span>(rule.<span class="property">match</span>, rule.<span class="property">replace</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">join</span>(destDir, destPath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这非常简单，下面开始开发修改源代码部分</p><h4 id="重写import和export"><a href="#重写import和export" class="headerlink" title="重写import和export"></a>重写import和export</h4><p>要重写导入路径需要知道它们在文件中的位置。我们将使用TypeScript的<a class="link"   href="https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API" >Compiler API<i class="fas fa-external-link-alt"></i></a>来将源文件解析为抽象语法树并找到导入语句</p><p>为了实现这个功能我们需要用到<code>typescript</code> NPM包的<code>compile API</code>。Deno的兼容模块提供了一个直接从CommonJS模块导入的方式。需要在执行Deno代码的时候使用<code>--unstable</code>标识，对于构建阶段这不是什么问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRequire&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/module.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> ts = <span class="built_in">require</span>(<span class="string">&quot;typescript&quot;</span>);</span><br></pre></td></tr></table></figure><p>下面遍历文件并依次解析</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;walk, ensureDir&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/fs/mod.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;createRequire&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/module.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> ts = <span class="built_in">require</span>(<span class="string">&quot;typescript&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [sourcePath, destPath] <span class="keyword">of</span> sourceFilePathMap) &#123;</span><br><span class="line">  <span class="title function_">compileFileForDeno</span>(sourcePath, destPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">compileFileForDeno</span>(<span class="params">sourcePath: <span class="built_in">string</span>, destPath: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> file = <span class="keyword">await</span> <span class="title class_">Deno</span>.<span class="title function_">readTextFile</span>(sourcePath);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">ensureDir</span>(<span class="title function_">dirname</span>(destPath));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果文件以&#x27;.deno.ts&#x27;结尾则直接复制无需修改</span></span><br><span class="line">  <span class="keyword">if</span> (destPath.<span class="title function_">endsWith</span>(<span class="string">&quot;.deno.ts&quot;</span>)) <span class="keyword">return</span> <span class="title class_">Deno</span>.<span class="title function_">writeTextFile</span>(destPath, file);</span><br><span class="line">  <span class="comment">// 如果文件以`.node.ts`结尾则跳过</span></span><br><span class="line">  <span class="keyword">if</span> (destPath.<span class="title function_">endsWith</span>(<span class="string">&quot;.node.ts&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用typescript Compiler API解析源文件</span></span><br><span class="line">  <span class="keyword">const</span> parsedSource = ts.<span class="title function_">createSourceFile</span>(</span><br><span class="line">    <span class="title function_">basename</span>(sourcePath),</span><br><span class="line">    file,</span><br><span class="line">    ts.<span class="property">ScriptTarget</span>.<span class="property">Latest</span>,</span><br><span class="line">    <span class="literal">false</span>,</span><br><span class="line">    ts.<span class="property">ScriptKind</span>.<span class="property">TS</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于每个AST，我们通过遍历顶层节点找出<code>import</code>和<code>export</code>语句。这里无需深层查找，因为<code>import/export</code>只会出现在顶级作用域（也无需处理动态<code>import()</code>，因为<code>edgedb-js</code>中也没有使用）</p><p>从这些节点中，获取源文件中<code>export/import</code>路径的开始和结束偏移量。然后可以通过切片取代路径内容并插入修改后的路径来重写导入</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parsedSource = ts.<span class="title function_">createSourceFile</span>(<span class="comment">/*...*/</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">rewrittenFile</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span>;</span><br><span class="line">parsedSource.<span class="title function_">forEachChild</span>(<span class="function">(<span class="params">node: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (node.<span class="property">kind</span> === ts.<span class="property">SyntaxKind</span>.<span class="property">ImportDeclaration</span> ||</span><br><span class="line">      node.<span class="property">kind</span> === ts.<span class="property">SyntaxKind</span>.<span class="property">ExportDeclaration</span>) &amp;&amp;</span><br><span class="line">    node.<span class="property">moduleSpecifier</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> pos = node.<span class="property">moduleSpecifier</span>.<span class="property">pos</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">const</span> end = node.<span class="property">moduleSpecifier</span>.<span class="property">end</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> importPath = file.<span class="title function_">slice</span>(pos, end);</span><br><span class="line"></span><br><span class="line">    rewrittenFile.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(cursor, pos));</span><br><span class="line">    cursor = end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Deno版本的导入替换导入适配文件</span></span><br><span class="line">    <span class="keyword">let</span> resolvedImportPath = <span class="title function_">resolveImportPath</span>(importPath, sourcePath);</span><br><span class="line">    <span class="keyword">if</span> (resolvedImportPath.<span class="title function_">endsWith</span>(<span class="string">&quot;/adapter.node.ts&quot;</span>)) &#123;</span><br><span class="line">      resolvedImportPath = resolvedImportPath.<span class="title function_">replace</span>(</span><br><span class="line">        <span class="string">&quot;/adapter.node.ts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/adapter.deno.ts&quot;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rewrittenFile.<span class="title function_">push</span>(resolvedImportPath);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rewrittenFile.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(cursor));</span><br></pre></td></tr></table></figure><p>这里的关键部分是<code>resolveImportPath</code>函数。它通过试错查找的方式实现将Node.js风格的引入转化为Deno风格的导入。首先检查路径是否对应于实际文件；如果失败了会尝试添加<code>.ts</code>；如果再失败则尝试添加<code>/index.ts</code>；如果再失败则抛出一个错误。</p><h4 id="注入Node-js全局变量"><a href="#注入Node-js全局变量" class="headerlink" title="注入Node.js全局变量"></a>注入Node.js全局变量</h4><p>最后一步是处理Node.js全局变量。首先在创建一个<code>global.deno.ts</code>文件。这个文件应该导出包中使用的所有Node.js全局变量的Deno兼容版本</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// global.deno.ts</span></span><br><span class="line"><span class="keyword">export</span> &#123;<span class="title class_">Buffer</span>&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/buffer.ts&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;process&#125; <span class="keyword">from</span> <span class="string">&quot;https://deno.land/std@0.114.0/node/process.ts&quot;</span>;</span><br></pre></td></tr></table></figure><p>通过编译后的AST可以拿到源文件中所有全局变量的集合。将使用它在任何引用这些全局变量的文件中注入import语句</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceDir = <span class="string">&quot;./src&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> destDir = <span class="string">&quot;./edgedb-deno&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> pathRewriteRules = [</span><br><span class="line">  &#123;<span class="attr">match</span>: <span class="regexp">/^src\/index.node.ts$/</span>, <span class="attr">replace</span>: <span class="string">&quot;mod.ts&quot;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">match</span>: <span class="regexp">/^src\//</span>, <span class="attr">replace</span>: <span class="string">&quot;_src/&quot;</span>&#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> injectImports = &#123;</span><br><span class="line">  <span class="attr">imports</span>: [<span class="string">&quot;Buffer&quot;</span>, <span class="string">&quot;process&quot;</span>],</span><br><span class="line">  <span class="attr">from</span>: <span class="string">&quot;src/globals.deno.ts&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">rewrittenFile</span>: <span class="built_in">string</span>[] = [];</span><br><span class="line"><span class="keyword">let</span> cursor = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> isFirstNode = <span class="literal">true</span>;</span><br><span class="line">parsedSource.<span class="title function_">forEachChild</span>(<span class="function">(<span class="params">node: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isFirstNode) &#123;  <span class="comment">// 每个文件只执行一次</span></span><br><span class="line">    isFirstNode = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> neededImports = injectImports.<span class="property">imports</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">importName</span>) =&gt;</span></span><br><span class="line">      parsedSource.<span class="property">identifiers</span>?.<span class="title function_">has</span>(importName)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (neededImports.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> imports = neededImports.<span class="title function_">join</span>(<span class="string">&quot;, &quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> importPath = <span class="title function_">resolveImportPath</span>(</span><br><span class="line">        <span class="title function_">relative</span>(<span class="title function_">dirname</span>(sourcePath), injectImports.<span class="property">from</span>),</span><br><span class="line">        sourcePath</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">const</span> importDecl = <span class="string">`import &#123;<span class="subst">$&#123;imports&#125;</span>&#125; from &quot;<span class="subst">$&#123;importPath&#125;</span>&quot;;\n\n`</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> injectPos = node.<span class="property">getLeadingTriviaWidth</span>?.(parsedSource) ?? node.<span class="property">pos</span>;</span><br><span class="line">      rewrittenFile.<span class="title function_">push</span>(file.<span class="title function_">slice</span>(cursor, injectPos));</span><br><span class="line">      rewrittenFile.<span class="title function_">push</span>(importDecl);</span><br><span class="line">      cursor = injectPos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>删除老文件的内容并依次写入每个文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Deno</span>.<span class="title function_">remove</span>(destDir, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sourceFilePathMap = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [sourcePath, destPath] <span class="keyword">of</span> sourceFilePathMap) &#123;</span><br><span class="line">  <span class="comment">// 重写文件</span></span><br><span class="line">  <span class="keyword">await</span> <span class="title class_">Deno</span>.<span class="title function_">writeTextFile</span>(destPath, rewrittenFile.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h4><p>一个常见的做法是为包的Deno版本维护一个单独的自动生成的仓库。在我们的例子中，每当一个新的提交合并到master时，将在GitHub Actions中生成<code>edgedb-js</code>的Deno版本。然后生成的文件被发布到<a href="https://github.com/edgedb/edgedb-deno"><code>edgedb-deno</code></a>仓库。下面是工作流的简化版本</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .github/workflows/deno-release.yml</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Deno</span> <span class="string">Release</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">edgedb-js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">edgedb-deno</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GITHUB_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">edgedb/edgedb-deno</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">edgedb-deno</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/setup-node@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">denoland/setup-deno@v1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">deps</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">version</span> <span class="string">from</span> <span class="string">package.json</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">package-version</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">martinbeentjes/npm-get-version-action@v1.1.0</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Write</span> <span class="string">version</span> <span class="string">to</span> <span class="string">file</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;$<span class="template-variable">&#123;&#123; steps.package-version.outputs.current-version&#125;&#125;</span>&quot;</span> <span class="string">&gt;</span> <span class="string">edgedb-deno/version.txt</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Compile</span> <span class="string">for</span> <span class="string">Deno</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">deno</span> <span class="string">run</span> <span class="string">--unstable</span> <span class="string">--allow-env</span> <span class="string">--allow-read</span> <span class="string">--allow-write</span> <span class="string">tools/compileForDeno.ts</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">to</span> <span class="string">edgedb-deno</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">cd</span> <span class="string">edgedb-deno</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">add</span> <span class="string">.</span> <span class="string">-f</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;Build from $GITHUB_SHA&quot;</span> <span class="string">&amp;&amp;</span> <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure><p><code>edgedb-deno</code>内部的另一个工作流则会创建一个GitHub release并发布到<code>deno.land/x</code>。可<a class="link"   href="https://github.com/edgedb/edgedb-deno/blob/main/.github/workflows/release.yml" >参考<i class="fas fa-external-link-alt"></i></a></p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>这就是将现存Node.js模块转换到Deno的通常方法。具体可参考<a href="https://github.com/edgedb/edgedb-js/blob/master/tools/compileForDeno.ts"><code>Deno编译脚本</code></a>和<a href="https://github.com/edgedb/edgedb-js/blob/master/.github/workflows/deno-release.yml"><code>workflow</code></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;br&gt;由于Node和Deno的一些差异，一个库要</summary>
      
    
    
    
    <category term="deno" scheme="https://blog.flytam.vip/categories/deno/"/>
    
    
    <category term="deno" scheme="https://blog.flytam.vip/tags/deno/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript不再需要写void 0了</title>
    <link href="https://blog.flytam.vip/JavaScript%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E5%86%99void%200%E4%BA%86.html"/>
    <id>https://blog.flytam.vip/JavaScript%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E5%86%99void%200%E4%BA%86.html</id>
    <published>2022-05-23T03:45:39.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"><br>我们经常会在一些代码中看到<code>void 0</code>的写法，这种写法其实现在已经不需要了</p><blockquote><p>本文翻译自：<a class="link"   href="https://p42.ai/blog/2022-05-10/you-dont-need-void-0" >https://p42.ai/blog/2022-05-10/you-dont-need-void-0<i class="fas fa-external-link-alt"></i></a></p></blockquote><p><a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void" >void操作符<i class="fas fa-external-link-alt"></i></a>执行一个表达式并返回原始值<a class="link"   href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined" >undefined<i class="fas fa-external-link-alt"></i></a>。<code>void 0</code>执行<code>0</code>，这什么都不会发生并且会返回<code>undefined</code>。是<code>undefined</code>的别名</p><h4 id="为什么void-0会用来当作undefined的别名？"><a href="#为什么void-0会用来当作undefined的别名？" class="headerlink" title="为什么void 0会用来当作undefined的别名？"></a>为什么<code>void 0</code>会用来当作<code>undefined</code>的别名？</h4><p><code>undefined</code>本身不是一个保留关键字而是一个<a class="link"   href="https://developer.mozilla.org/en-US/docs/Glossary/Global_object" >全局对象<i class="fas fa-external-link-alt"></i></a>的一个属性</p><p>在ES5（2009）之前，全局属性<code>undefined</code>的值是能被修改的，这会导致<code>undefined</code>一些不符合预期的行为</p><p>下面的例子（这在现在JavaScript引擎中已经不是这样了）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改全局对象中的undefined属性</span></span><br><span class="line"><span class="literal">undefined</span> = <span class="string">&quot;something else&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其它js文件或者script中</span></span><br><span class="line"><span class="keyword">if</span> (aVariable === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="title function_">doSomething</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改全局的<code>undefined</code>可能发生在第三方代码中，例如通过脚本标签导入的库。由于<code>void 0</code>总是返回<code>undefiend</code>的实际原始值，因此在ES5之前通常使用它来在防止全局<code>undefined</code>被修改的情况下仍能确保<code>undefined</code>判断的准确性</p><h4 id="ES5之后的全局属性undefined"><a href="#ES5之后的全局属性undefined" class="headerlink" title="ES5之后的全局属性undefined"></a>ES5之后的全局属性<code>undefined</code></h4><p><code>undefined</code>可以在全局对象上被修改的问题很大，以至于JavaScript标准在ES5中改变了。<strong>在ES5中，全局属性<code>undefined</code>变成了只读</strong>。尝试更改更改undefined的值在现代JavaScript中没有任何作用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">globalThis.<span class="property">undefined</span> = <span class="string">&quot;something else&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>); <span class="comment">// 在现代JS引擎中打印undefined</span></span><br></pre></td></tr></table></figure><h4 id="undefined仍然可以被局部变量覆盖"><a href="#undefined仍然可以被局部变量覆盖" class="headerlink" title="undefined仍然可以被局部变量覆盖"></a><code>undefined</code>仍然可以被局部变量覆盖</h4><p>虽然不再能更改全局属性<code>undefined</code>，但<code>undefined</code>仍然不是JavaScript中的保留关键字。因此它仍然可以被局部变量覆盖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="literal">undefined</span> = <span class="string">&quot;something else&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> check = aVariable === <span class="keyword">void</span> <span class="number">0</span>; <span class="comment">// 这里的void 0仍需要</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们应该避免使用<code>undefined</code>作为变量名。<a class="link"   href="https://eslint.org/docs/rules/no-undefined" >ESLint规则no-undefined<i class="fas fa-external-link-alt"></i></a> 不允许使用 undefined 作为变量名并防止出现覆盖问题</p><h4 id="void-0是否有助于减少打包体积？"><a href="#void-0是否有助于减少打包体积？" class="headerlink" title="void 0是否有助于减少打包体积？"></a><code>void 0</code>是否有助于减少打包体积？</h4><p>表达式<code>void 0</code>比<code>undefined</code>短。JavaScript包的大小对于创建快速加载的网站是至关重要的并且减少一些字节会有所帮助</p><p>但是最好将<strong>代码大小优化让<a class="link"   href="https://github.com/terser/terser" >Terser<i class="fas fa-external-link-alt"></i></a>之类的工具在打包过程中进行处理</strong>。这些工具可以执行许多不同的优化，并且源代码在没有任何手动的代码大小优化(如使用<code>void 0</code>而不是<code>undefined</code>)的情况下也更易于阅读</p><h4 id="在现代JavaScript中避免使用void-0"><a href="#在现代JavaScript中避免使用void-0" class="headerlink" title="在现代JavaScript中避免使用void 0"></a>在现代JavaScript中避免使用void 0</h4><p>总之，在现代浏览器和JavaScript引擎中没有理由再使用<code>void 0</code></p><ul><li>全局属性<code>undefined</code>不能在ES5以及后续的环境中更改</li><li>本地变量命名<code>undefined</code>可以通过<a class="link"   href="https://eslint.org/docs/rules/no-undefined" >ESLint规则no-undefined<i class="fas fa-external-link-alt"></i></a>进行禁止</li><li>生产环境打包时minifier工具可以将<code>undefined</code>替代成<code>void 0</code>实现体积优化</li></ul><p>相反，<code>void 0</code>使JavaScript代码更难阅读，因为需要知道<code>void 0</code>的含义并处理相同概念(<code>undefined</code>)的不同术语(<code>void 0</code>,<code>undefined</code>)</p><p>结论：使用<code>undefined</code>并移除不必要的<code>void 0</code></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;br&gt;我们经常会在一些代码中看到&lt;code&gt;vo</summary>
      
    
    
    
    <category term="原生" scheme="https://blog.flytam.vip/categories/%E5%8E%9F%E7%94%9F/"/>
    
    
    <category term="原生" scheme="https://blog.flytam.vip/tags/%E5%8E%9F%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>4个避免使用npm link的理由</title>
    <link href="https://blog.flytam.vip/4%E4%B8%AA%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8npm%20link%E7%9A%84%E7%90%86%E7%94%B1.html"/>
    <id>https://blog.flytam.vip/4%E4%B8%AA%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8npm%20link%E7%9A%84%E7%90%86%E7%94%B1.html</id>
    <published>2022-04-30T03:14:15.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><blockquote><p>本文主要介绍使用<code>npm link</code>的风险以及我们为什么使用<code>npx link</code>来替代它</p></blockquote><h2 id="先抛结论"><a href="#先抛结论" class="headerlink" title="先抛结论"></a>先抛结论</h2><p>使用<code>npm install</code>或者<code>npx link</code>去软连接一个本地包作为依赖而不是使用<code>npm link</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx <span class="built_in">link</span> &lt;package-path&gt;</span><br></pre></td></tr></table></figure><p><a class="link"   href="https://github.com/privatenumber/link"  title="npm link">npm link<i class="fas fa-external-link-alt"></i></a>是<a class="link"   href="https://github.com/privatenumber"  title="hiroki osame">hiroki osame<i class="fas fa-external-link-alt"></i></a>开发的一个更安全、更可预测的<code>npm link</code>的替代品</p><p>因为如下原因我们应该避免使用<code>npm link</code></p><ol><li><p>多个 Node.js 版本同时使用容易出错</p></li><li><p>link 失败不会报错并且会回退到直接从 npm 仓库进行安装</p></li><li><p>会有预期之外的二进制可执行文件安装</p></li><li><p>不符合预期的软链接删除</p></li></ol><h2 id="npm-link是什么"><a href="#npm-link是什么" class="headerlink" title="npm link是什么"></a><code>npm link</code>是什么</h2><p><code>npm link</code>是一个用于开发时直接将本地包<a class="link"   href="https://en.wikipedia.org/wiki/Symbolic_link"  title="链接">链接<i class="fas fa-external-link-alt"></i></a>为依赖项的一个命令行工具。通常用于发布 npm 包之前本地测试使用</p><p>更多信息可查看<a class="link"   href="https://docs.npmjs.com/cli/v8/commands/npm-link"  title="官方文档">官方文档<i class="fas fa-external-link-alt"></i></a></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>假设存在以下模块包</p><ul><li><code>my-library</code>: npm 包，需要在其它项目中作为依赖进行测试</li></ul><p>需要注意的是这里<code>my-library/package.json</code>中的<code>name</code>属性也是应该<code>my-library</code></p><ul><li><code>my-application</code>: <code>package/my-application</code>需要进行测试的项目</li></ul><p>下面演示如何将<code>my-application</code>中的<code>my-library</code>链接到本地</p><ul><li><strong>全局安装</strong></li></ul><p>在<code>my-application</code>中执行<code>npm link</code>将<code>my-library</code>安装到全局。这样才能让其它本地项目有办法链接到这个包。<code>npm link</code>的行为其实等同于<code>npm install --global</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./my-library</span><br><span class="line">$ npm <span class="built_in">link</span></span><br></pre></td></tr></table></figure><ul><li><strong>安装</strong></li></ul><p>在<code>my-application</code>中执行<code>npm link my-library</code>去链接这个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./my-application</span><br><span class="line">$ npm <span class="built_in">link</span> my-library</span><br></pre></td></tr></table></figure><h3 id="npm-link-lt-package-path-gt"><a href="#npm-link-lt-package-path-gt" class="headerlink" title="npm link &lt;package-path&gt;"></a><code>npm link &lt;package-path&gt;</code></h3><p>也可以直接执行<code>npm link &lt;package-path&gt;</code>命令实现上述两步</p><p>例子如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ./my-application</span><br><span class="line">$ npm <span class="built_in">link</span> ../my-library</span><br></pre></td></tr></table></figure><p>使用<code>npm link &lt;package-path&gt;</code>更加方便和不易出错，因为它是需要显式指定链接的包的路径</p><h2 id="4-个使用npm-link的缺点"><a href="#4-个使用npm-link的缺点" class="headerlink" title="4 个使用npm link的缺点"></a>4 个使用<code>npm link</code>的缺点</h2><ul><li><strong>多个 Node.js 版本同时使用容易出错</strong></li></ul><p>如果开发环境中使用类似<code>nvm</code>的版本管理工具安装多个 Node.js 版本的话，需要确保<code>npm link</code>的执行是在同一个 node 版本</p><p>像上文所说，第一步执行<code>npm link</code>其实是将包安装全局。但是因为多个版本的 Node.js 的全局安装路径是互相独立的。如果在不同版本中使用，包查找会失败</p><p>可以使用以下命令查看全局包的安装路径。如果 Node.js 的版本出现在打印的路径中，则全局包安装路径在不同 Node.js 版本下是独立的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm root -g</span><br><span class="line">~/.nvm/versions/node/v14.16.1/lib/node_modules</span><br></pre></td></tr></table></figure><p>在不同的终端中处理多个包的时候很容易忽略不同终端下的 Node.js 版本是否一致。并且这个版本差异也很难发现，因为<code>npm link</code>在无法找到要链接的本地包时也不会报错</p><ul><li><strong>link 失败不会报错并且会回退到直接从 npm 仓库进行安装</strong></li></ul><p>如果尝试在一个包中执行<code>npm link a</code> ，就算这个包之前并没有注册为全局链接，这个命令执行也不会报错</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">link</span> a</span><br><span class="line">~/my-package/node_modules/a -&gt; ~/.nvm/versions/node/v14.16.1/lib/node_modules/a</span><br></pre></td></tr></table></figure><p>这是因为<code>npm link</code>的时候没有找到全局的包<code>a</code>，它就会从<a href="(https://www.npmjs.com/package/a%20%22%60npm%60%22)"><code>npm</code></a>仓库上去全局安装这个包并创建一个软链接到这个包</p><p>只有这个包在 npm 远端仓库上没有这个包，<code>npm link</code>这个包才会失败</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">link</span> non-existent-package</span><br><span class="line">npm ERR! code E404</span><br><span class="line">npm ERR! 404 Not Found - GET https://registry.npmjs.org/non-existent-package - Not found</span><br><span class="line">npm ERR! 404</span><br><span class="line">npm ERR! 404  <span class="string">&#x27;non-existent-package@*&#x27;</span> is not <span class="keyword">in</span> this registry.</span><br><span class="line">npm ERR! 404 You should bug the author to publish it (or use the name yourself!)</span><br><span class="line">npm ERR! 404</span><br><span class="line">npm ERR! 404 Note that you can also install from a</span><br><span class="line">npm ERR! 404 tarball, folder, http url, or git url.</span><br></pre></td></tr></table></figure><p>要判断链接是否真正成功，可以检查输出是否有打印两个<code>-&gt;</code>，注意上面的错误链接只有一个<code>-&gt;</code>。两个<code>-&gt;</code>说明创建了一个指向全局包软链接，然后链接向本地包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm v6</span></span><br><span class="line">$ npm <span class="built_in">link</span> my-linked-package</span><br><span class="line">~/my-package/node_modules/my-linked-package -&gt; ~/.nvm/versions/node/v14.16.1/lib/node_modules/my-linked-package -&gt; ~/my-linked-package</span><br></pre></td></tr></table></figure><p>这种检查方法只能在 npm v6 版本中使用。从 npm v7 开始，链接路径不再被输出到终端了。从下面可以发现 v7 开始已经不可能确定是链接本地包成功还是、安装和链接了一个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># npm v7</span></span><br><span class="line">$ npm <span class="built_in">link</span> a</span><br><span class="line"></span><br><span class="line">up to <span class="built_in">date</span>, audited 3 packages <span class="keyword">in</span> 671ms</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br></pre></td></tr></table></figure><p>也可以使用<code>realpath</code>命令验证一个包是否链接成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">realpath</span> node_modules/package-name</span><br><span class="line">~/my-linked-package</span><br></pre></td></tr></table></figure><p>综上，由于缺少适当的报错，使用<code>npm link</code>带给我们不是很好的体验。特别是在多个 Node.js 版本的情况下</p><ul><li><strong>会有预期之外的二进制可执行文件安装</strong></li></ul><p><code>npm link</code>的第一步是将包安装到全局。这个命令是由两步实现</p><p><a class="link"   href="https://docs.npmjs.com/cli/v8/commands/npm-install#global"  title="npm install --global ...">npm install –global …<i class="fas fa-external-link-alt"></i></a>可用于使二进制文件作为系统范围的 cli 命令使用。如果包有<a href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#bin" title="`bin`"><code>bin</code></a> 字段，通过<code>npm link</code>可以另这个<code>bin</code>中的命令可以直接通过终端执行命令</p><p>考虑到<code>npm link</code>通常只是用来在开发中进行包的测试，全局二进制文件的安装可能会有额外的副作用。由于包可以声明具有<a class="link"   href="https://docs.npmjs.com/cli/v7/configuring-npm/package-json#:~:text=%22bin%22%3A%20%7B-,%22my%2Dprogram%22,-%3A%20%22./path/to/program"  title="任意名称">任意名称<i class="fas fa-external-link-alt"></i></a>的二进制执行文件，这种意外的副作用的影响可能非常严重</p><p>下面的例子，在<code>package.json</code>中指定了<code>bin</code>的<code>random-command</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-package&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;random-command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bin.js&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>执行<code>npm link</code>就也会全局安装可执行的<code>random-command</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ random-command</span><br><span class="line">zsh: <span class="built_in">command</span> not found: random-command</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> my-package &amp;&amp; npm <span class="built_in">link</span></span><br><span class="line">added 1 package, and audited 3 packages <span class="keyword">in</span> 548ms</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">$ random-command</span><br><span class="line">Suddenly works!</span><br></pre></td></tr></table></figure><p>全局安装也会覆盖已经存在的的全局可执行命令（取决于<a href="https://linuxhint.com/path_in_bash/" title="`PATH`配置"><code>PATH</code>配置</a>–终端查找命令的环境变量）。如果使用<a class="link"   href="http://nvm.sh/"  title="nvm">nvm<i class="fas fa-external-link-alt"></i></a>则可能会受到影响</p><p>下面的例子，覆盖了<a class="link"   href="https://en.wikipedia.org/wiki/Cat_(Unix%20%22%E6%A0%87%E5%87%86%E7%9A%84%20Unix%20%E5%91%BD%E4%BB%A4%22)" >标准的 Unix 命令<i class="fas fa-external-link-alt"></i></a><code>cat</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">type</span> <span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> is /bin/cat</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> my-package &amp;&amp; npm <span class="built_in">link</span></span><br><span class="line">added 1 package, and audited 3 packages <span class="keyword">in</span> 230ms</span><br><span class="line"></span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">hash</span> cash</span><br><span class="line">$ <span class="built_in">type</span> <span class="built_in">cat</span></span><br><span class="line"><span class="built_in">cat</span> is ~/.nvm/versions/node/v16.14.0/bin/cat</span><br></pre></td></tr></table></figure><p>在包安装方面，这些风险对于包管理很普遍，从安全角度来看，这些风险并不算太高</p><p>但<code>npm link</code>本身不是一个包安装工具。它是一个开发时进行软链接的工具。通过上文，我们了解到这种行为是会导致不少预期外的行为以及可能导致的一些错误</p><p>顺便提下上面提到的运行<code>npm link a</code>，则二进制执行命令<code>a</code>已安装到系统中。可能会认为 <code>npm unlink a</code>可以卸载，但它只会删除本地的软链接，而不会删除全局安装的二进制文件</p><p>卸载全局包和它的二进制执行文件需要使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm uninstall --global a</span><br></pre></td></tr></table></figure><ul><li><strong>不符合预期的软链接删除</strong></li></ul><p>链接多个包时，将删除先前链接的包。这个行为是 npm v7 中引入的</p><p>以下例子<code>pkg-a</code>已经被链接过并且存在于<code>node_modules</code>中了。但当链接了第二个包<code>pkg-b</code>后，<code>pkg-a</code>就不在<code>node_modules</code>中了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">link</span> ../pkg-a</span><br><span class="line">added 1 package, and audited 5 packages <span class="keyword">in</span> 684ms</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> node_modules</span><br><span class="line">pkg-a</span><br><span class="line"></span><br><span class="line">$ npm <span class="built_in">link</span> ../pkg-b</span><br><span class="line">added 1 package, removed 1 package, and audited 5 packages <span class="keyword">in</span> 703ms</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> node_modules</span><br><span class="line">pkg-b</span><br></pre></td></tr></table></figure><p>使用多个包进行链接时，<code>npn link</code>删除之前的链接包通常是不符合预期的。一般在链接第二个包之后，我们会继续运行代码并认为之前的软链接是应该不变的</p><p>如果要链接多个包就必须将所有包路径一次传递给<code>npm link</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="built_in">link</span> ../pkg-a ../pkg-b</span><br><span class="line">added 1 package, and audited 6 packages <span class="keyword">in</span> 645ms</span><br><span class="line">found 0 vulnerabilities</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">ls</span> node_modules</span><br><span class="line">pkg-a pkg-b</span><br></pre></td></tr></table></figure><p>虽然可行但这并不是一个很好的开发体验。在开发中，我们并不总是提前知道所有需要链接的包或以前链接过的包</p><p>这种令人困惑的行为说明了<code>npm link</code>的可用性很差</p><h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><p>作为一个流行的包管理工具，npm 有一个各种各样的包但却没有统一的质量标准</p><p><a class="link"   href="https://docs.npmjs.com/reporting-malware-in-an-npm-package"  title="这里">这里<i class="fas fa-external-link-alt"></i></a>列举了一些恶意包，但这里提到的风险不仅限于攻击。当不清楚是否安装了正确的软件包时是有可能发生意外的</p><p>npm 上的许多包是用来更改文件的，例如<a class="link"   href="https://www.npmjs.com/package/rimraf"  title="rimraf">rimraf<i class="fas fa-external-link-alt"></i></a>或代码 linter 工具。运行文件中被更改的代码可能是有可能有问题的</p><p><code>npm install</code>也有可能安装错误的包，但是了解到上面提到的<code>npm link</code>会有一些预料之外的行为时，<code>npm link</code>带来的风险会更高。如下：</p><ul><li><p><strong>包名称可能会发生冲突</strong>。可能使用了一个 npm 仓库上已有的包名字去链接本地的包。在意识到名称已被占用之前，开发和测试新的或私有包可能会遇到</p></li><li><p><strong>本地链接失败不会报错</strong>。如果被链接的包无法在本地找到，将从 npm 仓库下中查找。如果找到相同名称的包，则可能会意外地安装到全局</p></li><li><p><strong>二进制可执行文件被安装</strong>。如果安装了错误的包，很难发现二进制执行文件也会被全局安装并且很难意识到需要全局卸载这个二进制执行文件。这就会留下这个不符合预期的可执行文件被可能被意外执行</p></li></ul><h2 id="使用npm-install作为替代"><a href="#使用npm-install作为替代" class="headerlink" title="使用npm install作为替代"></a>使用<code>npm install</code>作为替代</h2><p><code>npm link</code>的一种替代方法是使用指定包路径的<code>npm install</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --no-save &lt;package-path-a&gt; &lt;package-path-b&gt; ...</span><br></pre></td></tr></table></figure><p>执行这个命令会创建一个指向包的软链接而不是全局安装。这种行为就和我们使用<code>npm link</code>进行测试包的初衷差不多了。 加上<code>--no-save</code>是为了防止包的路径保存在<code>package.json</code>中</p><p>但是<code>npm install</code>也是有缺点的。和<code>npm link</code>一样，执行<code>npm install</code>多次是会先移除之前的软链接。如果我们想一次链接多个包的话，必须一次将需要链接的多个包作为参数传入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --no-save &lt;package-path-a&gt; &lt;package-path-b&gt; ...</span><br></pre></td></tr></table></figure><h2 id="npx-link"><a href="#npx-link" class="headerlink" title="npx link"></a><code>npx link</code></h2><p><a href="https://github.com/privatenumber/link" title="`npx link`"><code>npx link</code></a>，一个小工具用来替代<code>npm link</code>，并且能解决上面提到的<code>npm link</code>的缺点</p><p>使用起来也很简单</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx <span class="built_in">link</span> &lt;package-path&gt;</span><br></pre></td></tr></table></figure><p><code>[npm link](https://github.com/privatenumber/link &quot;npm link&quot;)</code>不会全局安装链接的包或二进制执行文件，并且也不会删除以前的软链接，可以在不同版本的 Node.js 中使用。当不能解析包路径时，也会有一个执行失败报错</p><p>如果需要执行链接包的二进制文件，执行通过<a href="https://docs.npmjs.com/cli/v8/commands/npx" title="`npx`"><code>npx</code></a>命令或者通过<a class="link"   href="https://docs.npmjs.com/cli/v8/using-npm/scripts"  title="package scripts">package scripts<i class="fas fa-external-link-alt"></i></a></p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要</summary>
      
    
    
    
    <category term="node" scheme="https://blog.flytam.vip/categories/node/"/>
    
    
    <category term="node" scheme="https://blog.flytam.vip/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>使用TypeScript并升级到React 18</title>
    <link href="https://blog.flytam.vip/%E4%BD%BF%E7%94%A8TypeScript%E5%B9%B6%E5%8D%87%E7%BA%A7%E5%88%B0React%2018.html"/>
    <id>https://blog.flytam.vip/%E4%BD%BF%E7%94%A8TypeScript%E5%B9%B6%E5%8D%87%E7%BA%A7%E5%88%B0React%2018.html</id>
    <published>2022-04-23T07:18:45.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><p>为了支持React 18，React类型定义进行了升级，其中包含了一些break change。本文将讲述在TypeScript中如何升级到React 18</p><h4 id="React-18和Definitely-Typed"><a href="#React-18和Definitely-Typed" class="headerlink" title="React 18和Definitely Typed"></a>React 18和Definitely Typed</h4><p>在alpha和beta测试经历了相当长的一段时间后，React 18 于2022年3月29日正式发布。在第一个alpha版本发布的时候，TypeScript就提供了<a class="link"   href="https://blog.logrocket.com/how-to-use-typescript-with-react-18-alpha/" >支持<i class="fas fa-external-link-alt"></i></a></p><p>这是通过<a class="link"   href="https://github.com/DefinitelyTyped/DefinitelyTyped" >Definitely Typed<i class="fas fa-external-link-alt"></i></a>(一个社区维护的各种TypeScript类型定义的库)的类型定义实现的)来使用。感谢<a class="link"   href="https://twitter.com/sebsilbermann" >Sebastian Silbermann<i class="fas fa-external-link-alt"></i></a>的贡献，他在React18的类型定义工作中投入了大量的精力</p><p>目前React 18已经发布并且React 18 的类型定义在 Sebastian 的pr合并后也进行了<a class="link"   href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210" >更新<i class="fas fa-external-link-alt"></i></a>。许多项目会面临一些break change。本文章将介绍会产生哪些break change及如何解决</p><h4 id="Definitely-Typed和语义版本控制"><a href="#Definitely-Typed和语义版本控制" class="headerlink" title="Definitely Typed和语义版本控制"></a>Definitely Typed和<a class="link"   href="http://semver.org/" >语义版本控制<i class="fas fa-external-link-alt"></i></a></h4><p>开发者习惯于在使用的软件中进行语义版本控制。通常来说在主版本的修改是表明有重大更改的。这正是React从v17升级到v18所做的事</p><p><code>Definitely Typed</code>是不支持语义版本控制的</p><p>这不是故意的。因为<code>Definitely Typed</code>特意将类型定义发布到npm的<code>@types</code>作用域下。例如，React的类型定义被发布到<code>@types/react</code></p><p>需要注意的是，npm 建立在语义版本控制之上。为了使类型定义的使用更容易，类型定义包的版本将等同于它支持的 npm 包的版本。对于 <code>react</code>的<code>18.0.0</code>，对应的类型定义是<code>@types/react</code>的<code>18.0.0</code></p><p>如果<code>@types/react</code>类型定义发生breaking change，则会发布新版本而不是增加主要或次要版本号</p><p>修改将仅应用于修订号。这样做是为了通过npm维护当前更简单的类型消费模型</p><h4 id="React-18-类型上的breaking-change"><a href="#React-18-类型上的breaking-change" class="headerlink" title="React 18: 类型上的breaking change"></a>React 18: 类型上的breaking change</h4><p>综上所述，对于那些被广泛使用的类型定义包，都会尽量减少产生breaking change</p><p>顺便说一句，<code>Definitely Typed</code>自动化工具将类型定义分为<a class="link"   href="https://github.com/DefinitelyTyped/dt-mergebot/blob/5485345b210a4baf8e63376a930554bf2b7dd311/src/basic.ts#L11-L14" >三类<i class="fas fa-external-link-alt"></i></a>: “深受大家喜爱(Well-liked by everyone)”、”流行(Popular)”和”关键(Critical)”。感谢<a class="link"   href="https://twitter.com/atcb/status/1438559981838626817" >Andrew Branch<i class="fas fa-external-link-alt"></i></a>的分享。被广泛使用的React被认为是”关键的”</p><p>当Sebastian提交了一个<a class="link"   href="https://github.com/DefinitelyTyped/DefinitelyTyped/pull/56210" >pr<i class="fas fa-external-link-alt"></i></a>来升级TypeScript的React类型定义时，就有机会来做一些重大的修改。这些修改可能并不都与React 18有直接关系但会修复React类型定义中长期存在的一些问题</p><p>Sebastian pr非常好，我建议你去看一下。以下是重大更改的摘要</p><ul><li>移除隐式children</li><li>移除<code>ReactFragment</code>中的<code>&#123;&#125;</code>(related to 1.)</li><li><code>this.context</code>变成<code>unkown</code></li><li>Using noImplicitAny now enforces a type is supplied with useCallback</li><li><code>noImplicitAny</code>应用到<code>useCallback</code></li><li>删除不推荐使用的类型与React官方保持一致</li></ul><p>在上述修改中，移除隐式children是最具破坏性的。Sebastian专门写了一篇<a class="link"   href="https://solverfox.dev/writing/no-implicit-children" >博客<i class="fas fa-external-link-alt"></i></a>来解释其原因。他还写了一个<a class="link"   href="https://github.com/eps1lon/types-react-codemod" >codemod<i class="fas fa-external-link-alt"></i></a>来有利于进行这个代码迁移</p><p>下面让我们开始将代码库的react升级到18吧！</p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>我将通过升级我阿姨的网站进行演示。这是一个简单的网站，升级的<a class="link"   href="https://github.com/johnnyreilly/poor-clares-arundel-koa/pull/69" >pr<i class="fas fa-external-link-alt"></i></a></p><p>首先在<code>package.json</code>中升级React</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-    &quot;react&quot;: &quot;^17.0.0&quot;,</span><br><span class="line">-    &quot;react-dom&quot;: &quot;^17.0.0&quot;,</span><br><span class="line">+    &quot;react&quot;: &quot;^18.0.0&quot;,</span><br><span class="line">+    &quot;react-dom&quot;: &quot;^18.0.0&quot;,</span><br></pre></td></tr></table></figure><p>然后升级类型定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-    &quot;@types/react&quot;: &quot;^17.0.0&quot;,</span><br><span class="line">-    &quot;@types/react-dom&quot;: &quot;^17.0.0&quot;,</span><br><span class="line">+    &quot;@types/react&quot;: &quot;^18.0.0&quot;,</span><br><span class="line">+    &quot;@types/react-dom&quot;: &quot;^18.0.0&quot;,</span><br></pre></td></tr></table></figure><p>升级的时候需要检查lock依赖（yarn.lock / package-lock.json等），确保只有18版本的<code>@types/react</code>和<code>react</code>。</p><p>现在依赖安装已完成，会看到以下报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Property</span> ‘children’ does not exist on <span class="keyword">type</span> ‘<span class="title class_">LoadingProps</span>’.<span class="title function_">ts</span>(<span class="number">2339</span>)</span><br></pre></td></tr></table></figure><p>代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LoadingProps</span> &#123;</span><br><span class="line">  <span class="comment">// 你会注意到这里没有 `children` 属性 - 这就是出现错误的原因</span></span><br><span class="line">  noHeader?: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if props.noHeader is true then this component returns just the icon and a message</span></span><br><span class="line"><span class="comment">// if props.noHeader is true then this component returns the same but wrapped in an h1</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Loading</span>: <span class="title class_">React</span>.<span class="property">FunctionComponent</span>&lt;<span class="title class_">LoadingProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span></span><br><span class="line">  props.<span class="property">noHeader</span> ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">FontAwesomeIcon</span> <span class="attr">icon</span>=<span class="string">&#123;faSnowflake&#125;</span> <span class="attr">spin</span> /&gt;</span> Loading &#123;props.children&#125; ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;loader&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">FontAwesomeIcon</span> <span class="attr">icon</span>=<span class="string">&#123;faSnowflake&#125;</span> <span class="attr">spin</span> /&gt;</span> Loading &#123;props.children&#125; ...</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p><img src="https://files.mdnice.com/user/8265/33d20588-f557-414e-8c5c-1c53f71fda60.png"></p><p>在这里看到的是去除隐式<code>children</code>的改动。在我们进行升级之前，所有<code>React.Component</code>和<code>React.FunctionComponent</code>都有一个<code>children</code>属性，它允许<code>React</code>用户在不声明<code>children</code>的情况下直接使用</p><p>升级18后就不一样了。如果有一个带有子组件，则必须显式声明这个组件的类型</p><p>在这个例子中，通过直接添加<code>children</code>属性的声明可以修复这个问题</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">LoadingProps</span> &#123;</span><br><span class="line">  noHeader?: <span class="built_in">boolean</span>;</span><br><span class="line">  <span class="attr">children</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，当可以让其他方式帮我们写代码的话，为什么还要写代码呢？</p><p>我们可以使用Sebastian开发的<a class="link"   href="https://github.com/eps1lon/types-react-codemod" >codemod<i class="fas fa-external-link-alt"></i></a>来替代手动修改代码。使用它直接通过以下的命令就可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx types-react-codemod preset-18 ./src</span><br></pre></td></tr></table></figure><p>执行后，会看到如下提示：</p><p><img src="https://files.mdnice.com/user/8265/c290be45-a249-45bd-905d-db769a851c1a.png"></p><p>选择<code>a</code>并让codemod运行。对于这个项目，有37个文件更新了。所有文件都需要进行相同的修改。在每种情况下，组件的<code>props</code>都被<code>React.PropsWithChildren</code>包起来。例如<code>Loading</code>组件如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="keyword">const</span> <span class="title class_">Loading</span>: <span class="title class_">React</span>.<span class="property">FunctionComponent</span>&lt;<span class="title class_">LoadingProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span></span><br><span class="line">+<span class="keyword">const</span> <span class="title class_">Loading</span>: <span class="title class_">React</span>.<span class="property">FunctionComponent</span>&lt;<span class="title class_">React</span>.<span class="property">PropsWithChildren</span>&lt;<span class="title class_">LoadingProps</span>&gt;&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span></span><br></pre></td></tr></table></figure><p><code>PropsWithChildren</code>仅仅是将<code>children</code>属性添加，如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">PropsWithChildren</span>&lt;P&gt; = P &amp; &#123; children?: <span class="title class_">ReactNode</span> | <span class="literal">undefined</span> &#125;;</span><br></pre></td></tr></table></figure><p>这就解决了上面遇到的编译问题，没有类型问题报错了</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过本文我们已经学习到React 18是如何出现类型的破坏性更改，并知道可以使用codemod快速进行升级</p><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了支持React 18，Reac</summary>
      
    
    
    
    <category term="react" scheme="https://blog.flytam.vip/categories/react/"/>
    
    
    <category term="react" scheme="https://blog.flytam.vip/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>React中的浅比较是如何工作的</title>
    <link href="https://blog.flytam.vip/React%E4%B8%AD%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html"/>
    <id>https://blog.flytam.vip/React%E4%B8%AD%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84.html</id>
    <published>2022-04-15T14:18:21.000Z</published>
    <updated>2024-10-02T12:53:43.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p><p>浅比较这个概念在React开发过程中很常见。它在不同的过程中扮演着关键的角色，也可以在React组件生命周期的几个地方找到。判断class组件是否应该更新、React hood的依赖数组、通<code>React.memo</code> 缓存处理等例子</p><p>如果曾经阅读过官方的React文档，我们可能会经常到看到浅比较这个概念。但通常只是一个比较简单的解释。所以，本文将研究浅比较的概念，它到底是什么、如何工作，并会得到一些我们可能不知道的结论</p><h4 id="深入浅比较的实现"><a href="#深入浅比较的实现" class="headerlink" title="深入浅比较的实现"></a>深入浅比较的实现</h4><p>最直接了解浅比较的方式就是去深入它的实现。相应的代码可以在<a class="link"   href="https://github.com/facebook/react" >React Github项目<i class="fas fa-external-link-alt"></i></a>的<code>shared</code>包中的<code>shallowEqual.js</code>找到。代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> is <span class="keyword">from</span> <span class="string">&#x27;./objectIs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> hasOwnProperty <span class="keyword">from</span> <span class="string">&#x27;./hasOwnProperty&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">is</span>(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test for A&#x27;s keys different from B.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> currentKey = keysA[i];</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.<span class="title function_">call</span>(objB, currentKey) ||</span><br><span class="line">      !<span class="title function_">is</span>(objA[currentKey], objB[currentKey])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数做了不少事情，我们一步一步看这个函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line">函数接收两个入参作为被比较的对象。这个代码使用了<span class="string">`Flow`</span>作为类型检测系统而不是使用<span class="string">`TypeScript`</span>。两个函数的参数都使用了<span class="string">`Flow`</span>中的<span class="string">`mixed`</span>类型（类似<span class="string">`TypeScript`</span>中的<span class="string">`unknnown`</span>）。这表明它们可以是任意类型。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`typescript</span></span><br><span class="line"><span class="string">import is from &#x27;./objectIs&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function shallowEqual(objA: mixed, objB: mixed): boolean &#123;</span></span><br><span class="line"><span class="string">  if (is(objA, objB)) &#123;</span></span><br><span class="line"><span class="string">    return true;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">    // ...</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>首先使用React的内部实现的<code>is</code>方法对两个函数参数进行比较。这个引入的<code>is</code>内部方法和js中的<code>Object.js</code>几乎没有区别。这个比较函数和常用的<code>===</code>基本相同，除了两个例外</p><ul><li><code>Object.is</code>将<code>+0</code>和<code>-0</code>当作不相等，而<code>===</code>把他们当作相等</li><li><code>Object.is</code>把 <code>Number.NaN</code>和<code>Number.NaN</code>当作相等，而<code>===</code>把他们当作不相等</li></ul><p>基本上第一个条件分支能处理如下简单的情况：如果两个参数有相同的值，如原始值相等、或对象的引用相等，它们会被认为相等</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理了简单情况下的值相等或者对象引用相等后我们需要去比较更复杂的结构。如果其中一个参数是原始值，前面的比较仍然会漏掉这种情况</p><p>为了确保我们下面是比较两个复杂的数据结构，我们还需要检查是否其中一个参数不是对象或者是null。前一个检查确保我们处理的两个参数是对象或数组，而后一个检查是过滤掉<code>null</code>，因为的<code>typeof null === &#39;object&#39;</code>。如果两个条件都成立那么处理的两个参数肯定是不相等的(否则前面的判断就会将它们过滤)，所以浅比较返回false。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objB);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在可以确定我们只处理数组和对象。因此可以把重点放在复杂数据结构的比较上</p><p>首先，我们可以简单比较它们的键的数量是否相等。如果不是，他们就不会浅比较相等，这可以提高检查的效率。我们使用<code>Object.keys</code>获取它们的键的数量。对于对象，键数组由实际的键组成；而对于数组，键数组将由数组的索引组成。</p><pre><code class="typescript">import hasOwnProperty from &#39;./hasOwnProperty&#39;;function shallowEqual(objA: mixed, objB: mixed): boolean &#123;    // ...  // Test for A&#39;s keys different from B.  for (let i = 0; i &lt; keysA.length; i++) &#123;    const currentKey = keysA[i];    if (      !hasOwnProperty.call(objB, currentKey) ||      !is(objA[currentKey], objB[currentKey])    ) &#123;      return false;    &#125;  &#125;  return true;&#125;</code></pre><p>最后，我们遍历两个函数参数的值并逐个比较它们是否相等。使用上一步中生成的键数组，并使用<code>hasOwnProperty</code>检查键是否实际上是对象自身的属性，使用<code>Object.is</code>函数进行值比较</p><p>如果存在对象上的某个值不相等，那么通过浅比较就可以认为它们不相等。因此可以提前结束循环，并直接<code>shallow wEqual</code>函数返回false。如果所有的值都是相等那么我们可以通过浅比较函数判断两个参数相等，函数返回true</p><h4 id="有趣的东西"><a href="#有趣的东西" class="headerlink" title="有趣的东西"></a>有趣的东西</h4><p>我们已经了解了简单的比较和它背后的实现，也可以从中知道到一些有趣的东西:</p><ul><li><p>浅比较并不是使用全等<code>===</code>，而是使用<code>Object.is</code></p></li><li><p>浅比较中，空对象和空数组会被认为相等</p></li><li><p>浅比较中，一个以索引值作为键的对象和一个在相应各下标处具有相同值的数组相等。如<code>&#123;0:2,1:3&#125;</code>等于<code>[2,3]</code></p></li><li><p>由于使用<code>Object.is</code>而不是使用<code>===</code>。<code>+0</code>和<code>-0</code>在浅比较中是不相等的。并且<code>NaN</code>和<code>NaN</code>也认为不相等。这也适用于复杂结构内部的比较</p></li><li><p>虽然两个直接创建的对象(或数组)通过浅比较是相等的(<code>&#123;&#125;</code>和<code>[]</code>)，但嵌套的数组、对象是不相等的。如<code>&#123;someKey:&#123;&#125;</code>和<code>&#123;someKey:[]&#125;</code>浅比较是不相等的)</p></li></ul><p><img src="https://files.mdnice.com/user/8265/9ce83ec3-ddde-4d7f-b2af-86503a93f507.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;&lt;img src=&quot;https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;浅比较这个概念在React开发过程</summary>
      
    
    
    
    <category term="react" scheme="https://blog.flytam.vip/categories/react/"/>
    
    
    <category term="react" scheme="https://blog.flytam.vip/tags/react/"/>
    
  </entry>
  
</feed>
