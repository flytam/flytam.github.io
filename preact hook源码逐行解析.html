<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    <meta charset="utf-8">
    <meta name="baidu-site-verification" content="code-dIcFuFl2mE" >
    <meta name="google-site-verification" content="wape3ytOwC3RowSpyEC2hv0xY_nFeiO84AUG5pB1j_c">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="referrer" content="no-referrer" />
    <meta name="keywords" content="fe,web,node.js,react.js,frontend">
    <meta name="description" content="一个关于web开发知识的博客/A blog about web development">
    <meta name="author" content="flytam">
    
    <title>
        
            preact hook源码逐行解析 |
        
        Geek技术前线
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/fe.svg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"blog.flytam.vip","root":"/","language":"zh-Hans","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#888888","avatar":"https://avatars.githubusercontent.com/u/20512530?v=4","favicon":"images/fe.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":"scale","first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":true,"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="flytam's blog" type="application/atom+xml">
</head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Geek技术前线
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               target="_blank" rel="noopener" href="https://github.com/flytam"
                            >
                                GITHUB
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       target="_blank" rel="noopener" href="https://github.com/flytam">GITHUB</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">preact hook源码逐行解析</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="https://avatars.githubusercontent.com/u/20512530?v=4">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">flytam</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2019-11-11 13:39:34</span>
        <span class="mobile">2019-11-11 13:39</span>
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/react/">react</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/react/">react</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <span id="more"></span>

<p><img src="https://files.mdnice.com/user/8265/6f96e402-5262-4969-b58a-699a0ac57f95.png"></p>
<blockquote>
<p>本文通过对<code>preact</code>的<code>hook</code>源码分析，理解和掌握<code>react/preact</code>的<code>hook</code>用法以及一些常见的问题。虽然<code>react</code>和<code>preact</code>的实现上有一定的差异，但是对于<code>hook</code>的表现来说，是基本一致的。对于 preact<code>的</code>hook`分析，我们很容易旧记住 hook 的使用和防止踩一些误区</p>
</blockquote>
<p>preact hook 作为一个单独的包<code>preact/hook</code>引入的，它的总代码包含注释区区 300 行。</p>
<p>在阅读本文之前，先带着几个问题阅读：</p>
<p>1、函数组件是无状态的，那么为什么 hook 让它变成了有状态呢？</p>
<p>2、为什么 hook 不能放在 条件语句里面</p>
<p>3、为什么不能在普通函数执行 hook</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>前面提到，<code>hook</code>在<code>preact</code>中是通过<code>preact/hook</code>内一个模块单独引入的。这个模块中有两个重要的模块内的全局变量：1、<code>currentIndex</code>：用于记录当前函数组件正在使用的 hook 的顺序（下面会提到）。2、<code>currentComponent</code>。用于记录当前渲染对应的组件。</p>
<p><code>preact hook</code> 的实现对于原有的 <code>preact</code> 是几乎零入侵。它通过暴露在<code>preact.options</code>中的几个钩子函数在<code>preact</code>的相应初始/更新时候执行相应的<code>hook</code>逻辑。这几个钩子分别是<code>_render</code>=&gt; <code>组件的render方法</code>=&gt;<code>diffed</code>=&gt;<code>_commit</code>=&gt;<code>umount</code></p>
<ul>
<li><code>\_render</code><a class="link"   target="_blank" rel="noopener" href="https://github.com/preactjs/preact/blob/master/src/diff/index.js#L159" >位置<i class="fas fa-external-link-alt"></i></a>。执行组件的 render 方法之前执行，用于执行<code>_pendingEffects</code>（<code>_pendingEffects</code>是不阻塞页面渲染的 effect 操作，在下一帧绘制前执行）的清理操作和执行未执行的。这个钩子还有一个很重要的作用就是让 hook 拿到当前正在执行的<code>render</code>的组件实例<br><a class="link"   target="_blank" rel="noopener" href="https://preactjs.com/guide/v10/options" >options<i class="fas fa-external-link-alt"></i></a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options.<span class="property">_render</span> = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// render 钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (oldBeforeRender) <span class="title function_">oldBeforeRender</span>(vnode);</span><br><span class="line"></span><br><span class="line">  currentComponent = vnode.<span class="property">_component</span>;</span><br><span class="line">  currentIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (currentComponent.<span class="property">__hooks</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行清理操作</span></span><br><span class="line">    currentComponent.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span>.<span class="title function_">forEach</span>(invokeCleanup);</span><br><span class="line">    <span class="comment">// 执行effect</span></span><br><span class="line">    currentComponent.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span>.<span class="title function_">forEach</span>(invokeEffect);</span><br><span class="line">    currentComponent.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合<code>_render</code>在 preact 的执行时机，可以知道，在这个钩子函数里是进行每次 render 的初始化操作。包括执行/清理上次未处理完的 effect、初始化 hook 下标为 0、取得当前 render 的组件实例。</p>
<ul>
<li><code>diffed</code><a class="link"   target="_blank" rel="noopener" href="https://github.com/preactjs/preact/blob/master/src/diff/index.js#L216" >位置<i class="fas fa-external-link-alt"></i></a>。 vnode 的 diff 完成之后，将当前的<code>_pendingEffects</code>推进执行队列，让它在下一帧绘制前执行，不阻塞本次的浏览器渲染。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">options.<span class="property">diffed</span> = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldAfterDiff) <span class="title function_">oldAfterDiff</span>(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> c = vnode.<span class="property">_component</span>;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = c.<span class="property">__hooks</span>;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    <span class="comment">// 下面会提到useEffect就是进入_pendingEffects队列</span></span><br><span class="line">    <span class="keyword">if</span> (hooks.<span class="property">_pendingEffects</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// afterPaint 表示本次帧绘制完，下一帧开始前执行</span></span><br><span class="line">      <span class="title function_">afterPaint</span>(afterPaintEffects.<span class="title function_">push</span>(c));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>\_commit</code><a class="link"   target="_blank" rel="noopener" href="https://github.com/preactjs/preact/blob/master/src/diff/index.js#L230" >位置<i class="fas fa-external-link-alt"></i></a>。初始或者更新 render 结束之后执行<code>_renderCallbacks</code>，在这个<code>\_commit</code>中只执行 hook 的回调，如<code>useLayoutEffect</code>。（<code>_renderCallbacks</code>是指在<code>preact</code>中指每次 render 后，同步执行的操作回调列表，例如<code>setState</code>的第二个参数 cb、或者一些<code>render</code>后的生命周期函数、或者<code>forceUpdate</code>的回调）。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">options.<span class="property">_commit</span> = <span class="function">(<span class="params">vnode, commitQueue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">_commit</span>) options.<span class="title function_">_commit</span>(root, commitQueue);</span><br><span class="line">  commitQueue.<span class="title function_">some</span>(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 执行上次的_renderCallbacks的清理函数</span></span><br><span class="line">    component.<span class="property">_renderCallbacks</span>.<span class="title function_">forEach</span>(invokeCleanup);</span><br><span class="line">    <span class="comment">// _renderCallbacks有可能是setState的第二个参数这种的、或者生命周期、或者forceUpdate的回调。</span></span><br><span class="line">    <span class="comment">// 通过_value判断是hook的回调则在此出执行</span></span><br><span class="line">    component.<span class="property">_renderCallbacks</span> = component.<span class="property">_renderCallbacks</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">cb</span> =&gt;</span></span><br><span class="line">      cb.<span class="property">_value</span> ? <span class="title function_">invokeEffect</span>(cb) : <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldCommit) <span class="title function_">oldCommit</span>(vnode, commitQueue);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>unmount</code>。 组件的卸载之后执行<code>effect</code>的清理操作</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">options.<span class="property">unmount</span> = <span class="function"><span class="params">vnode</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldBeforeUnmount) <span class="title function_">oldBeforeUnmount</span>(vnode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> c = vnode.<span class="property">_component</span>;</span><br><span class="line">  <span class="keyword">if</span> (!c) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hooks = c.<span class="property">__hooks</span>;</span><br><span class="line">  <span class="keyword">if</span> (hooks) &#123;</span><br><span class="line">    <span class="comment">// _cleanup 是effect类hook的清理函数，也就是我们每个effect的callback 的返回值函数</span></span><br><span class="line">    hooks.<span class="property">_list</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">hook</span> =&gt;</span> hook.<span class="property">_cleanup</span> &amp;&amp; hook.<span class="title function_">_cleanup</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于组件来说加入的 hook 只是在 preact 的组件基础上增加一个__hook 属性。在 preact 的内部实现中，无论是函数组件还是 class 组件， 都是实例化成 PreactComponent，如下数据结构</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_">PreactComponent</span>&lt;<span class="built_in">any</span>, <span class="built_in">any</span>&gt; &#123;</span><br><span class="line">  __hooks?: &#123;</span><br><span class="line">    <span class="comment">// 每个组件的hook存储</span></span><br><span class="line">    <span class="attr">_list</span>: <span class="title class_">HookState</span>[];</span><br><span class="line">    <span class="comment">// useLayoutEffect useEffect 等</span></span><br><span class="line">    <span class="attr">_pendingEffects</span>: <span class="title class_">EffectHookState</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于问题 1 的回答，通过上面的分析，我们知道，<code>hook</code>最终是挂在组件的<code>__hooks</code>属性上的，因此，每次渲染的时候只要去读取函数组件本身的属性就能获取上次渲染的状态了，就能实现了函数组件的状态。这里关键在于<code>getHookState</code>这个函数。这个函数也是整个<code>preact</code> <code>hook</code>中非常重要的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getHookState</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.<span class="property">_hook</span>) options.<span class="title function_">_hook</span>(currentComponent);</span><br><span class="line">  <span class="keyword">const</span> hooks =</span><br><span class="line">    currentComponent.<span class="property">__hooks</span> ||</span><br><span class="line">    (currentComponent.<span class="property">__hooks</span> = &#123; <span class="attr">_list</span>: [], <span class="attr">_pendingEffects</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化的时候，创建一个空的hook</span></span><br><span class="line">  <span class="keyword">if</span> (index &gt;= hooks.<span class="property">_list</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    hooks.<span class="property">_list</span>.<span class="title function_">push</span>(&#123;&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hooks.<span class="property">_list</span>[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数是在组件每次执行<code>useXxx</code>的时候，首先执行这一步获取 hook 的状态的（以<a target="_blank" rel="noopener" href="https://github.com/preactjs/preact/blob/master/hooks/src/index.js#L133"><code>useEffect</code></a>为例子）。所有的<code>hook</code>都是使用这个函数先获取自身 hook 状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEffect</span>(<span class="params">callback, args</span>) &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>currentIndex</code>在每一次的<code>render</code>过程中是从 0 开始的，每执行一次<code>useXxx</code>后加一。每个<code>hook</code>在多次<code>render</code>中对于记录前一次的执行状态正是通过<code>currentComponent.__hooks</code>中的顺序决定。所以如果处于条件语句，如果某一次条件不成立，导致那个<code>useXxx</code>没有执行，这个后面的 hook 的顺序就发生错乱并导致 bug。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [state1, setState1] = <span class="title function_">useState</span>();</span><br><span class="line">  <span class="comment">// 假设condition第一次渲染为true，第二次渲染为false</span></span><br><span class="line">  <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="keyword">const</span> [state2, setState2] = <span class="title function_">useState</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [state3, setState3] = <span class="title function_">useState</span>();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>第一次渲染后，<code>__hooks = [hook1,hook2,hook3]</code>。<br>第二次渲染，由于<code>const [state2, setState2] = useState();</code>被跳过，通过<code>currentIndex</code>取到的<code>const [state3, setState3] = useState();</code>其实是<code>hook2</code>。就可能有问题。所以，这就是问题 2，为什么 hook 不能放到条件语句中。</p>
<p>经过上面一些分析，也知道问题 3 为什么 hook 不能用在普通函数了。因为 hook 都依赖了 hook 内的全局变量<code>currentIndex</code>和<code>currentComponent</code>。而普通函数并不会执行<code>options.render</code>钩子重置<code>currentIndex</code>和设置<code>currentComponent</code>，当普通函数执行 hook 的时候，<code>currentIndex</code>为上一个执行 hook 组件的实例的下标，<code>currentComponent</code>为上一个执行 hook 组件的实例。因此直接就有问题了。</p>
<h3 id="hook-分析"><a href="#hook-分析" class="headerlink" title="hook 分析"></a>hook 分析</h3><p>虽然 preact 中的 hook 有很多，数据结构来说只有 3 种<code>HookState</code>结构，所有的 hook 都是在这 3 种的基础上实现的。这 3 种分别是</p>
<ul>
<li><code>EffectHookState</code> (<code>useLayoutEffect</code> <code>useEffect</code> <code>useImperativeHandle</code>)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">EffectHookState</span> &#123;</span><br><span class="line">  <span class="comment">// effect hook的回调函数</span></span><br><span class="line">  _value?: <span class="title class_">Effect</span>;</span><br><span class="line">  <span class="comment">// 依赖项</span></span><br><span class="line">  _args?: <span class="built_in">any</span>[];</span><br><span class="line">  <span class="comment">// effect hook的清理函数，_value的返回值</span></span><br><span class="line">  _cleanup?: <span class="title class_">Cleanup</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MemoHookState</code> （**<code>useMemo</code>** <code>useRef</code> <code>useCallback</code>）</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">MemoHookState</span> &#123;</span><br><span class="line">  <span class="comment">// useMemo的返回值</span></span><br><span class="line">  _value?: <span class="built_in">any</span>;</span><br><span class="line">  <span class="comment">// 前一次的依赖数组</span></span><br><span class="line">  _args?: <span class="built_in">any</span>[];</span><br><span class="line">  <span class="comment">//useMemo传入的callback</span></span><br><span class="line">  _callback?: <span class="function">() =&gt;</span> <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReducerHookState</code> (<strong><code>useReducer</code></strong> <code>useState</code> ``)</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">ReducerHookState</span> &#123;</span><br><span class="line">  _value?: <span class="built_in">any</span>;</span><br><span class="line">  _component?: <span class="title class_">Component</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>useContext</code> 这个比较特殊</li>
</ul>
<h3 id="MemoHookState"><a href="#MemoHookState" class="headerlink" title="MemoHookState"></a>MemoHookState</h3><p><code>MemoHook</code>是一类用来和性能优化有关的 hook</p>
<h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><p>作用：把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 假设calculate是个消耗很多的计算操作</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">calculate</span>(props.<span class="property">xx</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>默认情况下，每次<code>Component</code>渲染都会执行<code>calculate</code>的计算操作，如果<code>calculate</code>是一个大计算量的函数，这里会有造成性能下降，这里就可以使用<code>useMemo</code>来进行优化了。这样如果<code>calculate</code>依赖的值没有变化，就不需要执行这个函数，而是取它的缓存值。要注意的是<code>calculate</code>对外部依赖的值都需要传进依赖项数组，否则当部分值变化是，<code>useMemo</code>却还是旧的值可能会产生 bug。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这样子，只会在props.xx值改变时才重新执行calculate函数，达到了优化的目的</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> <span class="title function_">calculate</span>(props.<span class="property">xx</span>), [props.<span class="property">xx</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;result&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>useMemo</code>源码分析</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useMemo</span>(<span class="params">callback, args</span>) &#123;</span><br><span class="line">  <span class="comment">// state是MemoHookState类型</span></span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="comment">// 判断依赖项是否改变</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">argsChanged</span>(state.<span class="property">_args</span>, args)) &#123;</span><br><span class="line">    <span class="comment">// 存储本次依赖的数据值</span></span><br><span class="line">    state.<span class="property">_args</span> = args;</span><br><span class="line">    state.<span class="property">_callback</span> = callback;</span><br><span class="line">    <span class="comment">// 改变后执行`callback`函数返回值。</span></span><br><span class="line">    <span class="keyword">return</span> (state.<span class="property">_value</span> = <span class="title function_">callback</span>());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state.<span class="property">_value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useMemo</code>的实现逻辑不复杂，判断依赖项是否改变，改变后执行<code>callback</code>函数返回值。值得一提的是，依赖项比较只是普通的<code>===</code>比较，如果依赖的是引用类型，并且直接改变改引用类型上的属性，将不会执行<code>callback</code>。</p>
<h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><p>作用：接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memorized 版本，该回调函数仅在某个依赖项改变时才会更新</p>
<p>假设有这样一段代码</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handle</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(number);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对于每次的渲染，都是新的 handle，因此 diff 都会失效，都会有一个创建一个新的函数，并且绑定新的事件代理的过程。当使用<code>useCallback</code>后则会解决这个问题</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 这里，如果number不变的情况下，每次的handle是同一个值</span></span><br><span class="line">  <span class="keyword">const</span> handle = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(number), [number]);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有一个坑点是，<code>[number]</code>是不能省略的，如果省略的话，每次打印的<code>log</code>永远是<code>number</code>的初始值 0</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 这里永远打印0</span></span><br><span class="line">  <span class="keyword">const</span> handle = <span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(number), []);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>至于为什么这样，结合<code>useMomo</code>的实现分析。<code>useCallback</code>是在<code>useMemo</code>的基础上实现的，只是它不执行这个 callback，而是返回这个 callback，用于执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useCallback</span>(<span class="params">callback, args</span>) &#123;</span><br><span class="line">  <span class="comment">// 直接返回这个callback，而不是执行</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> callback, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们想象一下，每次的函数组件执行，都是一个全新的过程。而我们的 callback 只是挂在<code>MemoHook</code>的<code>_value</code>字段上，当依赖没有改变的时候，我们执行的<code>callback</code>永远是创建的那个时刻那次渲染的形成的闭包函数。而那个时刻的<code>number</code>就是初次的渲染值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 这里永远打印0</span></span><br><span class="line">  <span class="keyword">const</span> handle = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> <span class="comment">/** 到了后面的时候，我们的handle并不是执行这次的callback，而是上次的那个记录的callback*/</span> <span class="function">() =&gt;</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(number),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handle&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>useMemo</code>和<code>useCallback</code>对于性能优化很好用，但是并不是必须的。因为对于大多数的函数来说，一方面创建/调用消耗并不大，而记录依赖项是需要一个遍历数组的对比操作，这个也是需要消耗的。因此并不需要无脑<code>useMemo</code>和<code>useCallback</code>，而是在一些刚好的地方使用才行</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p>作用：useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数（initialValue）。就是在函数组件中替代<code>React.createRef</code>的功能或者类似于<code>this.xxx</code>的功能。在整个周期中，ref 值是不变的</p>
<p>用法一：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> focus = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">() =&gt;</span>inputRef.<span class="title function_">focus</span>(),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;focus&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>用法二：类似于<code>this</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> focus = <span class="title function_">useCallback</span>(</span><br><span class="line">    <span class="function">() =&gt;</span>inputRef.<span class="property">current</span>.<span class="title function_">focus</span>(),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span><span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;node</span> =&gt;</span> inputRef.current = node&#125;&gt;</span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;focus&#125;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>之所以能这么用，在<code>diff</code>过程中于<code>applyRef</code>这个函数，<code>react</code>也是类似。<br>（<code>diff</code>中，通过<code>applyRef</code>将dom对象挂到对应的<code>ref</code>上）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">applyRef</span>(<span class="params">ref, value, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> ref == <span class="string">&quot;function&quot;</span>) <span class="title function_">ref</span>(value);</span><br><span class="line">    <span class="keyword">else</span> ref.<span class="property">current</span> = value;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    options.<span class="title function_">_catchError</span>(e, vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>useRef</code>的源码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useRef</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (&#123; <span class="attr">current</span>: initialValue &#125;), []);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 就是初始化的时候创建一个<code>&#123;current:initialValue&#125;</code>，不依赖任何数据，需要手动赋值修改</p>
<h3 id="ReducerHookState"><a href="#ReducerHookState" class="headerlink" title="ReducerHookState"></a>ReducerHookState</h3><h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><p><code>useReducer</code>和使用<code>redux</code>非常像。</p>
<p>用法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reducer就是平时redux那种reducer函数</span></span><br><span class="line"><span class="comment">// initialState 初始化的state状态</span></span><br><span class="line"><span class="comment">// init 一个函数用于惰性计算state初始值</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState, init);</span><br></pre></td></tr></table></figure>

<p>计数器的例子。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;increment&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">number</span>: state.<span class="property">number</span> + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;decrement&quot;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">number</span>: state.<span class="property">number</span> - <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">init</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">number</span>: initialState &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;state.number&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于熟悉<code>redux</code>的同学来说，一眼明了。后面提到的<code>useState</code>旧是基于<code>useReducer</code>实现的。</p>
<p>源码分析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useReducer</span>(<span class="params">reducer, initialState, init</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> hookState = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="comment">// 前面分析过ReducerHookState的数据结构，有两个属性</span></span><br><span class="line">  <span class="comment">// _value 当前的state值</span></span><br><span class="line">  <span class="comment">// _component 对应的组件实例</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!hookState.<span class="property">_component</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化过程</span></span><br><span class="line">    <span class="comment">// 因为后面需要用到setState更新，所以需要记录component的引用</span></span><br><span class="line">    hookState.<span class="property">_component</span> = currentComponent;</span><br><span class="line"></span><br><span class="line">    hookState.<span class="property">_value</span> = [</span><br><span class="line">      <span class="comment">// init是前面提到的惰性初始化函数，传入了init则初始值是init的计算结果</span></span><br><span class="line">      <span class="comment">// 没传init的时候是invokeOrReturn。这里就是直接返回初始化值</span></span><br><span class="line">      <span class="comment">/***</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * ```js</span></span><br><span class="line"><span class="comment">       * invokeOrReturn 很精髓</span></span><br><span class="line"><span class="comment">       * 参数f为函数，返回 f(arg)</span></span><br><span class="line"><span class="comment">       * 参数f非函数，返回f</span></span><br><span class="line"><span class="comment">       * function invokeOrReturn(arg, f) &#123;</span></span><br><span class="line"><span class="comment">            return typeof f === &quot;function&quot; ? f(arg) : f;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">       * ```</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      !init ? <span class="title function_">invokeOrReturn</span>(<span class="literal">undefined</span>, initialState) : <span class="title function_">init</span>(initialState),</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// reducer函数计算出下次的state的值</span></span><br><span class="line">        <span class="keyword">const</span> nextValue = <span class="title function_">reducer</span>(hookState.<span class="property">_value</span>[<span class="number">0</span>], action);</span><br><span class="line">        <span class="keyword">if</span> (hookState.<span class="property">_value</span>[<span class="number">0</span>] !== nextValue) &#123;</span><br><span class="line">          hookState.<span class="property">_value</span>[<span class="number">0</span>] = nextValue;</span><br><span class="line">          <span class="comment">// setState开始进行下一轮更新</span></span><br><span class="line">          hookState.<span class="property">_component</span>.<span class="title function_">setState</span>(&#123;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前的state</span></span><br><span class="line">  <span class="keyword">return</span> hookState.<span class="property">_value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新<code>state</code>就是调用 demo 的<code>dispatch</code>，也就是通过<code>reducer(preState,action)</code>计算出下次的<code>state</code>赋值给<code>_value</code>。然后调用组件的<code>setState</code>方法进行组件的<code>diff</code>和相应更新操作(这里是<code>preact</code>和<code>react</code>不太一样的一个地方，preact 的函数组件在内部和 class 组件一样使用 component 实现的)。</p>
<h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h4><p><code>useState</code>大概是 hook 中最常用的了。类似于 class 组件中的 state 状态值。</p>
<p>用法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [index, setIndex] = <span class="title function_">useIndex</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;/* setXxx可以传入回调或者直接设置值**/&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setNumber(number =&gt; number + 1)&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        更新number</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">      //</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setIndex(index + 1)&#125;&gt;更新index<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;index&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上文已经提到过，<code>useState</code>是通过<code>useReducer</code>实现的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="comment">/***</span></span><br><span class="line"><span class="comment">       * </span></span><br><span class="line"><span class="comment">       * ```js</span></span><br><span class="line"><span class="comment">       * function invokeOrReturn(arg, f) &#123;</span></span><br><span class="line"><span class="comment">            return typeof f === &quot;function&quot; ? f(arg) : f;</span></span><br><span class="line"><span class="comment">          &#125;</span></span><br><span class="line"><span class="comment">       * ```</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useReducer</span>(invokeOrReturn, initialState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我们给<code>useReduecr</code>的<code>reducer</code>参数传<code>invokeOrReturn</code>函数即可实现<code>useState</code>。回顾下<code>useState</code>和<code>useReducer</code>的用法</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [index, setIndex] = <span class="title function_">useIndex</span>(<span class="number">0</span>);</span><br><span class="line"><span class="title function_">setIndex</span>(<span class="function"><span class="params">index</span> =&gt;</span> index + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="title function_">setIndex</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line"><span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line"><span class="title function_">dispatch</span>(&#123; <span class="attr">type</span>: <span class="string">&quot;some type&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>1、对于<code>setState</code>直接传值的情况。<code>reducer</code>（<code>invokeOrReturn</code>）函数，直接返回入参即可</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action非函数，reducer(hookState._value[0], action)结果为action</span></span><br><span class="line"><span class="keyword">const</span> nextValue = <span class="title function_">reducer</span>(hookState.<span class="property">_value</span>[<span class="number">0</span>], action);</span><br></pre></td></tr></table></figure>

<p>2、对于<code>setState</code>直接参数的情况的情况。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// action为函数，reducer(hookState._value[0], action)结果为action(hookState._value[0])</span></span><br><span class="line"><span class="keyword">const</span> nextValue = <span class="title function_">reducer</span>(hookState.<span class="property">_value</span>[<span class="number">0</span>], action);</span><br></pre></td></tr></table></figure>

<p>可见，<code>useState</code>其实只是传特定<code>reducer</code>的<code>useReducer</code>一种实现。</p>
<h3 id="EffectHookState"><a href="#EffectHookState" class="headerlink" title="EffectHookState"></a>EffectHookState</h3><ul>
<li><code>useEffect</code> 和 <code>useLayoutEffect</code></li>
</ul>
<p>这两个 hook 的用法完全一致，都是在 render 过程中执行一些副作用的操作，可来实现以往 class 组件中一些生命周期的操作。<strong>区别</strong>在于，<br><code>useEffect</code> 的 callback 执行是在本次渲染结束之后，下次渲染之前执行。 <code>useLayoutEffect</code>则是在本次会在浏览器 layout 之后，painting 之前执行，是同步的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/11/11/16e58f8e4de77ef2?w=1310&h=650&f=png&s=267591"></p>
<p>用法。传递一个回调函数和一个依赖数组，数组的依赖参数变化时，重新执行回调。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收一个包含一些必要副作用代码的函数，这个函数需要从DOM中读取layout和同步re-render</span></span><br><span class="line"><span class="comment"> *  `useLayoutEffect` 里面的操作将在DOM变化之后，浏览器绘制之前 执行</span></span><br><span class="line"><span class="comment"> * 尽量使用`useEffect`避免阻塞视图更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> effect Imperative function that can return a cleanup function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputs If present, effect will only activate if the values in the list change (using ===).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useLayoutEffect</span>(<span class="params">effect: EffectCallback, inputs?: Inputs</span>): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收一个包含一些必要副作用代码的函数。</span></span><br><span class="line"><span class="comment"> * 副作用函数会在浏览器绘制后执行，不会阻塞渲染</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> effect Imperative function that can return a cleanup function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputs If present, effect will only activate if the values in the list change (using ===).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEffect</span>(<span class="params">effect: EffectCallback, inputs?: Inputs</span>): <span class="built_in">void</span>;</span><br></pre></td></tr></table></figure>

<p><a class="link"   target="_blank" rel="noopener" href="https://codesandbox.io/s/old-sun-91m9z" >demo<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">LayoutEffect</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [color, setColor] = <span class="title function_">useState</span>(<span class="string">&quot;red&quot;</span>);</span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(color);</span><br><span class="line">  &#125;, [color]);</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">alert</span>(color);</span><br><span class="line">  &#125;, [color]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myDiv&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> <span class="attr">color</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        颜色</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&quot;red&quot;)&#125;&gt;红<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&quot;yellow&quot;)&#125;&gt;黄<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setColor(&quot;blue&quot;)&#125;&gt;蓝<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 demo 可以看出，每次改变颜色，<code>useLayoutEffect</code>的回调触发时机是在页面改变颜色之前，而<code>useEffect</code>的回调触发时机是页面改变颜色之后。它们的实现如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useLayoutEffect</span>(<span class="params">callback, args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">argsChanged</span>(state.<span class="property">_args</span>, args)) &#123;</span><br><span class="line">    state.<span class="property">_value</span> = callback;</span><br><span class="line">    state.<span class="property">_args</span> = args;</span><br><span class="line"></span><br><span class="line">    currentComponent.<span class="property">_renderCallbacks</span>.<span class="title function_">push</span>(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useEffect</span>(<span class="params">callback, args</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">argsChanged</span>(state.<span class="property">_args</span>, args)) &#123;</span><br><span class="line">    state.<span class="property">_value</span> = callback;</span><br><span class="line">    state.<span class="property">_args</span> = args;</span><br><span class="line"></span><br><span class="line">    currentComponent.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span>.<span class="title function_">push</span>(state);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它们的实现几乎一模一样，唯一的区别是<code>useLayoutEffect</code>的回调进的是<code>_renderCallbacks</code>数组，而<code>useEffect</code>的回调进的是<code>_pendingEffects</code>。</p>
<p>前面已经做过一些分析，<code>_renderCallbacks</code>是在<code>\_commit</code>钩子中执行的，在这里执行上次<code>renderCallbacks</code>的<code>effect</code>的清理函数和执行本次的<code>renderCallbacks</code>。<code>\_commit</code>则是在<code>preact</code>的<code>commitRoot</code>中被调用，即每次 render 后同步调用（顾名思义 renderCallback 就是 render 后的回调，此时 DOM 已经更新完，浏览器还没有 paint 新一帧，上图所示的 layout 后 paint 前）因此 demo 中我们在这里<code>alert</code>会阻塞浏览器的 paint，这个时候看不到颜色的变化。</p>
<p>而<code>_pendingEffects</code>则是本次重绘之后，下次重绘之前执行。在 hook 中的调用关系如下</p>
<p>1、 <code>options.differed</code> 钩子中（即组件 diff 完成后），执行<code>afterPaint(afterPaintEffects.push(c))</code>将含有<code>_pendingEffects</code>的组件推进全局的<code>afterPaintEffects</code>队列</p>
<p>2、<code>afterPaint</code>中执行执行<code>afterNextFrame(flushAfterPaintEffects)</code>。在下一帧 重绘之前，执行<code>flushAfterPaintEffects</code>。同时，如果 100ms 内，当前帧的 requestAnimationFrame 没有结束(例如窗口不可见的情况)，则直接执行<code>flushAfterPaintEffects</code>。<code>flushAfterPaintEffects</code>函数执行队列内所有组件的上一次的<code>_pendingEffects</code>的清理函数和执行本次的<code>_pendingEffects</code>。</p>
<p>几个关键函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绘制之后执行回调</span></span><br><span class="line"><span class="comment"> * 执行队列内所有组件的上一次的`_pendingEffects`的清理函数和执行本次的`_pendingEffects`。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flushAfterPaintEffects</span>(<span class="params"></span>) &#123;</span><br><span class="line">  afterPaintEffects.<span class="title function_">some</span>(<span class="function"><span class="params">component</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (component.<span class="property">_parentDom</span>) &#123;</span><br><span class="line">      <span class="comment">// 清理上一次的_pendingEffects</span></span><br><span class="line">      component.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span>.<span class="title function_">forEach</span>(invokeCleanup);</span><br><span class="line">      <span class="comment">// 执行当前_pendingEffects</span></span><br><span class="line">      component.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span>.<span class="title function_">forEach</span>(invokeEffect);</span><br><span class="line">      component.<span class="property">__hooks</span>.<span class="property">_pendingEffects</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 清空afterPaintEffects</span></span><br><span class="line">  afterPaintEffects = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *preact的diff是同步的，是宏任务。 </span></span><br><span class="line"><span class="comment">  newQueueLength === 1 保证了afterPaint内的afterNextFrame(flushAfterPaintEffects)只执行一遍。因为会调用n次宏任务的afterPaint结束后，才会执行flushAfterPaintEffects一次将所有含有pendingEffect的组件进行回调进行</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line">afterPaint = <span class="function"><span class="params">newQueueLength</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (newQueueLength === <span class="number">1</span> || prevRaf !== options.<span class="property">requestAnimationFrame</span>) &#123;</span><br><span class="line">    prevRaf = options.<span class="property">requestAnimationFrame</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行下一帧结束后，清空 useEffect的回调</span></span><br><span class="line">    (prevRaf || afterNextFrame)(flushAfterPaintEffects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希望在下一帧 重绘之前，执行callback。同时，如果100ms内，当前帧的requestAnimationFrame没有结束(例如窗口不可见的情况)，则直接执行callback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">afterNextFrame</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">done</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    <span class="title function_">cancelAnimationFrame</span>(raf);</span><br><span class="line">    <span class="built_in">setTimeout</span>(callback);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> timeout = <span class="built_in">setTimeout</span>(done, <span class="variable constant_">RAF_TIMEOUT</span>);</span><br><span class="line">  <span class="keyword">const</span> raf = <span class="title function_">requestAnimationFrame</span>(done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><p>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React文档的例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FancyInput</span>(<span class="params">props, ref</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>();</span><br><span class="line">  <span class="comment">// 第一个参数是 父组件 ref</span></span><br><span class="line">  <span class="comment">// 第二个参数是返回，返回的对象会作为父组件 ref current 属性的值</span></span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">focus</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">FancyInput</span> = <span class="title function_">forwardRef</span>(<span class="title class_">FancyInput</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">FancyInput</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>ref.focus()&#125;&gt;click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>默认情况下，函数组件是没有<code>ref</code>属性，通过<code>forwardRef(FancyInput)</code>后，父组件就可以往子函数组件传递<code>ref</code>属性了。</del><code>useImperativeHandle</code>的作用就是控制父组件不能在拿到子组件的<code>ref</code>后为所欲为。如上，父组件拿到<code>FancyInput</code>后，只能执行<code>focus</code>，即子组件决定对外暴露的 ref 接口，<code>class</code>组件是无法做到的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useImperativeHandle</span>(<span class="params">ref, createHandle, args</span>) &#123;</span><br><span class="line">  <span class="title function_">useLayoutEffect</span>(</span><br><span class="line">    <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> ref === <span class="string">&quot;function&quot;</span>) <span class="title function_">ref</span>(<span class="title function_">createHandle</span>());</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ref) ref.<span class="property">current</span> = <span class="title function_">createHandle</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">    args == <span class="literal">null</span> ? args : args.<span class="title function_">concat</span>(ref)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useImperativeHandle</code>的实现也是一目了然，因为这种是涉及到 dom 更新后的同步修改，所以是用<code>useLayoutEffect</code>实现的。从实现可看出，<code>useImperativeHandle</code>也能接收依赖项数组的</p>
<h3 id="createContext"><a href="#createContext" class="headerlink" title="createContext"></a>createContext</h3><p>接收一个 context 对象（Preact.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 <code>&lt;MyContext.Provider&gt;</code> 的 value prop 决定。当组件上层最近的<code>&lt;MyContext.Provider&gt;</code> 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。</p>
<p>使用 context 最大的好处就是避免了深层组件嵌套时，需要一层层往下通过 props 传值。使用 createContext 可以非常方便的使用 context 而不用再写繁琐的<code>Consumer</code></p>
<p><a class="link"   target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/context.html#reactcreatecontext" >react context<i class="fas fa-external-link-alt"></i></a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = <span class="title class_">Preact</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Component</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 每当Context.Provider value=&#123;&#123;xx:xx&#125;&#125;变化时，Component都会重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> &#123; xx &#125; = <span class="title function_">useContext</span>(context);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Context.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">xx:</span> <span class="attr">xx</span> &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Component</span>&gt;</span><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Context.Provider</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>useContext</code>实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useContext</span>(<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 每个`preact`组件的context属性都保存着当前全局context的Provider引用，不同的context都有一个唯一id</span></span><br><span class="line">  <span class="comment">// 获取当前组件 所属的Context Provider</span></span><br><span class="line">  <span class="keyword">const</span> provider = currentComponent.<span class="property">context</span>[context.<span class="property">_id</span>];</span><br><span class="line">  <span class="keyword">if</span> (!provider) <span class="keyword">return</span> context.<span class="property">_defaultValue</span>;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">getHookState</span>(currentIndex++);</span><br><span class="line">  <span class="keyword">if</span> (state.<span class="property">_value</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化的时候将当前 组件订阅 Provider的value变化</span></span><br><span class="line">    <span class="comment">// 当Provider的value变化时，重新渲染当前组件</span></span><br><span class="line">    state.<span class="property">_value</span> = <span class="literal">true</span>;</span><br><span class="line">    provider.<span class="title function_">sub</span>(currentComponent);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> provider.<span class="property">props</span>.<span class="property">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，<code>useContext</code>会在初始化的时候，当前组件对应的<code>Context.Provider</code>会把该组件加入订阅回调(<code>provider.sub(currentComponent)</code>)，当 Provider value 变化时，在 Provider 的<code>shouldComponentUpdate</code>周期中执行组件的 render。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="comment">// Provider部分源码</span></span><br><span class="line">    <span class="title class_">Provider</span>(props) &#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">      <span class="comment">// 初始化Provider的时候执行的部分</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">shouldComponentUpdate</span> = <span class="function"><span class="params">_props</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (props.<span class="property">value</span> !== _props.<span class="property">value</span>) &#123;</span><br><span class="line">            subs.<span class="title function_">some</span>(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">              c.<span class="property">context</span> = _props.<span class="property">value</span>;</span><br><span class="line">              <span class="comment">// 执行sub订阅回调组件的render</span></span><br><span class="line">              <span class="title function_">enqueueRender</span>(c);</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sub</span> = <span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">          subs.<span class="title function_">push</span>(c);</span><br><span class="line">          <span class="keyword">let</span> old = c.<span class="property">componentWillUnmount</span>;</span><br><span class="line">          c.<span class="property">componentWillUnmount</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 组件卸载的时候，从订阅回调组件列表中移除</span></span><br><span class="line">            subs.<span class="title function_">splice</span>(subs.<span class="title function_">indexOf</span>(c), <span class="number">1</span>);</span><br><span class="line">            old &amp;&amp; old.<span class="title function_">call</span>(c);</span><br><span class="line">          &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"> <span class="comment">//....</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结： <code>preact</code>和<code>react</code>在源码实现上有一定差异，但是通过对 preact hook 源码的学习，对于理解 hook 的很多观念和思想是非常有帮助的。</p>
<hr>
<p>最后附上带了注释的 hook 源码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; options &#125; <span class="keyword">from</span> <span class="string">&quot;preact&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\*_ @type &#123;number&#125; _/</span></span><br><span class="line"><span class="keyword">let</span> currentIndex;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/\*_ @type &#123;import(&#x27;./i</span>nternal<span class="string">&#x27;).Component&#125; _/</span></span><br><span class="line"><span class="string">let currentComponent;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*_ @type &#123;Array&lt;import(&#x27;</span>./internal<span class="string">&#x27;).Component&gt;&#125; _/</span></span><br><span class="line"><span class="string">let afterPaintEffects = [];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let oldBeforeRender = options.\_render;</span></span><br><span class="line"><span class="string">options.\_render = vnode =&gt; &#123;</span></span><br><span class="line"><span class="string">// render 钩子函数</span></span><br><span class="line"><span class="string">if (oldBeforeRender) oldBeforeRender(vnode);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">currentComponent = vnode.\_component;</span></span><br><span class="line"><span class="string">currentIndex = 0;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if (currentComponent.**hooks) &#123;</span></span><br><span class="line"><span class="string">// 执行清理操作</span></span><br><span class="line"><span class="string">currentComponent.**hooks.\_pendingEffects.forEach(invokeCleanup);</span></span><br><span class="line"><span class="string">// 执行 effect</span></span><br><span class="line"><span class="string">currentComponent.**hooks.\_pendingEffects.forEach(invokeEffect);</span></span><br><span class="line"><span class="string">currentComponent.**hooks.\_pendingEffects = [];</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// \_pendingEffects paint 后调用</span></span><br><span class="line"><span class="string">// \_renderCallbacks render 后同步调用</span></span><br><span class="line"><span class="string">// render（执行 render 方法之前） -&gt; diffed（diff 结束） -&gt; \_commit(初始或者更新生命周期结束之后) -&gt; unmount（卸载）</span></span><br><span class="line"><span class="string">let oldAfterDiff = options.diffed;</span></span><br><span class="line"><span class="string">options.diffed = vnode =&gt; &#123;</span></span><br><span class="line"><span class="string">if (oldAfterDiff) oldAfterDiff(vnode);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const c = vnode.\_component;</span></span><br><span class="line"><span class="string">if (!c) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const hooks = c.\_\_hooks;</span></span><br><span class="line"><span class="string">if (hooks) &#123;</span></span><br><span class="line"><span class="string">if (hooks.\_pendingEffects.length) &#123;</span></span><br><span class="line"><span class="string">afterPaint(afterPaintEffects.push(c));</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let oldCommit = options.\_commit;</span></span><br><span class="line"><span class="string">options.\_commit = (vnode, commitQueue) =&gt; &#123;</span></span><br><span class="line"><span class="string">commitQueue.some(component =&gt; &#123;</span></span><br><span class="line"><span class="string">component.\_renderCallbacks.forEach(invokeCleanup);</span></span><br><span class="line"><span class="string">// \_renderCallbacks 有可能是 setState 的第二个参数这种的、或者生命周期、或者 forceUpdate 的回调。</span></span><br><span class="line"><span class="string">// 通过\_value 判断是 hook 的回调</span></span><br><span class="line"><span class="string">component.\_renderCallbacks = component.\_renderCallbacks.filter(cb =&gt;</span></span><br><span class="line"><span class="string">cb.\_value ? invokeEffect(cb) : true</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if (oldCommit) oldCommit(vnode, commitQueue);</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">let oldBeforeUnmount = options.unmount;</span></span><br><span class="line"><span class="string">options.unmount = vnode =&gt; &#123;</span></span><br><span class="line"><span class="string">if (oldBeforeUnmount) oldBeforeUnmount(vnode);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const c = vnode.\_component;</span></span><br><span class="line"><span class="string">if (!c) return;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const hooks = c.\_\_hooks;</span></span><br><span class="line"><span class="string">if (hooks) &#123;</span></span><br><span class="line"><span class="string">hooks.\_list.forEach(hook =&gt; hook.\_cleanup &amp;&amp; hook.\_cleanup());</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Get a hook&#x27;</span>s state <span class="keyword">from</span> the currentComponent</span><br><span class="line">- @param &#123;number&#125; index <span class="title class_">The</span> index <span class="keyword">of</span> the hook to get</span><br><span class="line">- @returns &#123;<span class="keyword">import</span>(<span class="string">&#x27;./internal&#x27;</span>).<span class="property">HookState</span>&#125;</span><br><span class="line">  _/</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getHookState</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (options.\_hook) options.\<span class="title function_">_hook</span>(currentComponent);</span><br><span class="line">  <span class="comment">// Largely inspired by:</span></span><br><span class="line">  <span class="comment">// _ https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs</span></span><br><span class="line">  <span class="comment">// _ https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs</span></span><br><span class="line">  <span class="comment">// Other implementations to look at:</span></span><br><span class="line">  <span class="comment">// _ https://codesandbox.io/s/mnox05qp8</span></span><br><span class="line">  <span class="keyword">const</span> hooks =</span><br><span class="line">  currentComponent.**hooks ||</span><br><span class="line">  (currentComponent.**hooks = &#123; \<span class="attr">_list</span>: [], \<span class="attr">_pendingEffects</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化的时候新 hook 的情况</span></span><br><span class="line"><span class="keyword">if</span> (index &gt;= hooks.\_list.<span class="property">length</span>) &#123;</span><br><span class="line">hooks.\_list.<span class="title function_">push</span>(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> hooks.\_list[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @param &#123;<span class="keyword">import</span>(<span class="string">&#x27;./index&#x27;</span>).<span class="property">StateUpdater</span>&lt;any&gt;&#125; initialState</span><br><span class="line">  \*/</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initialState</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">useReducer</span>(invokeOrReturn, initialState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- @param &#123;<span class="keyword">import</span>(<span class="string">&#x27;./index&#x27;</span>).<span class="property">Reducer</span>&lt;any, any&gt;&#125; reducer</span><br><span class="line">- @param &#123;<span class="keyword">import</span>(<span class="string">&#x27;./index&#x27;</span>).<span class="property">StateUpdater</span>&lt;any&gt;&#125; initialState</span><br><span class="line">- @param &#123;<span class="function">(<span class="params">initialState: any</span>) =&gt;</span> <span class="keyword">void</span>&#125; [init]</span><br><span class="line">- @returns &#123;[ any, <span class="function">(<span class="params">state: any</span>) =&gt;</span> <span class="keyword">void</span> ]&#125;</span><br><span class="line">  _/</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useReducer</span>(<span class="params">reducer, initialState, init</span>) &#123;</span><br><span class="line">  <span class="regexp">/\*\* @type &#123;import(&#x27;./i</span>nternal<span class="string">&#x27;).ReducerHookState&#125; _/</span></span><br><span class="line"><span class="string">  const hookState = getHookState(currentIndex++);</span></span><br><span class="line"><span class="string">  if (!hookState.\_component) &#123;</span></span><br><span class="line"><span class="string">  hookState.\_component = currentComponent;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      hookState._value = [</span></span><br><span class="line"><span class="string">        !init ? invokeOrReturn(undefined, initialState) : init(initialState),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        action =&gt; &#123;</span></span><br><span class="line"><span class="string">          const nextValue = reducer(hookState._value[0], action);</span></span><br><span class="line"><span class="string">          if (hookState._value[0] !== nextValue) &#123;</span></span><br><span class="line"><span class="string">            hookState._value[0] = nextValue;</span></span><br><span class="line"><span class="string">            hookState._component.setState(&#123;&#125;);</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return hookState.\_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;import(&#x27;</span>./internal<span class="string">&#x27;).Effect&#125; callback</span></span><br><span class="line"><span class="string">- @param &#123;any[]&#125; args</span></span><br><span class="line"><span class="string">  _/</span></span><br><span class="line"><span class="string">  export function useEffect(callback, args) &#123;</span></span><br><span class="line"><span class="string">  /\*\* @type &#123;import(&#x27;</span>./internal<span class="string">&#x27;).EffectHookState&#125; _/</span></span><br><span class="line"><span class="string">  const state = getHookState(currentIndex++);</span></span><br><span class="line"><span class="string">  if (argsChanged(state.\_args, args)) &#123;</span></span><br><span class="line"><span class="string">  state.\_value = callback;</span></span><br><span class="line"><span class="string">  state.\_args = args;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      currentComponent.__hooks._pendingEffects.push(state);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;import(&#x27;</span>./internal<span class="string">&#x27;).Effect&#125; callback</span></span><br><span class="line"><span class="string">- @param &#123;any[]&#125; args</span></span><br><span class="line"><span class="string">  _/</span></span><br><span class="line"><span class="string">  export function useLayoutEffect(callback, args) &#123;</span></span><br><span class="line"><span class="string">  /\*\* @type &#123;import(&#x27;</span>./internal<span class="string">&#x27;).EffectHookState&#125; _/</span></span><br><span class="line"><span class="string">  const state = getHookState(currentIndex++);</span></span><br><span class="line"><span class="string">  if (argsChanged(state.\_args, args)) &#123;</span></span><br><span class="line"><span class="string">  state.\_value = callback;</span></span><br><span class="line"><span class="string">  state.\_args = args;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      currentComponent._renderCallbacks.push(state);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export function useRef(initialValue) &#123;</span></span><br><span class="line"><span class="string">return useMemo(() =&gt; (&#123; current: initialValue &#125;), []);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;object&#125; ref</span></span><br><span class="line"><span class="string">- @param &#123;() =&gt; object&#125; createHandle</span></span><br><span class="line"><span class="string">- @param &#123;any[]&#125; args</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  export function useImperativeHandle(ref, createHandle, args) &#123;</span></span><br><span class="line"><span class="string">  useLayoutEffect(</span></span><br><span class="line"><span class="string">  () =&gt; &#123;</span></span><br><span class="line"><span class="string">  if (typeof ref === &quot;function&quot;) ref(createHandle());</span></span><br><span class="line"><span class="string">  else if (ref) ref.current = createHandle();</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  args == null ? args : args.concat(ref)</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;() =&gt; any&#125; callback</span></span><br><span class="line"><span class="string">- @param &#123;any[]&#125; args</span></span><br><span class="line"><span class="string">  _/</span></span><br><span class="line"><span class="string">  export function useMemo(callback, args) &#123;</span></span><br><span class="line"><span class="string">  /\*\* @type &#123;import(&#x27;</span>./internal<span class="string">&#x27;).MemoHookState&#125; _/</span></span><br><span class="line"><span class="string">  const state = getHookState(currentIndex++);</span></span><br><span class="line"><span class="string">  if (argsChanged(state.\_args, args)) &#123;</span></span><br><span class="line"><span class="string">  state.\_args = args;</span></span><br><span class="line"><span class="string">  state.\_callback = callback;</span></span><br><span class="line"><span class="string">  return (state.\_value = callback());</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">return state.\_value;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;() =&gt; void&#125; callback</span></span><br><span class="line"><span class="string">- @param &#123;any[]&#125; args</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  export function useCallback(callback, args) &#123;</span></span><br><span class="line"><span class="string">  return useMemo(() =&gt; callback, args);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- @param &#123;import(&#x27;</span>./internal<span class="string">&#x27;).PreactContext&#125; context</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  export function useContext(context) &#123;</span></span><br><span class="line"><span class="string">  const provider = currentComponent.context[context._id];</span></span><br><span class="line"><span class="string">  if (!provider) return context.\_defaultValue;</span></span><br><span class="line"><span class="string">  const state = getHookState(currentIndex++);</span></span><br><span class="line"><span class="string">  // This is probably not safe to convert to &quot;!&quot;</span></span><br><span class="line"><span class="string">  if (state.\_value == null) &#123;</span></span><br><span class="line"><span class="string">  state.\_value = true;</span></span><br><span class="line"><span class="string">  provider.sub(currentComponent);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return provider.props.value;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Display a custom label for a custom hook for the devtools panel</span></span><br><span class="line"><span class="string">- @type &#123;&lt;T&gt;(value: T, cb?: (value: T) =&gt; string | number) =&gt; void&#125;</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  export function useDebugValue(value, formatter) &#123;</span></span><br><span class="line"><span class="string">  if (options.useDebugValue) &#123;</span></span><br><span class="line"><span class="string">  options.useDebugValue(formatter ? formatter(value) : value);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// Note: if someone used Component.debounce = requestAnimationFrame,</span></span><br><span class="line"><span class="string">// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.</span></span><br><span class="line"><span class="string">// Perhaps this is not such a big deal.</span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Schedule afterPaintEffects flush after the browser paints</span></span><br><span class="line"><span class="string">- @type &#123;(newQueueLength: number) =&gt; void&#125;</span></span><br><span class="line"><span class="string">  _/</span></span><br><span class="line"><span class="string">  /_ istanbul ignore next \*/</span></span><br><span class="line"><span class="string">  let afterPaint = () =&gt; &#123;&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 绘制之后执行回调</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  function flushAfterPaintEffects() &#123;</span></span><br><span class="line"><span class="string">  afterPaintEffects.some(component =&gt; &#123;</span></span><br><span class="line"><span class="string">  if (component.\_parentDom) &#123;</span></span><br><span class="line"><span class="string">  // 清理上一次的 Effect</span></span><br><span class="line"><span class="string">  component.**hooks.\_pendingEffects.forEach(invokeCleanup);</span></span><br><span class="line"><span class="string">  // 执行当前 effect</span></span><br><span class="line"><span class="string">  component.**hooks.\_pendingEffects.forEach(invokeEffect);</span></span><br><span class="line"><span class="string">  component.\_\_hooks.\_pendingEffects = [];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">  afterPaintEffects = [];</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const RAF_TIMEOUT = 100;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 希望在下一帧 重绘之前，执行 callback。同时，如果 100ms 内，当前帧没有结束(例如窗口不可见的情况)，则直接执行 callback</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  function afterNextFrame(callback) &#123;</span></span><br><span class="line"><span class="string">  const done = () =&gt; &#123;</span></span><br><span class="line"><span class="string">  clearTimeout(timeout);</span></span><br><span class="line"><span class="string">  cancelAnimationFrame(raf);</span></span><br><span class="line"><span class="string">  setTimeout(callback);</span></span><br><span class="line"><span class="string">  &#125;;</span></span><br><span class="line"><span class="string">  const timeout = setTimeout(done, RAF_TIMEOUT);</span></span><br><span class="line"><span class="string">  const raf = requestAnimationFrame(done);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/_ istanbul ignore else _/</span></span><br><span class="line"><span class="string">if (typeof window !== &quot;undefined&quot;) &#123;</span></span><br><span class="line"><span class="string">let prevRaf = options.requestAnimationFrame;</span></span><br><span class="line"><span class="string">afterPaint = newQueueLength =&gt; &#123;</span></span><br><span class="line"><span class="string">if (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) &#123;</span></span><br><span class="line"><span class="string">prevRaf = options.requestAnimationFrame;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      // 执行下一帧结束后，清空 useEffect的回调</span></span><br><span class="line"><span class="string">      (prevRaf || afterNextFrame)(flushAfterPaintEffects);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 执行清理 effect 操作。</span></span><br><span class="line"><span class="string">- @param &#123;import(&#x27;</span>./internal<span class="string">&#x27;).EffectHookState&#125; hook</span></span><br><span class="line"><span class="string">  \*/</span></span><br><span class="line"><span class="string">  function invokeCleanup(hook) &#123;</span></span><br><span class="line"><span class="string">  if (hook.\_cleanup) hook.\_cleanup();</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/\*\*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 执行 effect hook 的 cb，并将清理函数赋值给\_cleanup</span></span><br><span class="line"><span class="string">- Invoke a Hook&#x27;</span>s effect</span><br><span class="line">- @param &#123;<span class="keyword">import</span>(<span class="string">&#x27;./internal&#x27;</span>).<span class="property">EffectHookState</span>&#125; hook</span><br><span class="line">  \*/</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeEffect</span>(<span class="params">hook</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result = hook.\<span class="title function_">_value</span>();</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>) hook.\_cleanup = result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- 判断两个数组是否变化</span><br><span class="line">- @param &#123;any[]&#125; oldArgs</span><br><span class="line">- @param &#123;any[]&#125; newArgs</span><br><span class="line">  \*/</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">argsChanged</span>(<span class="params">oldArgs, newArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> !oldArgs || newArgs.<span class="title function_">some</span>(<span class="function">(<span class="params">arg, index</span>) =&gt;</span> arg !== oldArgs[index]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">/\*\*</span><br><span class="line"></span><br><span class="line">- 执行或者返回</span><br><span class="line">  \*/</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">invokeOrReturn</span>(<span class="params">arg, f</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> f === <span class="string">&quot;function&quot;</span> ? <span class="title function_">f</span>(arg) : f;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>Post title：preact hook源码逐行解析</li>
        <li>Post author：flytam</li>
        <li>Create time：2019-11-11 13:39:34</li>
        <li>
            Post link：https://blog.flytam.vip/preact hook源码逐行解析.html
        </li>
        <li>
            Copyright Notice：All articles in this blog are licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> unless stating additionally.
        </li>
    </ul>
</div>

            </div>
        

        
            <ul class="post-tags-box">
                
                    <li class="tag-item">
                        <a href="/tags/react/">#react</a>&nbsp;
                    </li>
                
            </ul>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/Go%E4%B9%8B%E6%95%B0%E7%BB%84!%E5%88%87%E7%89%87.html"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">Go之数组/切片</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/%E7%AE%80%E6%9E%90redux%E6%8A%80%E6%9C%AF%E6%A0%88(%E4%BA%8C)%EF%BC%9A%E8%AE%A4%E8%AF%86saga%E7%9A%84buffer%E5%92%8Cchanel.html"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">简析redux技术栈(二)：认识saga的buffer和chanel</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2016</span>
              -
            
            2024&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">flytam</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                    <span id="busuanzi_container_site_uv">
                        Visitor Count&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp;
                    </span>
                
                
                    <span id="busuanzi_container_site_pv">
                        Totalview&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        <div class="info-item">
          <a target="_blank" href="https://github.com/flytam/github-issue-to-hexo">Generated by github-issue-to-hexo</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        
            <li class="tools-item rss flex-center">
                <a class="flex-center"
                   href="/atom.xml"
                   target="_blank"
                >
                    <i class="fas fa-rss"></i>
                </a>
            </li>
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80"><span class="nav-text">基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hook-%E5%88%86%E6%9E%90"><span class="nav-text">hook 分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MemoHookState"><span class="nav-text">MemoHookState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useMemo"><span class="nav-text">useMemo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useCallback"><span class="nav-text">useCallback</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useRef"><span class="nav-text">useRef</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReducerHookState"><span class="nav-text">ReducerHookState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useReducer"><span class="nav-text">useReducer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#useState"><span class="nav-text">useState</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EffectHookState"><span class="nav-text">EffectHookState</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#useImperativeHandle"><span class="nav-text">useImperativeHandle</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#createContext"><span class="nav-text">createContext</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script>




<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script>
    
</div>



</body>
</html>
